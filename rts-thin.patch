diff --git a/contrib/seeds/generate-seeds.py b/contrib/seeds/generate-seeds.py
index a3d035218..83802a73f 100755
--- a/contrib/seeds/generate-seeds.py
+++ b/contrib/seeds/generate-seeds.py
@@ -129,8 +129,8 @@ def main():
     with open(os.path.join(indir,'nodes_main.txt'),'r') as f:
         process_nodes(g, f, 'pnSeed6_main', 8333)
     g.write('\n')
-    with open(os.path.join(indir,'nodes_test.txt'),'r') as f:
-        process_nodes(g, f, 'pnSeed6_test', 18333)
+    #with open(os.path.join(indir,'nodes_test.txt'),'r') as f:
+    #    process_nodes(g, f, 'pnSeed6_test', 18333)
     g.write('#endif // BITCOIN_CHAINPARAMSSEEDS_H\n')
             
 if __name__ == '__main__':
diff --git a/depends/packages/libevent.mk b/depends/packages/libevent.mk
index 2e9be1e98..9a0ab91d4 100644
--- a/depends/packages/libevent.mk
+++ b/depends/packages/libevent.mk
@@ -3,10 +3,11 @@ $(package)_version=2.0.22
 $(package)_download_path=https://github.com/libevent/libevent/releases/download/release-2.0.22-stable
 $(package)_file_name=$(package)-$($(package)_version)-stable.tar.gz
 $(package)_sha256_hash=71c2c49f0adadacfdbe6332a372c38cf9c8b7895bb73dabeaa53cdcc1d4e1fa3
-$(package)_patches=reuseaddr.patch
+$(package)_patches=reuseaddr.patch zu_mingw_w64.patch
 
 define $(package)_preprocess_cmds
-  patch -p1 < $($(package)_patch_dir)/reuseaddr.patch
+  patch -p1 < $($(package)_patch_dir)/reuseaddr.patch && \
+  patch -p1 < $($(package)_patch_dir)/zu_mingw_w64.patch
 endef
 
 define $(package)_set_vars
diff --git a/depends/patches/libevent/zu_mingw_w64.patch b/depends/patches/libevent/zu_mingw_w64.patch
new file mode 100644
index 000000000..13d0a57df
--- /dev/null
+++ b/depends/patches/libevent/zu_mingw_w64.patch
@@ -0,0 +1,22 @@
+commit 79b69d8be535a78f2b02dd4e7e90227c1e9bfacd
+Author: Azat Khuzhin <a3at.mail@gmail.com>
+Date:   Wed Feb 24 14:10:21 2016 +0300
+
+    util: fix "%zu" format on TDM-gcc/MinGW-w64
+    
+    From: @gvanem
+    Fixes: #326
+
+diff --git a/util-internal.h b/util-internal.h
+index db4e5f3..06aa972 100644
+--- a/util-internal.h
++++ b/util-internal.h
+@@ -417,7 +417,7 @@ HMODULE evutil_load_windows_system_library_(const TCHAR *library_name);
+ #define EV_SOCK_ARG(x) (x)
+ #endif
+ 
+-#if defined(__STDC__) && defined(__STDC_VERSION__)
++#if defined(__STDC__) && defined(__STDC_VERSION__) && !defined(__MINGW64_VERSION_MAJOR)
+ #if (__STDC_VERSION__ >= 199901L)
+ #define EV_SIZE_FMT "%zu"
+ #define EV_SSIZE_FMT "%zd"
diff --git a/src/Makefile.am b/src/Makefile.am
index 52316a9fd..59b0ce127 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -116,14 +116,11 @@ BITCOIN_CORE_H = \
   main.h \
   memusage.h \
   merkleblock.h \
-  miner.h \
   net.h \
   netbase.h \
   noui.h \
-  policy/fees.h \
   policy/policy.h \
   policy/rbf.h \
-  pow.h \
   prevector.h \
   primitives/block.h \
   primitives/transaction.h \
@@ -196,15 +193,11 @@ libbitcoin_server_a_SOURCES = \
   dbwrapper.cpp \
   main.cpp \
   merkleblock.cpp \
-  miner.cpp \
   net.cpp \
   noui.cpp \
-  policy/fees.cpp \
   policy/policy.cpp \
-  pow.cpp \
   rest.cpp \
   rpcblockchain.cpp \
-  rpcmining.cpp \
   rpcmisc.cpp \
   rpcnet.cpp \
   rpcrawtransaction.cpp \
@@ -267,7 +260,6 @@ crypto_libbitcoin_crypto_a_SOURCES = \
 libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)
 libbitcoin_common_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)
 libbitcoin_common_a_SOURCES = \
-  amount.cpp \
   arith_uint256.cpp \
   base58.cpp \
   chainparams.cpp \
diff --git a/src/amount.cpp b/src/amount.cpp
deleted file mode 100644
index a3abd8cd8..000000000
--- a/src/amount.cpp
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-2015 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include "amount.h"
-
-#include "tinyformat.h"
-
-const std::string CURRENCY_UNIT = "BTC";
-
-CFeeRate::CFeeRate(const CAmount& nFeePaid, size_t nSize)
-{
-    if (nSize > 0)
-        nSatoshisPerK = nFeePaid*1000/nSize;
-    else
-        nSatoshisPerK = 0;
-}
-
-CAmount CFeeRate::GetFee(size_t nSize) const
-{
-    CAmount nFee = nSatoshisPerK*nSize / 1000;
-
-    if (nFee == 0 && nSatoshisPerK > 0)
-        nFee = nSatoshisPerK;
-
-    return nFee;
-}
-
-std::string CFeeRate::ToString() const
-{
-    return strprintf("%d.%08d %s/kB", nSatoshisPerK / COIN, nSatoshisPerK % COIN, CURRENCY_UNIT);
-}
diff --git a/src/amount.h b/src/amount.h
index a48b17d51..aa7726fc3 100644
--- a/src/amount.h
+++ b/src/amount.h
@@ -10,14 +10,14 @@
 
 #include <stdlib.h>
 #include <string>
+#include <boost/foreach.hpp>
 
-typedef int64_t CAmount;
+#define ABC_ID 0
 
-static const CAmount COIN = 100000000;
-static const CAmount CENT = 1000000;
-
-extern const std::string CURRENCY_UNIT;
+typedef std::map<uint32_t, int64_t> CAmount;
+typedef std::pair<uint32_t, int64_t> CValue;
 
+// static const int64_t CENT = 1000000;
 /** No amount larger than this (in satoshi) is valid.
  *
  * Note that this constant is *not* the total money supply, which in Bitcoin
@@ -27,39 +27,184 @@ extern const std::string CURRENCY_UNIT;
  * critical; in unusual circumstances like a(nother) overflow bug that allowed
  * for the creation of coins out of thin air modification could lead to a fork.
  * */
-static const CAmount MAX_MONEY = 21000000 * COIN;
-inline bool MoneyRange(const CAmount& nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }
-
-/** Type-safe wrapper class for fee rates
- * (how much to pay based on transaction size)
- */
-class CFeeRate
-{
-private:
-    CAmount nSatoshisPerK; // unit is satoshis-per-1,000-bytes
-public:
-    CFeeRate() : nSatoshisPerK(0) { }
-    explicit CFeeRate(const CAmount& _nSatoshisPerK): nSatoshisPerK(_nSatoshisPerK) { }
-    CFeeRate(const CAmount& nFeePaid, size_t nSize);
-    CFeeRate(const CFeeRate& other) { nSatoshisPerK = other.nSatoshisPerK; }
-
-    CAmount GetFee(size_t size) const; // unit returned is satoshis
-    CAmount GetFeePerK() const { return GetFee(1000); } // satoshis-per-1000-bytes
-
-    friend bool operator<(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK < b.nSatoshisPerK; }
-    friend bool operator>(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK > b.nSatoshisPerK; }
-    friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }
-    friend bool operator<=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK <= b.nSatoshisPerK; }
-    friend bool operator>=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK >= b.nSatoshisPerK; }
-    CFeeRate& operator+=(const CFeeRate& a) { nSatoshisPerK += a.nSatoshisPerK; return *this; }
-    std::string ToString() const;
-
-    ADD_SERIALIZE_METHODS;
-
-    template <typename Stream, typename Operation>
-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {
-        READWRITE(nSatoshisPerK);
+inline bool MoneyRange(const int64_t& nValue) { return (nValue >= 0); }
+
+inline bool MoneyRange(const CAmount& nValue) {
+    for(CAmount::const_iterator it = nValue.begin(); it != nValue.end(); it++) {
+        if (it->second < 0) {
+            return false;
+        }
+    }
+    return true;
+}
+
+inline bool MoneyRange(const CValue& nValue) {
+    return nValue.second >= 0;
+}
+
+inline void normalize(CAmount& a) {
+    CAmount b = a;
+    BOOST_FOREACH(const CValue& cval, b) {
+        if (cval.second == 0) a.erase(cval.first);
+    }
+}
+
+inline CAmount operator+(const CAmount& a, const CAmount& b) {
+    CAmount value = a;
+    BOOST_FOREACH(const CValue& cvTarget, b) {
+        value[cvTarget.first] += cvTarget.second;
     }
+
+    normalize(value);
+    return value;
+}
+
+inline CAmount operator+(const CAmount& a, const CValue& b) {
+    CAmount value = a;
+
+    value[b.first] += b.second;
+
+    normalize(value);
+    return value;
+}
+
+inline CAmount operator+=(CAmount& a, const CAmount& b) {
+    BOOST_FOREACH(const CValue& cvTarget, b) {
+        a[cvTarget.first] += cvTarget.second;
+    }
+
+    normalize(a);
+    return a;
+}
+
+inline CAmount operator-=(CAmount& a, const CAmount& b) {
+    BOOST_FOREACH(const CValue& cvTarget, b) {
+        a[cvTarget.first] -= cvTarget.second;
+    }
+
+    normalize(a);
+    return a;
+}
+
+inline CAmount operator+=(CAmount& a, const CValue& b) {
+    a[b.first] += b.second;
+
+    normalize(a);
+    return a;
+}
+
+inline CAmount operator-=(CAmount& a, const CValue& b) {
+    a[b.first] -= b.second;
+
+    normalize(a);
+    return a;
+}
+
+inline CAmount operator-(const CAmount& a, const CValue& b) {
+    CAmount value = a;
+
+    value[b.first] -= b.second;
+
+    normalize(value);
+    return value;
+}
+
+inline CAmount operator-(const CAmount& a) {
+    CAmount tmp;
+    BOOST_FOREACH(const CValue& cvTarget, a) {
+        tmp[cvTarget.first] = -cvTarget.second;
+    }
+
+    normalize(tmp);
+    return tmp;
+}
+
+inline CValue operator-(const CValue& a) {
+    return std::make_pair(a.first, -a.second);
+}
+
+inline CAmount operator-(const CAmount& a, const CAmount& b) {
+    return a + (-b);
+}
+
+enum Arith_OP {
+    EQ,
+    NE,
+    LT,
+    LE,
+    GT,
+    GE
 };
 
+inline bool amount_op(const CAmount& a, const CAmount& b, enum Arith_OP op) {
+    CAmount dup_a = a;
+    CAmount dup_b = b;
+    normalize(dup_a);
+    normalize(dup_b);
+
+    std::set<uint32_t> sAsset;
+    BOOST_FOREACH(const CValue& cval, dup_a) {
+        sAsset.insert(cval.first);
+    }
+    BOOST_FOREACH(const CValue& cval, dup_b) {
+        sAsset.insert(cval.first);
+    }
+
+    if (sAsset.size() == 0) {
+        if (op == EQ || op == LE || op == GE) return true;
+        else return false;
+    }
+
+    BOOST_FOREACH(const uint32_t& ival, sAsset) {
+        switch (op) {
+			case EQ:
+				if (dup_a[ival] != dup_b[ival]) return false;
+				break;
+			case NE:
+				if (dup_a[ival] == dup_b[ival]) return false;
+				break;
+			case LT:
+				if (dup_a[ival] >= dup_b[ival]) return false;
+				break;
+			case LE:
+				if (dup_a[ival] > dup_b[ival]) return false;
+				break;
+			case GT:
+				if (dup_a[ival] <= dup_b[ival]) return false;
+				break;
+			case GE:
+				if (dup_a[ival] < dup_b[ival]) return false;
+				break;
+            default:
+                return false;
+        }
+    }
+
+    return true;
+}
+
+inline bool operator==(const CAmount& a, const CAmount& b) {
+    return amount_op(a, b, EQ);
+}
+
+inline bool operator!=(const CAmount& a, const CAmount& b) {
+    return amount_op(a, b, NE);
+}
+
+inline bool operator>(const CAmount& a, const CAmount& b) {
+    return amount_op(a, b, GT);
+}
+
+inline bool operator>=(const CAmount& a, const CAmount& b) {
+    return amount_op(a, b, GE);
+}
+
+inline bool operator<(const CAmount& a, const CAmount& b) {
+    return amount_op(a, b, LT);
+}
+
+inline bool operator<=(const CAmount& a, const CAmount& b) {
+    return amount_op(a, b, LE);
+}
+
 #endif //  BITCOIN_AMOUNT_H
diff --git a/src/base58.cpp b/src/base58.cpp
index 5e26cf8d4..621f2a031 100644
--- a/src/base58.cpp
+++ b/src/base58.cpp
@@ -248,6 +248,21 @@ bool CBitcoinAddress::IsValid(const CChainParams& params) const
     return fCorrectSize && fKnownVersion;
 }
 
+uint160 CBitcoinAddress::GetID() const
+{
+    if (!IsValid())
+        return uint160();
+
+    if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS) || \
+        vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)) {
+        uint160 id;
+        memcpy(&id, &vchData[0], 20);
+        return id;
+    }
+    else
+        return uint160();
+}
+
 CTxDestination CBitcoinAddress::Get() const
 {
     if (!IsValid())
diff --git a/src/base58.h b/src/base58.h
index a3980118a..0780a507e 100644
--- a/src/base58.h
+++ b/src/base58.h
@@ -57,13 +57,13 @@ std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn);
  * Decode a base58-encoded string (psz) that includes a checksum into a byte
  * vector (vchRet), return true if decoding is successful
  */
-inline bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet);
+bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet);
 
 /**
  * Decode a base58-encoded string (str) that includes a checksum into a byte
  * vector (vchRet), return true if decoding is successful
  */
-inline bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet);
+bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet);
 
 /**
  * Base class for all base58-encoded data
@@ -115,6 +115,7 @@ public:
     CBitcoinAddress(const char* pszAddress) { SetString(pszAddress); }
 
     CTxDestination Get() const;
+    uint160 GetID() const;
     bool GetKeyID(CKeyID &keyID) const;
     bool IsScript() const;
 };
diff --git a/src/bitcoin-tx.cpp b/src/bitcoin-tx.cpp
index 2c502ead3..2077b1c82 100644
--- a/src/bitcoin-tx.cpp
+++ b/src/bitcoin-tx.cpp
@@ -207,7 +207,7 @@ static void MutateTxAddInput(CMutableTransaction& tx, const string& strInput)
 static void MutateTxAddOutAddr(CMutableTransaction& tx, const string& strInput)
 {
     // separate VALUE:ADDRESS in string
-    size_t pos = strInput.find(':');
+    size_t pos = strInput.rfind(':');
     if ((pos == string::npos) ||
         (pos == 0) ||
         (pos == (strInput.size() - 1)))
@@ -215,7 +215,7 @@ static void MutateTxAddOutAddr(CMutableTransaction& tx, const string& strInput)
 
     // extract and validate VALUE
     string strValue = strInput.substr(0, pos);
-    CAmount value;
+    CValue value;
     if (!ParseMoney(strValue, value))
         throw runtime_error("invalid TX output value");
 
@@ -235,10 +235,10 @@ static void MutateTxAddOutAddr(CMutableTransaction& tx, const string& strInput)
 
 static void MutateTxAddOutData(CMutableTransaction& tx, const string& strInput)
 {
-    CAmount value = 0;
+    CValue value;
 
     // separate [VALUE:]DATA in string
-    size_t pos = strInput.find(':');
+    size_t pos = strInput.rfind(':');
 
     if (pos==0)
         throw runtime_error("TX output value not specified");
@@ -265,14 +265,14 @@ static void MutateTxAddOutData(CMutableTransaction& tx, const string& strInput)
 static void MutateTxAddOutScript(CMutableTransaction& tx, const string& strInput)
 {
     // separate VALUE:SCRIPT in string
-    size_t pos = strInput.find(':');
+    size_t pos = strInput.rfind(':');
     if ((pos == string::npos) ||
         (pos == 0))
         throw runtime_error("TX output missing separator");
 
     // extract and validate VALUE
     string strValue = strInput.substr(0, pos);
-    CAmount value;
+    CValue value;
     if (!ParseMoney(strValue, value))
         throw runtime_error("invalid TX output value");
 
@@ -425,7 +425,7 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)
                 if ((unsigned int)nOut >= coins->vout.size())
                     coins->vout.resize(nOut+1);
                 coins->vout[nOut].scriptPubKey = scriptPubKey;
-                coins->vout[nOut].nValue = 0; // we don't know the actual output value
+                coins->vout[nOut].nValue = std::make_pair((uint32_t)0,(int64_t)0); // we don't know the actual output value
             }
 
             // if redeemScript given and private keys given,
diff --git a/src/bitcoind.cpp b/src/bitcoind.cpp
index 3b6608c95..d3b61d08a 100644
--- a/src/bitcoind.cpp
+++ b/src/bitcoind.cpp
@@ -13,6 +13,7 @@
 #include "httpserver.h"
 #include "httprpc.h"
 #include "rpcserver.h"
+#include "sync.h"
 
 #include <boost/algorithm/string/predicate.hpp>
 #include <boost/filesystem.hpp>
@@ -171,6 +172,7 @@ bool AppInit(int argc, char* argv[])
     } else {
         WaitForShutdown(&threadGroup);
     }
+
     Shutdown();
 
     return fRet;
diff --git a/src/booker.cpp b/src/booker.cpp
new file mode 100644
index 000000000..6dcbc7446
--- /dev/null
+++ b/src/booker.cpp
@@ -0,0 +1,400 @@
+// Copyright (c) 2009-2010 Satoshi Nakamoto
+// Copyright (c) 2009-2015 The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include "booker.h"
+
+#include "amount.h"
+#include "chain.h"
+#include "chainparams.h"
+#include "coins.h"
+#include "consensus/consensus.h"
+#include "consensus/merkle.h"
+#include "consensus/validation.h"
+#include "hash.h"
+#include "main.h"
+#include "net.h"
+#include "policy/policy.h"
+#include "primitives/transaction.h"
+#include "script/standard.h"
+#include "timedata.h"
+#include "txmempool.h"
+#include "util.h"
+#include "utilmoneystr.h"
+#include "validationinterface.h"
+
+#include <boost/thread.hpp>
+#include <boost/tuple/tuple.hpp>
+#include <queue>
+
+using namespace std;
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// BitcoinMiner
+//
+
+//
+// Unconfirmed transactions in the memory pool often depend on other
+// transactions in the memory pool. When we select transactions from the
+// pool, we select by highest priority or fee rate, so we might consider
+// transactions that depend on transactions that aren't yet in the block.
+
+uint64_t nLastBlockTx = 0;
+uint64_t nLastBlockSize = 0;
+
+class ScoreCompare
+{
+public:
+    ScoreCompare() {}
+
+    bool operator()(const CTxMemPool::txiter a, const CTxMemPool::txiter b)
+    {
+        return CompareTxMemPoolEntryByEntryTime()(*b,*a); // Convert to less than
+    }
+};
+
+int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)
+{
+    int64_t nOldTime = pblock->nTime;
+    int64_t nNewTime = std::max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());
+
+    if (nOldTime < nNewTime)
+        pblock->nTime = nNewTime;
+
+    // Updating time can change work required on testnet:
+    // if (consensusParams.fPowAllowMinDifficultyBlocks)
+    //     pblock->nBits = GetNextWorkRequired(pindexPrev, pblock, consensusParams);
+
+    return nNewTime - nOldTime;
+}
+
+CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, bool bManual)
+{
+    // Create new block
+    auto_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());
+    if(!pblocktemplate.get())
+        return NULL;
+    CBlock *pblock = &pblocktemplate->block; // pointer for convenience
+    // Add dummy coinbase tx as first transaction
+    pblock->vtx.push_back(CTransaction());
+    pblocktemplate->vTxSigOps.push_back(-1); // updated at end
+
+    // Largest block you're willing to create:
+    unsigned int nBlockMaxSize = GetArg("-blockmaxsize", DEFAULT_BLOCK_MAX_SIZE);
+    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:
+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));
+
+    // Collect memory pool transactions into the block
+    CTxMemPool::setEntries inBlock;
+    CTxMemPool::setEntries waitSet;
+
+    std::priority_queue<CTxMemPool::txiter, std::vector<CTxMemPool::txiter>, ScoreCompare> clearedTxs;
+    uint64_t nBlockSize = 1000;
+    uint64_t nBlockTx = 0;
+    unsigned int nBlockSigOps = 100;
+    int lastFewTxs = 0;
+
+    CBlockIndex* pindexPrev;
+    {
+        LOCK(cs_main);
+        {
+        LOCK(mempool.cs);
+        pindexPrev = chainActive.Tip();
+        const int nHeight = pindexPrev->nHeight + 1;
+        pblock->nTime = GetAdjustedTime();
+        const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();
+
+        pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());
+        // -regtest only: allow overriding block.nVersion with
+        // -blockversion=N to test forking scenarios
+        if (chainparams.MineBlocksOnDemand())
+            pblock->nVersion = GetArg("-blockversion", pblock->nVersion);
+
+        int64_t nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)
+                                ? nMedianTimePast
+                                : pblock->GetBlockTime();
+
+        CTxMemPool::indexed_transaction_set::nth_index<1>::type::iterator mi = mempool.mapTx.get<1>().begin();
+        CTxMemPool::txiter iter;
+
+        while (mi != mempool.mapTx.get<1>().end() || !clearedTxs.empty())
+        {
+            if (clearedTxs.empty()) { // add tx with next highest score
+                iter = mempool.mapTx.project<0>(mi);
+                mi++;
+            }
+            else {  // try to add a previously postponed child tx
+                iter = clearedTxs.top();
+                clearedTxs.pop();
+            }
+
+            if (inBlock.count(iter))
+                continue; // could have been added to the priorityBlock
+
+            const CTransaction& tx = iter->GetTx();
+
+            bool fOrphan = false;
+            BOOST_FOREACH(CTxMemPool::txiter parent, mempool.GetMemPoolParents(iter))
+            {
+                if (!inBlock.count(parent)) {
+                    fOrphan = true;
+                    break;
+                }
+            }
+            if (fOrphan) {
+                waitSet.insert(iter);
+                continue;
+            }
+
+            unsigned int nTxSize = iter->GetTxSize();
+
+            if (nBlockSize + nTxSize >= nBlockMaxSize) {
+                if (nBlockSize >  nBlockMaxSize - 100 || lastFewTxs > 50) {
+                    break;
+                }
+                // Once we're within 1000 bytes of a full block, only look at 50 more txs
+                // to try to fill the remaining space.
+                if (nBlockSize > nBlockMaxSize - 1000) {
+                    lastFewTxs++;
+                }
+                continue;
+            }
+
+            // Check the output id: only pay to script hash or public key hash accepted
+            bool bValidDestIDs = true;
+            for(uint32_t i = 0; i < tx.vout.size(); i++) {
+                if (tx.vout[i].nValue.second == 0) continue;
+                suint160 id, primeid;
+                // Make sure id is authorized
+                if (!chainActive.IdAuthorized(tx.vout[i].scriptPubKey, id, primeid)) {
+                    bValidDestIDs = false;
+                    break;
+                }
+            }
+
+            if (bValidDestIDs == false) continue;
+
+            if (!IsFinalTx(tx, nHeight, nLockTimeCutoff))
+                continue;
+
+            unsigned int nTxSigOps = iter->GetSigOpCount();
+            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS) {
+                if (nBlockSigOps > MAX_BLOCK_SIGOPS - 2) {
+                    break;
+                }
+                continue;
+            }
+
+            // Added
+            pblock->vtx.push_back(tx);
+            pblocktemplate->vTxSigOps.push_back(nTxSigOps);
+            nBlockSize += nTxSize;
+            ++nBlockTx;
+            nBlockSigOps += nTxSigOps;
+
+            inBlock.insert(iter);
+
+            // Add transactions that depend on this one to the priority queue
+            BOOST_FOREACH(CTxMemPool::txiter child, mempool.GetMemPoolChildren(iter))
+            {
+                {
+                    if (waitSet.count(child)) {
+                        clearedTxs.push(child);
+                        waitSet.erase(child);
+                    }
+                }
+            }
+        }
+        }
+
+        if (nBlockTx == 0 && !bManual) {
+            // LogPrintf("CreateNewBlock(): no transaction in memory pool to book\n");
+            return NULL;
+        }
+
+        nLastBlockTx = nBlockTx;
+        nLastBlockSize = nBlockSize;
+        // LogPrintf("CreateNewBlock(): total size %u txs: %u sigops %d\n", nBlockSize, nBlockTx, nBlockSigOps);
+
+        // Compute final coinbase transaction.
+        // LogPrintf("TxIn: %s", txNew->vin[0].ToString());
+        // pblock->vtx[0] = *txNew;
+
+        // Fill in header
+        pblock->hashPrevBlock  = pindexPrev->GetBlockHash();
+        UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);
+        // pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);
+
+        if (!bManual) {
+
+            GetMainSignals().TransForBooking(*pblock, *pindexPrev);
+
+            if (pblock->vchBlockSig.size() == 0) {
+                // LogPrintf("CreateNewBlock(): Could not get booking block\n");
+                return NULL;
+            }
+
+            pblocktemplate->vTxSigOps[0] = GetLegacySigOpCount(pblock->vtx[0]);
+
+            CValidationState state;
+            if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false)) {
+                LogPrintf("%s: TestBlockValidity failed: %s", __func__, FormatStateMessage(state));
+                return NULL;
+            }
+
+        }
+
+    }
+
+    return pblocktemplate.release();
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// Internal miner
+//
+
+//
+// ScanHash scans nonces looking for a hash with at least some zero bits.
+// The nonce is usually preserved between calls, but periodically or if the
+// nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at
+// zero.
+//
+
+static bool ProcessBlockFound(const CBlock* pblock, const CChainParams& chainparams)
+{
+    // LogPrintf("%s\n", pblock->ToString());
+
+    // Root script hash and operator public key hash will be refreshed on site
+    // Issuer public key hash will invalidated on site
+    // Branch preferences:
+    // 1, Root script hash checking
+    // 2, Operator public key hash checking
+    // 3, Issuer public key hash checking
+    // 4, Stake holder public key hash checking
+
+    // Found a solution
+    {
+        LOCK(cs_main);
+        
+        CBlockIndex* tip = chainActive.Tip();
+        if (pblock->hashPrevBlock != tip->GetBlockHash() && (tip->GetBlockHeader() > pblock->GetBlockHeader()))
+            return error("BitcoinMiner: generated block is stale");
+    }
+
+    // Inform about the new block
+    GetMainSignals().BlockFound(pblock->GetHash());
+
+    // Process this block the same as if we had received it from another node
+    CValidationState state;
+    if (!ProcessNewBlock(state, chainparams, NULL, pblock, true, NULL))
+        return error("BitcoinMiner: ProcessNewBlock, block not accepted");
+
+    LogPrintf("Block generated\n");
+
+    return true;
+}
+
+CCriticalSection cs_miner;
+
+void static BitcoinMiner(const CChainParams& chainparams)
+{
+    LogPrintf("BitcoinMiner started\n");
+    SetThreadPriority(THREAD_PRIORITY_LOWEST);
+    RenameThread("bitcoin-miner");
+
+    try {
+        // Throw an error if no script was provided.  This can happen
+        // due to some internal error but also if the keypool is empty.
+        // In the latter case, already the pointer is NULL.
+        while (true) {
+            if (chainparams.MiningRequiresPeers()) {
+                // Busy-wait for the network to come online so we don't waste time mining
+                // on an obsolete chain. In regtest mode we expect to fly solo.
+                do {
+                    bool fvNodesEmpty;
+                    {
+                        LOCK(cs_vNodes);
+                        fvNodesEmpty = vNodes.empty();
+                    }
+                    if (!fvNodesEmpty && !IsInitialBlockDownload())
+                        break;
+                    MilliSleep(1000);
+                } while (true);
+            }
+
+            MilliSleep(5000);
+            //
+            // Create new block
+            //
+            SetThreadPriority(THREAD_PRIORITY_NORMAL);
+
+            {
+            LOCK(cs_miner);
+
+            auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlock(chainparams));
+            if (!pblocktemplate.get()) continue;
+
+            CBlock *pblock = &pblocktemplate->block;
+
+            // LogPrintf("Running BitcoinMiner with %u transactions in block (%u bytes)\n", pblock->vtx.size(),
+              //  ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));
+
+            ProcessBlockFound(pblock, chainparams);
+
+            uint256 bhash = pblock->GetHash();
+
+            {
+                LOCK(cs_main);
+                BlockMap::const_iterator blit = mapBlockIndex.find(bhash);
+                if (blit == mapBlockIndex.end() || !chainActive.Contains(blit->second)) {
+                    LogPrintf("BitcoinMiner: generated block not accepted: %s\n", bhash.ToString());
+                    GetMainSignals().ReverseTransForBooking(*pblock);
+                }
+            }
+            }
+
+            SetThreadPriority(THREAD_PRIORITY_LOWEST);
+            //coinbaseScript->KeepScript();
+
+            // Check for stop or if block needs to be rebuilt
+            boost::this_thread::interruption_point();
+            // Regtest mode doesn't require peers
+            // Update nTime every few seconds
+        }
+    }
+    catch (const boost::thread_interrupted&)
+    {
+        LogPrintf("BitcoinMiner terminated\n");
+        throw;
+    }
+    catch (const std::runtime_error &e)
+    {
+        LogPrintf("BitcoinMiner runtime error: %s\n", e.what());
+        return;
+    }
+}
+
+void GenerateBitcoins(bool fGenerate, int nThreads, const CChainParams& chainparams)
+{
+    static boost::thread_group* minerThreads = NULL;
+
+    if (nThreads < 0)
+        nThreads = GetNumCores();
+
+    if (minerThreads != NULL)
+    {
+        minerThreads->interrupt_all();
+        delete minerThreads;
+        minerThreads = NULL;
+    }
+
+    if (nThreads == 0 || !fGenerate)
+        return;
+
+    minerThreads = new boost::thread_group();
+    for (int i = 0; i < nThreads; i++)
+        minerThreads->create_thread(boost::bind(&BitcoinMiner, boost::cref(chainparams)));
+}
diff --git a/src/miner.h b/src/booker.h
similarity index 76%
rename from src/miner.h
rename to src/booker.h
index 512494198..ec78b47af 100644
--- a/src/miner.h
+++ b/src/booker.h
@@ -3,8 +3,8 @@
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
-#ifndef BITCOIN_MINER_H
-#define BITCOIN_MINER_H
+#ifndef BITCOIN_BOOKER_H
+#define BITCOIN_BOOKER_H
 
 #include "primitives/block.h"
 
@@ -20,21 +20,16 @@ namespace Consensus { struct Params; };
 static const bool DEFAULT_GENERATE = false;
 static const int DEFAULT_GENERATE_THREADS = 1;
 
-static const bool DEFAULT_PRINTPRIORITY = false;
-
 struct CBlockTemplate
 {
     CBlock block;
-    std::vector<CAmount> vTxFees;
     std::vector<int64_t> vTxSigOps;
 };
 
-/** Run the miner threads */
+/** Run the booker threads */
 void GenerateBitcoins(bool fGenerate, int nThreads, const CChainParams& chainparams);
 /** Generate a new block, without valid proof-of-work */
-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn);
+CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, bool bManual = false);
 /** Modify the extranonce in a block */
-void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned int& nExtraNonce);
 int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev);
-
 #endif // BITCOIN_MINER_H
diff --git a/src/chain.cpp b/src/chain.cpp
index 3450ed6c3..320868707 100644
--- a/src/chain.cpp
+++ b/src/chain.cpp
@@ -4,6 +4,7 @@
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #include "chain.h"
+#include "util.h"
 
 using namespace std;
 
@@ -15,11 +16,129 @@ void CChain::SetTip(CBlockIndex *pindex) {
         vChain.clear();
         return;
     }
+
+    // Modify the chain parameters
+    const CBlockIndex* pIndexFork = FindFork(pindex);
+
+    // Roll back parameters in stale blocks
+    for(const CBlockIndex* pBlockIndex = Tip(); pBlockIndex && pIndexFork && pBlockIndex->nHeight > pIndexFork->nHeight; pBlockIndex = pBlockIndex->pprev) {
+        unsigned int nBlockType = pBlockIndex->GetType();
+
+        // Root block never rolls back ...
+        assert(nBlockType != BLOCK_ROOT);
+
+        if (nBlockType == BLOCK_OP) {
+            // Find the nearest curve
+            if (pBlockIndex->WithData(BLOCK_CURVE)) {
+                mTimeDecaying = NULL;
+                for (const CBlockIndex* prevOperatorBlockIndex = vChain[pBlockIndex->pprev->nOperatorHeight];
+                        prevOperatorBlockIndex->pprev != NULL;
+                        prevOperatorBlockIndex = vChain[prevOperatorBlockIndex->pprev->nOperatorHeight]) {
+                    assert(prevOperatorBlockIndex->GetType() == BLOCK_OP);
+                    if (prevOperatorBlockIndex->WithData(BLOCK_CURVE)) {
+                        assert(prevOperatorBlockIndex->mTimeDecaying != NULL);
+                        mTimeDecaying = prevOperatorBlockIndex->mTimeDecaying;
+                        break;
+                    }
+                }
+            }
+
+            if (pBlockIndex->WithData(BLOCK_DEAUTH)) {
+                assert(pBlockIndex->sMinusPrimeID != NULL);
+                BOOST_FOREACH(const suint160& idPrime, *(pBlockIndex->sMinusPrimeID)) {
+                    assert(sPrimeID.count(idPrime) == 0);
+                    sPrimeID.insert(idPrime);
+                }
+            }
+
+            if (pBlockIndex->WithData(BLOCK_AUTH)) {
+                assert(pBlockIndex->sPlusPrimeID != NULL);
+                BOOST_FOREACH(const suint160& idPrime, *(pBlockIndex->sPlusPrimeID)) {
+                    assert(sPrimeID.count(idPrime) == 1);
+                    sPrimeID.erase(idPrime);
+                }
+            }
+
+        }
+
+        if (pBlockIndex->WithData(BLOCK_AUTHCHAIN)) {
+            assert(pBlockIndex->mPlusTransID != NULL);
+            BOOST_FOREACH(const PAIRTYPE(suint160, sID)& pairPrimeTrans, *(pBlockIndex->mPlusTransID)) {
+                BOOST_FOREACH(const suint160& idTrans, pairPrimeTrans.second) {
+                // assert(sNextTransID.get<0>.erase(idTrans) == 1);
+                // assert(sNextTransID.erase(idTrans) == 1);
+                if (sNextTransID.erase(idTrans) == 1)
+                    LogPrintf("Transaction id removed: %d:%s\n", idTrans.first, idTrans.second.ToString());
+                }
+            }
+        }
+
+        if (pBlockIndex->WithData(BLOCK_SIGNCOUNT)) {
+            BOOST_FOREACH(const PAIRTYPE(suint160, uint32_t)& pairTransIDSigs, *(pBlockIndex->mIDSigCount)) {
+                trans_id_set::const_iterator it = sNextTransID.find(pairTransIDSigs.first);
+                assert(it != sNextTransID.end());
+                assert(sNextTransID.modify(it, dec_signature_number(pairTransIDSigs.second)));
+            }
+        }
+    }
+
+    vector<const CBlockIndex*> vBlocks;
+    for(const CBlockIndex* tip = pindex; tip && tip->nHeight > (pIndexFork ? pIndexFork->nHeight : -1); tip = tip->pprev) {
+        vBlocks.push_back(tip);
+    }
+
+    BOOST_REVERSE_FOREACH(const CBlockIndex*& pBlockIndex, vBlocks) {
+        unsigned int nBlockType = pBlockIndex->GetType();
+
+        if (nBlockType == BLOCK_OP) {
+            if (pBlockIndex->WithData(BLOCK_CURVE)) {
+                mTimeDecaying = pBlockIndex->mTimeDecaying;
+                assert(mTimeDecaying != NULL);
+            }
+
+            if (pBlockIndex->WithData(BLOCK_AUTH)) {
+                assert(pBlockIndex->sPlusPrimeID != NULL);
+                BOOST_FOREACH(const suint160& idPrime, *(pBlockIndex->sPlusPrimeID)) {
+                    assert(sPrimeID.count(idPrime) == 0);
+                    sPrimeID.insert(idPrime);
+                    sNextTransID.insert(transaction_id(idPrime, idPrime, 0));
+                }
+            }
+
+            if (pBlockIndex->WithData(BLOCK_DEAUTH)) {
+                assert(pBlockIndex->sMinusPrimeID != NULL);
+                BOOST_FOREACH(const suint160& idPrime, *(pBlockIndex->sMinusPrimeID)) {
+                    assert(sPrimeID.count(idPrime) == 1);
+                    sPrimeID.erase(idPrime);
+                }
+            }
+        }
+
+        if (pBlockIndex->WithData(BLOCK_AUTHCHAIN)) {
+            BOOST_FOREACH(const PAIRTYPE(suint160, sID)& pairPrimeTrans, *(pBlockIndex->mPlusTransID)) {
+                BOOST_FOREACH(const suint160& idTrans, pairPrimeTrans.second) {
+                if (sNextTransID.insert(transaction_id(idTrans, pairPrimeTrans.first, 0)).second)
+                    LogPrintf("Transaction id added: %d:%s for primeid: %d:%s\n", idTrans.first, idTrans.second.ToString(), pairPrimeTrans.first.first, pairPrimeTrans.first.second.ToString());
+                }
+            }
+        }
+
+        if (pBlockIndex->WithData(BLOCK_SIGNCOUNT)) {
+            BOOST_FOREACH(const PAIRTYPE(suint160, uint32_t)& pairTransIDSigs, *(pBlockIndex->mIDSigCount)) {
+                trans_id_set::const_iterator it = sNextTransID.find(pairTransIDSigs.first);
+                assert(it != sNextTransID.end());
+                assert(sNextTransID.modify(it, add_signature_number(pairTransIDSigs.second)));
+            }
+        }
+
+    }
+
     vChain.resize(pindex->nHeight + 1);
     while (pindex && vChain[pindex->nHeight] != pindex) {
         vChain[pindex->nHeight] = pindex;
         pindex = pindex->pprev;
     }
+
 }
 
 CBlockLocator CChain::GetLocator(const CBlockIndex *pindex) const {
diff --git a/src/chain.h b/src/chain.h
index ae6c4338d..82e1732f5 100644
--- a/src/chain.h
+++ b/src/chain.h
@@ -8,11 +8,22 @@
 
 #include "arith_uint256.h"
 #include "primitives/block.h"
-#include "pow.h"
 #include "tinyformat.h"
 #include "uint256.h"
+#include "chainparams.h"
+#include "util.h"
 
 #include <vector>
+#include <boost/multi_index_container.hpp>
+#include <boost/multi_index/member.hpp>
+#include <boost/multi_index/ordered_index.hpp>
+#include <boost/multi_index/hashed_index.hpp>
+#include <boost/multi_index/composite_key.hpp>
+
+using namespace boost::multi_index;
+
+#define PAIRTYPE(t1, t2)    std::pair<t1, t2>
+typedef PAIRTYPE(bool, uint160) suint160;
 
 struct CDiskBlockPos
 {
@@ -89,9 +100,86 @@ enum BlockStatus {
 
     BLOCK_FAILED_VALID       =   32, //! stage after last reached validness failed
     BLOCK_FAILED_CHILD       =   64, //! descends from failed block
+    BLOCK_FAILED_WEIGHT      =  128, //! failed booker weighting
     BLOCK_FAILED_MASK        =   BLOCK_FAILED_VALID | BLOCK_FAILED_CHILD,
+
+    // Bit 8-9 designates the block type
+    BLOCK_OP                 =  1 << 8, // Block type operator
+    BLOCK_POS                =  2 << 8, // Block type POS
+    BLOCK_ROOT               =  3 << 8, // Block type root
+
+    BLOCK_CURVE              =  1 << 10, // Block contains POS decaying curve assignment, implying  this is an operator block
+    BLOCK_AUTH               =  1 << 11, // Block contains prime suint160 authorization, implying  this is an operator block
+    BLOCK_DEAUTH             =  1 << 12, // Block contains prime suint160 de-authorization, implying  this is an operator block
+    BLOCK_AUTHCHAIN          =  1 << 13, // Block contains chained transaction suint160 authorization
+    BLOCK_SIGNCOUNT          =  1 << 14, // Block contains normal transaction signature
+    BLOCK_WIZARD             =  1 << 15, // Block contains wizard id authorization, implying this is a root block
+    BLOCK_OPERATOR           =  1 << 16, // Block contains operator id authorization, implying this is a root block
+};
+
+enum RootCommand {
+    ROOT_ASSIGN_OPERATOR = 0, // Renew operator id
+    ROOT_CREDITING = 1, // Asset creditor signagures
+    ROOT_ASSIGN_WIZARD = 2, // Renew wizard id
+};
+
+enum OperaterCommand {
+    OP_AUTH_TRANS_IDS = 0, // Authorize transactor ids;
+    OP_DEAUTH_TRANS_IDS = 1, // Revoke transactor ids;
+    OP_CURVE_DECAYING = 2, // Renew stake decaying curve for POS;
+};
+
+enum UserCommand {
+    USER_AUTH_TRANS_IDS = 0, // Authorize sub transactor ids;
 };
 
+typedef std::set<suint160> sID;
+
+struct transaction_id {
+    suint160 trans_id;
+    suint160 prime_id;
+    unsigned int signed_count;
+
+    transaction_id(suint160 trans_id_in, suint160 prime_id_in, uint32_t signed_count_in) : trans_id(trans_id_in), prime_id(prime_id_in), signed_count(signed_count_in) {}
+};
+
+struct add_signature_number
+{
+    add_signature_number(const uint32_t& _nSignatures) : nSignatures(_nSignatures) { }
+
+    void operator() (struct transaction_id &t) { t.signed_count += nSignatures; }
+
+private:
+    const uint32_t& nSignatures;
+};
+
+struct dec_signature_number
+{
+    dec_signature_number(const uint32_t& _nSignatures) : nSignatures(_nSignatures) { }
+
+    void operator() (struct transaction_id &t) {
+        assert(nSignatures <= t.signed_count);
+        t.signed_count -= nSignatures;
+    }
+
+private:
+    const uint32_t& nSignatures;
+};
+
+typedef boost::multi_index_container<
+    transaction_id,
+    boost::multi_index::indexed_by<
+        ordered_unique<BOOST_MULTI_INDEX_MEMBER(transaction_id,suint160,trans_id)>,
+        ordered_non_unique<composite_key<transaction_id, member<transaction_id,suint160,&transaction_id::prime_id>, member<transaction_id,unsigned int,&transaction_id::signed_count> > >
+    >
+> trans_id_set;
+
+typedef trans_id_set::nth_index<0>::type trans_id_set_ordered_by_trans_id;
+typedef trans_id_set::nth_index<1>::type trans_id_set_ordered_by_prime_id_and_signed_count;
+
+typedef trans_id_set_ordered_by_trans_id::iterator trans_id_set_ordered_by_trans_id_iterator_t;
+typedef trans_id_set_ordered_by_prime_id_and_signed_count::const_iterator trans_id_set_ordered_by_prime_id_and_signed_count_iterator_t;
+
 /** The block chain is a tree shaped structure starting with the
  * genesis block at the root, with each block potentially having multiple
  * candidates to be the next block. A blockindex may have multiple pprev pointing
@@ -122,7 +210,7 @@ public:
     unsigned int nUndoPos;
 
     //! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block
-    arith_uint256 nChainWork;
+    // arith_uint256 nChainWork;
 
     //! Number of transactions in this block.
     //! Note: in a potential headers-first mode, this number cannot be relied upon
@@ -140,10 +228,34 @@ public:
     int nVersion;
     uint256 hashMerkleRoot;
     unsigned int nTime;
-    unsigned int nBits;
-    unsigned int nNonce;
-
-    //! (memory only) Sequential id assigned to distinguish order in which blocks are received.
+    int nRootHeight;
+    int nOperatorHeight;
+    uint64_t nChainStakeSeconds;
+    // unsigned int nBits;
+    // unsigned int nNonce;
+
+    // In memory authorzation information
+    const uint160* idNextRootScript;
+    const uint160* idNextOperatorPubKey;
+    const uint160* idNextWizardScript;
+
+    // map of transaction suint160 to signing count in this block
+    std::map<suint160, uint32_t>* mIDSigCount;
+
+    // The prime ids authenticated by this block
+    std::set<suint160>* sPlusPrimeID;
+    // The prime ids revoked by this block
+    std::set<suint160>* sMinusPrimeID;
+
+    // The transaction ids authenticated by this block
+    std::map<suint160, sID>* mPlusTransID;
+    // The transaction ids revoked by this block
+    // std::set<uint160> sMinusTransID;
+
+    // Weighting of period for proof of stake calculating
+    std::map<uint32_t, uint32_t>* mTimeDecaying;
+
+    //! (memory only) Sequential suint160 assigned to distinguish order in which blocks are received.
     uint32_t nSequenceId;
 
     void SetNull()
@@ -155,7 +267,7 @@ public:
         nFile = 0;
         nDataPos = 0;
         nUndoPos = 0;
-        nChainWork = arith_uint256();
+        // nChainWork = arith_uint256();
         nTx = 0;
         nChainTx = 0;
         nStatus = 0;
@@ -164,8 +276,20 @@ public:
         nVersion       = 0;
         hashMerkleRoot = uint256();
         nTime          = 0;
-        nBits          = 0;
-        nNonce         = 0;
+        nRootHeight = -1;
+        nOperatorHeight = -1;
+        nChainStakeSeconds = 0;
+        // nBits          = 0;
+        // nNonce         = 0;
+
+        idNextRootScript = NULL;
+        idNextOperatorPubKey = NULL;
+        idNextWizardScript = NULL;
+        mIDSigCount = NULL;
+        sPlusPrimeID = NULL;
+        sMinusPrimeID = NULL;
+        mPlusTransID = NULL;
+        mTimeDecaying = NULL;
     }
 
     CBlockIndex()
@@ -180,8 +304,11 @@ public:
         nVersion       = block.nVersion;
         hashMerkleRoot = block.hashMerkleRoot;
         nTime          = block.nTime;
-        nBits          = block.nBits;
-        nNonce         = block.nNonce;
+        nRootHeight = block.nRootHeight;
+        nOperatorHeight = block.nOperatorHeight;
+        nChainStakeSeconds = block.nChainStakeSeconds;
+        // nBits          = block.nBits;
+        // nNonce         = block.nNonce;
     }
 
     CDiskBlockPos GetBlockPos() const {
@@ -210,8 +337,11 @@ public:
             block.hashPrevBlock = pprev->GetBlockHash();
         block.hashMerkleRoot = hashMerkleRoot;
         block.nTime          = nTime;
-        block.nBits          = nBits;
-        block.nNonce         = nNonce;
+        block.nRootHeight = nRootHeight;
+        block.nOperatorHeight = nOperatorHeight;
+        block.nChainStakeSeconds = nChainStakeSeconds;
+        // block.nBits          = nBits;
+        // block.nNonce         = nNonce;
         return block;
     }
 
@@ -243,10 +373,13 @@ public:
 
     std::string ToString() const
     {
-        return strprintf("CBlockIndex(pprev=%p, nHeight=%d, merkle=%s, hashBlock=%s)",
+        std::string sRet =
+        strprintf("CBlockIndex(pprev=%p, nHeight=%d, merkle=%s, hashBlock=%s)\n",
             pprev, nHeight,
             hashMerkleRoot.ToString(),
-            GetBlockHash().ToString());
+            phashBlock == NULL ? "NULL Pointer" : GetBlockHash().ToString());
+
+        return sRet;
     }
 
     //! Check whether this block index entry is valid up to the passed validity level.
@@ -278,6 +411,24 @@ public:
     //! Efficiently find an ancestor of this block.
     CBlockIndex* GetAncestor(int height);
     const CBlockIndex* GetAncestor(int height) const;
+
+    // 
+    unsigned int GetType() const {
+        return nStatus & (3 << 8);
+    }
+
+    bool SetType(enum BlockStatus nType) {
+        if (nType != BLOCK_ROOT && nType != BLOCK_OP && nType != BLOCK_POS)
+            return false;
+
+        nStatus &= ~(3<<8);
+        nStatus |= nType;
+        return true;
+    }
+
+    bool WithData(enum BlockStatus nDataType) const {
+        return (nStatus & nDataType) != 0;
+    }
 };
 
 /** Used to marshal pointers into hashes for db storage. */
@@ -304,6 +455,7 @@ public:
         READWRITE(VARINT(nHeight));
         READWRITE(VARINT(nStatus));
         READWRITE(VARINT(nTx));
+
         if (nStatus & (BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO))
             READWRITE(VARINT(nFile));
         if (nStatus & BLOCK_HAVE_DATA)
@@ -316,8 +468,62 @@ public:
         READWRITE(hashPrev);
         READWRITE(hashMerkleRoot);
         READWRITE(nTime);
-        READWRITE(nBits);
-        READWRITE(nNonce);
+        READWRITE(nRootHeight);
+        READWRITE(nOperatorHeight);
+        READWRITE(nChainStakeSeconds);
+
+        unsigned int nBlockType = GetType();
+
+        if (nBlockType == BLOCK_ROOT) {
+            if (ser_action.ForRead()) {
+                idNextRootScript = new uint160;
+                if (WithData(BLOCK_OPERATOR)) idNextOperatorPubKey = new uint160;
+                if (WithData(BLOCK_WIZARD)) idNextWizardScript = new uint160;
+            }
+
+            READWRITE(*const_cast<uint160*>(idNextRootScript));
+            if (WithData(BLOCK_OPERATOR)) READWRITE(*const_cast<uint160*>(idNextOperatorPubKey));
+            if (WithData(BLOCK_WIZARD)) READWRITE(*const_cast<uint160*>(idNextWizardScript));
+        }
+        else if (nBlockType == BLOCK_OP) {
+            if (ser_action.ForRead()) {
+
+                idNextOperatorPubKey = new uint160;
+
+                if (WithData(BLOCK_CURVE)) {
+                    mTimeDecaying = new std::map<uint32_t, uint32_t>;
+                }
+
+                if (WithData(BLOCK_AUTH)) {
+                    sPlusPrimeID = new std::set<suint160>;
+                }
+
+                if (WithData(BLOCK_DEAUTH)) {
+                    sMinusPrimeID = new std::set<suint160>;
+                }
+            }
+
+            READWRITE(*const_cast<uint160*>(idNextOperatorPubKey));
+
+            if (WithData(BLOCK_CURVE)) READWRITE(*mTimeDecaying);
+            if (WithData(BLOCK_AUTH)) READWRITE(*sPlusPrimeID);
+            if (WithData(BLOCK_DEAUTH)) READWRITE(*sMinusPrimeID);
+        }
+
+        if (WithData(BLOCK_AUTHCHAIN)) {
+            if (ser_action.ForRead()) mPlusTransID = new std::map<suint160, sID>;
+
+            READWRITE(*mPlusTransID);
+        }
+
+        if (WithData(BLOCK_SIGNCOUNT)) {
+            if (ser_action.ForRead()) {
+                mIDSigCount = new std::map<suint160, uint32_t>;
+            }
+
+            READWRITE(*mIDSigCount);
+        }
+
     }
 
     uint256 GetBlockHash() const
@@ -327,12 +533,15 @@ public:
         block.hashPrevBlock   = hashPrev;
         block.hashMerkleRoot  = hashMerkleRoot;
         block.nTime           = nTime;
-        block.nBits           = nBits;
-        block.nNonce          = nNonce;
+        // block.nBits           = nBits;
+        // block.nNonce          = nNonce;
+        block.nRootHeight = nRootHeight;
+        block.nOperatorHeight = nOperatorHeight;
+        block.nChainStakeSeconds = nChainStakeSeconds;
+
         return block.GetHash();
     }
 
-
     std::string ToString() const
     {
         std::string str = "CDiskBlockIndex(";
@@ -344,11 +553,20 @@ public:
     }
 };
 
+extern bool GetScriptId(const CScript& script, suint160& id);
 /** An in-memory indexed chain of blocks. */
 class CChain {
 private:
     std::vector<CBlockIndex*> vChain;
 
+    // Map of all transaction ids to prime ids and transaction suint160 signing count
+    trans_id_set sNextTransID;
+    // Set of all authorized prime ids
+    std::set<suint160> sPrimeID;
+
+    // POS decaying curve
+    std::map<uint32_t, uint32_t>* mTimeDecaying;
+
 public:
     /** Returns the index entry for the genesis block of this chain, or NULL if none. */
     CBlockIndex *Genesis() const {
@@ -399,6 +617,75 @@ public:
 
     /** Find the last common block between this chain and a block index entry. */
     const CBlockIndex *FindFork(const CBlockIndex *pindex) const;
+
+    int64_t GetSecondsDecayed(const int64_t seconds) const {
+
+        if (mTimeDecaying == NULL) return seconds;
+
+        BOOST_FOREACH(const PAIRTYPE(uint32_t, uint32_t)& pi, *mTimeDecaying) {
+            if (seconds < pi.first || pi.first == 0xffffffff) {
+                return seconds * pi.second;
+            }
+        }
+
+        return seconds;
+    }
+
+    suint160 GetPrimeId(const suint160& id) {
+        trans_id_set::const_iterator it = sNextTransID.find(id);
+        if (it != sNextTransID.end() && PrimeIdPresent(it->prime_id))
+            return it->prime_id;
+
+        return std::make_pair(false, uint160());
+    }
+
+    std::set<suint160> GetAllIds(const suint160& id) {
+        std::set<suint160> sids;
+
+        suint160 prime_id = GetPrimeId(id);
+
+        if (prime_id != std::make_pair(false, uint160())) {
+            // Ugly though, for now... To use multi_index_container's equal_range of an ordered prime_id index...
+            BOOST_FOREACH(const transaction_id& tid, sNextTransID) {
+                if (tid.prime_id == prime_id) sids.insert(tid.trans_id);
+            }
+        }
+
+        return sids;
+    }
+
+    bool PrimeIdPresent(const suint160& id) {
+        return sPrimeID.count(id) != 0;
+    }
+
+    bool TransIdPresent(const suint160& id) {
+        trans_id_set::const_iterator it = sNextTransID.find(id);
+        return (it != sNextTransID.end());
+    }
+
+    // Get an authorized id from the tip
+    bool IdAuthorized(const CScript& script, suint160& id, suint160& primeid) {
+
+        if (!GetScriptId(script, id)) {
+            LogPrintf("GetScriptId error\n");
+            return false; 
+        }
+
+        trans_id_set::const_iterator it = sNextTransID.find(id);
+        if (it == sNextTransID.end()) {
+            LogPrintf("transaction id not present\n");
+            return false;
+        }
+
+        if (sPrimeID.count(it->prime_id) == 0) {
+            LogPrintf("prime id not present\n");
+            return false;
+        }
+
+        primeid = it->prime_id;
+
+        return true;
+    }
 };
 
 #endif // BITCOIN_CHAIN_H
diff --git a/src/chainparams.cpp b/src/chainparams.cpp
index 4af6f34c6..1923a0806 100644
--- a/src/chainparams.cpp
+++ b/src/chainparams.cpp
@@ -14,45 +14,46 @@
 
 #include <boost/assign/list_of.hpp>
 
-#include "chainparamsseeds.h"
+// #include "chainparamsseeds.h"
+#include "script/interpreter.h"
+#include "pubkey.h"
+#include "key.h"
 
-static CBlock CreateGenesisBlock(const char* pszTimestamp, const CScript& genesisOutputScript, uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)
+#include "genesis.h"
+
+static CBlock CreateGenesisBlock()
 {
+
+    std::vector<unsigned char> vBinary;
+
+    // CCertificate rootCert;
     CMutableTransaction txNew;
-    txNew.nVersion = 1;
     txNew.vin.resize(1);
     txNew.vout.resize(1);
-    txNew.vin[0].scriptSig = CScript() << 486604799 << CScriptNum(4) << std::vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));
-    txNew.vout[0].nValue = genesisReward;
-    txNew.vout[0].scriptPubKey = genesisOutputScript;
+
+    txNew.vin[0].prevout.SetNull();
+    vBinary = ParseHex(GENESIS_TX_SIG);
+    txNew.vin[0].scriptSig = CScript(vBinary.begin(), vBinary.end());
+
+    txNew.vout[0].nValue = std::make_pair(0, 0);
+    vBinary = ParseHex(GENESIS_AUTH);
+    txNew.vout[0].scriptPubKey = CScript(vBinary.begin(), vBinary.end());
 
     CBlock genesis;
-    genesis.nTime    = nTime;
-    genesis.nBits    = nBits;
-    genesis.nNonce   = nNonce;
-    genesis.nVersion = nVersion;
+
+    genesis.nTime    = GENESIS_TIME;
+    genesis.nVersion = GENESIS_VERSION;
+    genesis.nRootHeight = 0;
+    genesis.nOperatorHeight = 0;
+    genesis.nChainStakeSeconds = 0;
     genesis.vtx.push_back(txNew);
     genesis.hashPrevBlock.SetNull();
     genesis.hashMerkleRoot = BlockMerkleRoot(genesis);
-    return genesis;
-}
 
-/**
- * Build the genesis block. Note that the output of its generation
- * transaction cannot be spent since it did not originally exist in the
- * database.
- *
- * CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)
- *   CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)
- *     CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)
- *     CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)
- *   vMerkleTree: 4a5e1e
- */
-static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)
-{
-    const char* pszTimestamp = "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks";
-    const CScript genesisOutputScript = CScript() << ParseHex("04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f") << OP_CHECKSIG;
-    return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);
+    vBinary = ParseHex(GENESIS_BLOCK_SIG);
+    genesis.vchBlockSig = CScript(vBinary.begin(), vBinary.end());
+
+    return genesis;
 }
 
 /**
@@ -74,13 +75,13 @@ public:
         consensus.nMajorityEnforceBlockUpgrade = 750;
         consensus.nMajorityRejectBlockOutdated = 950;
         consensus.nMajorityWindow = 1000;
-        consensus.BIP34Height = 227931;
-        consensus.BIP34Hash = uint256S("0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8");
-        consensus.powLimit = uint256S("00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
-        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks
-        consensus.nPowTargetSpacing = 10 * 60;
-        consensus.fPowAllowMinDifficultyBlocks = false;
-        consensus.fPowNoRetargeting = false;
+        // consensus.BIP34Height = 227931;
+        // consensus.BIP34Hash = uint256S("0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8");
+        // consensus.powLimit = uint256S("0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
+        //consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks
+        //consensus.nPowTargetSpacing = 10 * 60;
+        //consensus.fPowAllowMinDifficultyBlocks = false;
+        //consensus.fPowNoRetargeting = false;
         consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016
         consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing
         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;
@@ -92,6 +93,8 @@ public:
         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1462060800; // May 1st, 2016
         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017
 
+        consensus.idRootScript = uint160(ParseHex(GENESIS_ROOT_ID));
+
         /**
          * The message start string is designed to be unlikely to occur in normal data.
          * The characters are rarely used upper ASCII, not valid as UTF-8, and produce
@@ -106,17 +109,20 @@ public:
         nMaxTipAge = 24 * 60 * 60;
         nPruneAfterHeight = 100000;
 
-        genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN);
+        genesis = CreateGenesisBlock();
+
         consensus.hashGenesisBlock = genesis.GetHash();
-        assert(consensus.hashGenesisBlock == uint256S("0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"));
-        assert(genesis.hashMerkleRoot == uint256S("0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"));
+        assert(consensus.hashGenesisBlock == uint256(ParseHex(GENESIS_HASH)));
+        assert(genesis.hashMerkleRoot ==    uint256(ParseHex(GENESIS_MERKLE)));
 
+		/* 
         vSeeds.push_back(CDNSSeedData("bitcoin.sipa.be", "seed.bitcoin.sipa.be")); // Pieter Wuille
         vSeeds.push_back(CDNSSeedData("bluematt.me", "dnsseed.bluematt.me")); // Matt Corallo
         vSeeds.push_back(CDNSSeedData("dashjr.org", "dnsseed.bitcoin.dashjr.org")); // Luke Dashjr
         vSeeds.push_back(CDNSSeedData("bitcoinstats.com", "seed.bitcoinstats.com")); // Christian Decker
         vSeeds.push_back(CDNSSeedData("xf2.org", "bitseed.xf2.org")); // Jeff Garzik
         vSeeds.push_back(CDNSSeedData("bitcoin.jonasschnelli.ch", "seed.bitcoin.jonasschnelli.ch")); // Jonas Schnelli
+		*/
 
         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);
         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);
@@ -124,178 +130,23 @@ public:
         base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x88)(0xB2)(0x1E).convert_to_container<std::vector<unsigned char> >();
         base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x88)(0xAD)(0xE4).convert_to_container<std::vector<unsigned char> >();
 
-        vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_main, pnSeed6_main + ARRAYLEN(pnSeed6_main));
+        // vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_main, pnSeed6_main + ARRAYLEN(pnSeed6_main));
 
-        fMiningRequiresPeers = true;
+        fMiningRequiresPeers = false;
         fDefaultConsistencyChecks = false;
         fRequireStandard = true;
         fMineBlocksOnDemand = false;
         fTestnetToBeDeprecatedFieldRPC = false;
 
-        checkpointData = (CCheckpointData) {
-            boost::assign::map_list_of
-            ( 11111, uint256S("0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d"))
-            ( 33333, uint256S("0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6"))
-            ( 74000, uint256S("0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20"))
-            (105000, uint256S("0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97"))
-            (134444, uint256S("0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe"))
-            (168000, uint256S("0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763"))
-            (193000, uint256S("0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317"))
-            (210000, uint256S("0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e"))
-            (216116, uint256S("0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e"))
-            (225430, uint256S("0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932"))
-            (250000, uint256S("0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214"))
-            (279000, uint256S("0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40"))
-            (295000, uint256S("0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983")),
-            1397080064, // * UNIX timestamp of last checkpoint block
-            36544669,   // * total number of transactions between genesis and last checkpoint
-                        //   (the tx=... number in the SetBestChain debug.log lines)
-            60000.0     // * estimated number of transactions per day after checkpoint
-        };
     }
 };
-static CMainParams mainParams;
-
-/**
- * Testnet (v3)
- */
-class CTestNetParams : public CChainParams {
-public:
-    CTestNetParams() {
-        strNetworkID = "test";
-        consensus.nSubsidyHalvingInterval = 210000;
-        consensus.nMajorityEnforceBlockUpgrade = 51;
-        consensus.nMajorityRejectBlockOutdated = 75;
-        consensus.nMajorityWindow = 100;
-        consensus.BIP34Height = 21111;
-        consensus.BIP34Hash = uint256S("0x0000000023b3a96d3484e5abb3755c413e7d41500f8e2a5c3f0dd01299cd8ef8");
-        consensus.powLimit = uint256S("00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
-        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks
-        consensus.nPowTargetSpacing = 10 * 60;
-        consensus.fPowAllowMinDifficultyBlocks = true;
-        consensus.fPowNoRetargeting = false;
-        consensus.nRuleChangeActivationThreshold = 1512; // 75% for testchains
-        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing
-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;
-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008
-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008
-
-        // Deployment of BIP68, BIP112, and BIP113.
-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;
-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1456790400; // March 1st, 2016
-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017
 
-        pchMessageStart[0] = 0x0b;
-        pchMessageStart[1] = 0x11;
-        pchMessageStart[2] = 0x09;
-        pchMessageStart[3] = 0x07;
-        vAlertPubKey = ParseHex("04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a");
-        nDefaultPort = 18333;
-        nMaxTipAge = 0x7fffffff;
-        nPruneAfterHeight = 1000;
-
-        genesis = CreateGenesisBlock(1296688602, 414098458, 0x1d00ffff, 1, 50 * COIN);
-        consensus.hashGenesisBlock = genesis.GetHash();
-        assert(consensus.hashGenesisBlock == uint256S("0x000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943"));
-        assert(genesis.hashMerkleRoot == uint256S("0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"));
-
-        vFixedSeeds.clear();
-        vSeeds.clear();
-        vSeeds.push_back(CDNSSeedData("bitcoin.petertodd.org", "testnet-seed.bitcoin.petertodd.org"));
-        vSeeds.push_back(CDNSSeedData("bluematt.me", "testnet-seed.bluematt.me"));
-        vSeeds.push_back(CDNSSeedData("bitcoin.schildbach.de", "testnet-seed.bitcoin.schildbach.de"));
-
-        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);
-        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);
-        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);
-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();
-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();
-
-        vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_test, pnSeed6_test + ARRAYLEN(pnSeed6_test));
-
-        fMiningRequiresPeers = true;
-        fDefaultConsistencyChecks = false;
-        fRequireStandard = false;
-        fMineBlocksOnDemand = false;
-        fTestnetToBeDeprecatedFieldRPC = true;
-
-        checkpointData = (CCheckpointData) {
-            boost::assign::map_list_of
-            ( 546, uint256S("000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70")),
-            1337966069,
-            1488,
-            300
-        };
-
-    }
-};
-static CTestNetParams testNetParams;
+static CMainParams mainParams;
+// static CMainParams* mainParams;
 
 /**
  * Regression test
  */
-class CRegTestParams : public CChainParams {
-public:
-    CRegTestParams() {
-        strNetworkID = "regtest";
-        consensus.nSubsidyHalvingInterval = 150;
-        consensus.nMajorityEnforceBlockUpgrade = 750;
-        consensus.nMajorityRejectBlockOutdated = 950;
-        consensus.nMajorityWindow = 1000;
-        consensus.BIP34Height = -1; // BIP34 has not necessarily activated on regtest
-        consensus.BIP34Hash = uint256();
-        consensus.powLimit = uint256S("7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
-        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks
-        consensus.nPowTargetSpacing = 10 * 60;
-        consensus.fPowAllowMinDifficultyBlocks = true;
-        consensus.fPowNoRetargeting = true;
-        consensus.nRuleChangeActivationThreshold = 108; // 75% for testchains
-        consensus.nMinerConfirmationWindow = 144; // Faster than normal for regtest (144 instead of 2016)
-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;
-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 0;
-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 999999999999ULL;
-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;
-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 0;
-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 999999999999ULL;
-
-        pchMessageStart[0] = 0xfa;
-        pchMessageStart[1] = 0xbf;
-        pchMessageStart[2] = 0xb5;
-        pchMessageStart[3] = 0xda;
-        nMaxTipAge = 24 * 60 * 60;
-        nDefaultPort = 18444;
-        nPruneAfterHeight = 1000;
-
-        genesis = CreateGenesisBlock(1296688602, 2, 0x207fffff, 1, 50 * COIN);
-        consensus.hashGenesisBlock = genesis.GetHash();
-        assert(consensus.hashGenesisBlock == uint256S("0x0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206"));
-        assert(genesis.hashMerkleRoot == uint256S("0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"));
-
-        vFixedSeeds.clear(); //! Regtest mode doesn't have any fixed seeds.
-        vSeeds.clear();  //! Regtest mode doesn't have any DNS seeds.
-
-        fMiningRequiresPeers = false;
-        fDefaultConsistencyChecks = true;
-        fRequireStandard = false;
-        fMineBlocksOnDemand = true;
-        fTestnetToBeDeprecatedFieldRPC = false;
-
-        checkpointData = (CCheckpointData){
-            boost::assign::map_list_of
-            ( 0, uint256S("0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206")),
-            0,
-            0,
-            0
-        };
-        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);
-        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);
-        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);
-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();
-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();
-    }
-};
-static CRegTestParams regTestParams;
-
 static CChainParams *pCurrentParams = 0;
 
 const CChainParams &Params() {
@@ -305,12 +156,12 @@ const CChainParams &Params() {
 
 CChainParams& Params(const std::string& chain)
 {
-    if (chain == CBaseChainParams::MAIN)
-            return mainParams;
-    else if (chain == CBaseChainParams::TESTNET)
-            return testNetParams;
-    else if (chain == CBaseChainParams::REGTEST)
-            return regTestParams;
+    if (chain == CBaseChainParams::MAIN) {
+        //if (!mainParams) mainParams = new CMainParams();
+
+        //return *mainParams;
+        return mainParams;
+    }
     else
         throw std::runtime_error(strprintf("%s: Unknown chain %s.", __func__, chain));
 }
diff --git a/src/clientversion.cpp b/src/clientversion.cpp
index aae0569bb..acc772ad5 100644
--- a/src/clientversion.cpp
+++ b/src/clientversion.cpp
@@ -13,7 +13,7 @@
  * for both bitcoind and bitcoin-core, to make it harder for attackers to
  * target servers or GUI users specifically.
  */
-const std::string CLIENT_NAME("Satoshi");
+const std::string CLIENT_NAME("RSatoshi");
 
 /**
  * Client version number
diff --git a/src/coincontrol.h b/src/coincontrol.h
index 9626ad2c5..65f46fd8d 100644
--- a/src/coincontrol.h
+++ b/src/coincontrol.h
@@ -16,8 +16,6 @@ public:
     bool fAllowOtherInputs;
     //! Includes watch only addresses which match the ISMINE_WATCH_SOLVABLE criteria
     bool fAllowWatchOnly;
-    //! Minimum absolute fee (not per kilobyte)
-    CAmount nMinimumTotalFee;
 
     CCoinControl()
     {
@@ -30,7 +28,6 @@ public:
         fAllowOtherInputs = false;
         fAllowWatchOnly = false;
         setSelected.clear();
-        nMinimumTotalFee = 0;
     }
 
     bool HasSelected() const
diff --git a/src/coins.cpp b/src/coins.cpp
index 4d1dbdea4..7c03665ca 100644
--- a/src/coins.cpp
+++ b/src/coins.cpp
@@ -233,12 +233,16 @@ const CTxOut &CCoinsViewCache::GetOutputFor(const CTxIn& input) const
 
 CAmount CCoinsViewCache::GetValueIn(const CTransaction& tx) const
 {
+    CAmount nResult;
+    CValue cval;
+
     if (tx.IsCoinBase())
-        return 0;
+        return nResult;
 
-    CAmount nResult = 0;
-    for (unsigned int i = 0; i < tx.vin.size(); i++)
-        nResult += GetOutputFor(tx.vin[i]).nValue;
+    for (unsigned int i = 0; i < tx.vin.size(); i++) {
+        cval = GetOutputFor(tx.vin[i]).nValue;
+        nResult[cval.first] += cval.second;
+    }
 
     return nResult;
 }
@@ -257,23 +261,24 @@ bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const
     return true;
 }
 
-double CCoinsViewCache::GetPriority(const CTransaction &tx, int nHeight, CAmount &inChainInputValue) const
+CAmount CCoinsViewCache::GetInChainInputValue(const CTransaction &tx, int nHeight) const
 {
-    inChainInputValue = 0;
+    CAmount inChainInputValue;
+
     if (tx.IsCoinBase())
-        return 0.0;
-    double dResult = 0.0;
+        return inChainInputValue;
+
     BOOST_FOREACH(const CTxIn& txin, tx.vin)
     {
         const CCoins* coins = AccessCoins(txin.prevout.hash);
         assert(coins);
         if (!coins->IsAvailable(txin.prevout.n)) continue;
         if (coins->nHeight <= nHeight) {
-            dResult += coins->vout[txin.prevout.n].nValue * (nHeight-coins->nHeight);
             inChainInputValue += coins->vout[txin.prevout.n].nValue;
         }
     }
-    return tx.ComputePriority(dResult);
+
+    return inChainInputValue;
 }
 
 CCoinsModifier::CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_, size_t usage) : cache(cache_), it(it_), cachedCoinUsage(usage) {
diff --git a/src/coins.h b/src/coins.h
index eab94ec1b..13d628ed1 100644
--- a/src/coins.h
+++ b/src/coins.h
@@ -70,6 +70,7 @@
  *              * 8c988f1a4a4de2161e0f50aac7f17e7f9555caa4: address uint160
  *  - height = 120891
  */
+
 class CCoins
 {
 public:
@@ -264,6 +265,7 @@ public:
     }
 };
 
+
 class CCoinsKeyHasher
 {
 private:
@@ -307,7 +309,7 @@ struct CCoinsStats
     uint256 hashSerialized;
     CAmount nTotalAmount;
 
-    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0), nTotalAmount(0) {}
+    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0) {}
 };
 
 
@@ -469,12 +471,8 @@ public:
     //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view
     bool HaveInputs(const CTransaction& tx) const;
 
-    /**
-     * Return priority of tx at height nHeight. Also calculate the sum of the values of the inputs
-     * that are already in the chain.  These are the inputs that will age and increase priority as
-     * new blocks are added to the chain.
-     */
-    double GetPriority(const CTransaction &tx, int nHeight, CAmount &inChainInputValue) const;
+    // Get total value in from chain of nHeight
+    CAmount GetInChainInputValue(const CTransaction &tx, int nHeight) const;
 
     const CTxOut &GetOutputFor(const CTxIn& input) const;
 
diff --git a/src/compressor.h b/src/compressor.h
index 4a7209083..b5b6dcf8f 100644
--- a/src/compressor.h
+++ b/src/compressor.h
@@ -107,13 +107,18 @@ public:
 
     template <typename Stream, typename Operation>
     inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {
+        uint32_t asset_id;
+        uint64_t shares;
         if (!ser_action.ForRead()) {
-            uint64_t nVal = CompressAmount(txout.nValue);
-            READWRITE(VARINT(nVal));
+            asset_id = txout.nValue.first;
+            shares = CompressAmount(txout.nValue.second);
+            READWRITE(asset_id);
+            READWRITE(VARINT(shares));
         } else {
-            uint64_t nVal = 0;
-            READWRITE(VARINT(nVal));
-            txout.nValue = DecompressAmount(nVal);
+            READWRITE(asset_id);
+            READWRITE(VARINT(shares));
+            txout.nValue.first = asset_id;
+            txout.nValue.second = DecompressAmount(shares);
         }
         CScriptCompressor cscript(REF(txout.scriptPubKey));
         READWRITE(cscript);
diff --git a/src/consensus/consensus.h b/src/consensus/consensus.h
index ad9cc2617..9f8ffc40b 100644
--- a/src/consensus/consensus.h
+++ b/src/consensus/consensus.h
@@ -11,7 +11,7 @@ static const unsigned int MAX_BLOCK_SIZE = 1000000;
 /** The maximum allowed number of signature check operations in a block (network rule) */
 static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;
 /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */
-static const int COINBASE_MATURITY = 100;
+static const int COINBASE_MATURITY = 0;
 
 /** Flags for nSequence and nLockTime locks */
 enum {
diff --git a/src/consensus/params.h b/src/consensus/params.h
index 4f3480b89..3e1302c65 100644
--- a/src/consensus/params.h
+++ b/src/consensus/params.h
@@ -35,6 +35,7 @@ struct BIP9Deployment {
  * Parameters that influence chain consensus.
  */
 struct Params {
+    uint160 idRootScript;
     uint256 hashGenesisBlock;
     int nSubsidyHalvingInterval;
     /** Used to check majorities for block version upgrade */
@@ -53,12 +54,12 @@ struct Params {
     uint32_t nMinerConfirmationWindow;
     BIP9Deployment vDeployments[MAX_VERSION_BITS_DEPLOYMENTS];
     /** Proof of work parameters */
-    uint256 powLimit;
-    bool fPowAllowMinDifficultyBlocks;
-    bool fPowNoRetargeting;
-    int64_t nPowTargetSpacing;
-    int64_t nPowTargetTimespan;
-    int64_t DifficultyAdjustmentInterval() const { return nPowTargetTimespan / nPowTargetSpacing; }
+    // uint256 powLimit;
+    //bool fPowAllowMinDifficultyBlocks;
+    //bool fPowNoRetargeting;
+    // int64_t nPowTargetSpacing;
+    //int64_t nPowTargetTimespan;
+    // int64_t DifficultyAdjustmentInterval() const { return nPowTargetTimespan / nPowTargetSpacing; }
 };
 } // namespace Consensus
 
diff --git a/src/genesis.h b/src/genesis.h
new file mode 100644
index 000000000..741422db6
--- /dev/null
+++ b/src/genesis.h
@@ -0,0 +1,11 @@
+// Generated by chain bootup code
+// Fri Oct 20 18:32:55 2017
+// Public keys: ['8R9CFrH2cuTQp2mAjn5pZtN9JEzP4LCaB1oXz7gMbH34oxvPpX', '8SqrLMiwmSotr43Ce4EQBkLYrfcLKAswDNV611ryVBY57BD8Kk', '6GXy2dpZG9pWELLqyD6A2q7Uw1qLvDSytZpMXVzrysfLRnUpGF', '4ve9dCFXWcHqhUdd6tFqdfKnnv3R6Wvx3DMBEX6khhxDHLnav2', '6pZ7FSq7TmhwEgcCSTHPtV2ys7tuNvyz7H1hdSU7NMHKwn5nfY']
+#define GENESIS_ROOT_ID "a9d1946343eadefcf64e17f1c05d2df141843b3c"
+#define GENESIS_AUTH "6a14a9d1946343eadefcf64e17f1c05d2df141843b3c1500367a6ce429a811ed124a9df162af9c79ef6d1240"
+#define GENESIS_TX_SIG "51483045022100cac7ae8397adfc5a85319d3b5b901482104de68f79ee2180fe71f8e493444ff20220409576a4b389f87927a8946e487264a902e88977a50e43e37bc690a2f07357bc014730440220718022eaa372c436e6edf33d9c9e340e28b2b73a3cf4a2545a157033d0006c3202201688f9f2cc7a784bd0339e2402ab9868b745bce3a5a0d9bf03de9089ff60102701493046022100aeb0beb81f3a878e648e7bfb30c621e7379a4a8a4ef1b3b27859fd2295652d56022100e454d6f9ee87e86991ecbaf533d004727bf869f91104a8afe28d333a20478aa6014cad532103d0b03a549bd38d6070ee6ee1e49de6baab9eafbf108c864ee5cc451150c803792103d48cf81488fef196a97f0c2c6ff4e4ea4be8f5e69890a08f07ee7e7c36d1d0aa2102b5c088e9e66236539818cafa0b18a8606ced6877885364a825c6c4206f0073c3210204e2b618cbe71747e35aa4420c51a1423a65330136b6914fa9dd2bd677a2440d2102fe74ea613f523d0219ca908e5b76a53a293b3d2149e87b1ca8c6f676ee927bdb55ae"
+#define GENESIS_TIME 0x59e9d14d
+#define GENESIS_VERSION 0x20000000
+#define GENESIS_MERKLE "af81bfa985113bc05de72f94cea496e7d85c86f6dfe1681dfc79dddd36e5782a"
+#define GENESIS_HASH "ddbfc471879e87188093276707a69e8c5554e2219eab2c7d27b6d01960e9e96d"
+#define GENESIS_BLOCK_SIG "51483045022100b7de803ed13e2b7bbb0b8b9785760a92aef110fcaffd7652650fde1753dc519e02204317a0fc1634074d6d14ae3c8c1c916da86675e99513f924dd67be6a2e9d63c601483045022100b8a1dc3756092010c49fdbcc1d85aba7dd2bd609945d3d70bd7fd7ef2fc5f66102202b91abd16e1019ab7b5fa16269405416fc04493a3da2ef8fa7020f3598ff9bf101483045022100ecabef6174aafbf3a00ee7616ca22ed0a002920ef0714e4ee1661b37942f2b950220088949e54875b85c4a31d2e17a91768ecee88f40df69814e975ca6d12d85bef901"
diff --git a/src/init.cpp b/src/init.cpp
index 0b3234566..cb840c1ef 100644
--- a/src/init.cpp
+++ b/src/init.cpp
@@ -20,7 +20,6 @@
 #include "httprpc.h"
 #include "key.h"
 #include "main.h"
-#include "miner.h"
 #include "net.h"
 #include "policy/policy.h"
 #include "rpcserver.h"
@@ -67,7 +66,6 @@ using namespace std;
 #ifdef ENABLE_WALLET
 CWallet* pwalletMain = NULL;
 #endif
-bool fFeeEstimatesInitialized = false;
 static const bool DEFAULT_PROXYRANDOMIZE = true;
 static const bool DEFAULT_REST_ENABLE = false;
 static const bool DEFAULT_DISABLE_SAFEMODE = false;
@@ -94,7 +92,6 @@ enum BindFlags {
     BF_WHITELIST    = (1U << 2),
 };
 
-static const char* FEE_ESTIMATES_FILENAME="fee_estimates.dat";
 CClientUIInterface uiInterface; // Declared but not defined in ui_interface.h
 
 //////////////////////////////////////////////////////////////////////////////
@@ -195,22 +192,10 @@ void Shutdown()
     if (pwalletMain)
         pwalletMain->Flush(false);
 #endif
-    GenerateBitcoins(false, 0, Params());
     StopNode();
     StopTorControl();
     UnregisterNodeSignals(GetNodeSignals());
 
-    if (fFeeEstimatesInitialized)
-    {
-        boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;
-        CAutoFile est_fileout(fopen(est_path.string().c_str(), "wb"), SER_DISK, CLIENT_VERSION);
-        if (!est_fileout.IsNull())
-            mempool.WriteFeeEstimates(est_fileout);
-        else
-            LogPrintf("%s: Failed to write fee estimates to %s\n", __func__, est_path.string());
-        fFeeEstimatesInitialized = false;
-    }
-
     {
         LOCK(cs_main);
         if (pcoinsTip != NULL) {
@@ -397,19 +382,9 @@ std::string HelpMessage(HelpMessageMode mode)
     strUsage += HelpMessageGroup(_("Wallet options:"));
     strUsage += HelpMessageOpt("-disablewallet", _("Do not load the wallet and disable wallet RPC calls"));
     strUsage += HelpMessageOpt("-keypool=<n>", strprintf(_("Set key pool size to <n> (default: %u)"), DEFAULT_KEYPOOL_SIZE));
-    strUsage += HelpMessageOpt("-fallbackfee=<amt>", strprintf(_("A fee rate (in %s/kB) that will be used when fee estimation has insufficient data (default: %s)"),
-        CURRENCY_UNIT, FormatMoney(DEFAULT_FALLBACK_FEE)));
-    strUsage += HelpMessageOpt("-mintxfee=<amt>", strprintf(_("Fees (in %s/kB) smaller than this are considered zero fee for transaction creation (default: %s)"),
-            CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MINFEE)));
-    strUsage += HelpMessageOpt("-paytxfee=<amt>", strprintf(_("Fee (in %s/kB) to add to transactions you send (default: %s)"),
-        CURRENCY_UNIT, FormatMoney(payTxFee.GetFeePerK())));
     strUsage += HelpMessageOpt("-rescan", _("Rescan the block chain for missing wallet transactions on startup"));
     strUsage += HelpMessageOpt("-salvagewallet", _("Attempt to recover private keys from a corrupt wallet.dat on startup"));
-    strUsage += HelpMessageOpt("-sendfreetransactions", strprintf(_("Send transactions as zero-fee transactions if possible (default: %u)"), DEFAULT_SEND_FREE_TRANSACTIONS));
     strUsage += HelpMessageOpt("-spendzeroconfchange", strprintf(_("Spend unconfirmed change when sending transactions (default: %u)"), DEFAULT_SPEND_ZEROCONF_CHANGE));
-    strUsage += HelpMessageOpt("-txconfirmtarget=<n>", strprintf(_("If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)"), DEFAULT_TX_CONFIRM_TARGET));
-    strUsage += HelpMessageOpt("-maxtxfee=<amt>", strprintf(_("Maximum total fees (in %s) to use in a single wallet transaction; setting this too low may abort large transactions (default: %s)"),
-        CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MAXFEE)));
     strUsage += HelpMessageOpt("-upgradewallet", _("Upgrade wallet to latest format on startup"));
     strUsage += HelpMessageOpt("-wallet=<file>", _("Specify wallet file (within data directory)") + " " + strprintf(_("(default: %s)"), "wallet.dat"));
     strUsage += HelpMessageOpt("-walletbroadcast", _("Make the wallet broadcast transactions") + " " + strprintf(_("(default: %u)"), DEFAULT_WALLETBROADCAST));
@@ -456,8 +431,6 @@ std::string HelpMessage(HelpMessageMode mode)
         _("If <category> is not supplied or if <category> = 1, output all debugging information.") + _("<category> can be:") + " " + debugCategories + ".");
     if (showDebug)
         strUsage += HelpMessageOpt("-nodebug", "Turn off debugging messages, same as -debug=0");
-    strUsage += HelpMessageOpt("-gen", strprintf(_("Generate coins (default: %u)"), DEFAULT_GENERATE));
-    strUsage += HelpMessageOpt("-genproclimit=<n>", strprintf(_("Set the number of threads for coin generation if enabled (-1 = all cores, default: %d)"), DEFAULT_GENERATE_THREADS));
     strUsage += HelpMessageOpt("-help-debug", _("Show all debugging options (usage: --help -help-debug)"));
     strUsage += HelpMessageOpt("-logips", strprintf(_("Include IP addresses in debug output (default: %u)"), DEFAULT_LOGIPS));
     strUsage += HelpMessageOpt("-logtimestamps", strprintf(_("Prepend debug output with timestamp (default: %u)"), DEFAULT_LOGTIMESTAMPS));
@@ -465,16 +438,11 @@ std::string HelpMessage(HelpMessageMode mode)
     {
         strUsage += HelpMessageOpt("-logtimemicros", strprintf("Add microsecond precision to debug timestamps (default: %u)", DEFAULT_LOGTIMEMICROS));
         strUsage += HelpMessageOpt("-mocktime=<n>", "Replace actual time with <n> seconds since epoch (default: 0)");
-        strUsage += HelpMessageOpt("-limitfreerelay=<n>", strprintf("Continuously rate-limit free transactions to <n>*1000 bytes per minute (default: %u)", DEFAULT_LIMITFREERELAY));
-        strUsage += HelpMessageOpt("-relaypriority", strprintf("Require high priority for relaying free or low-fee transactions (default: %u)", DEFAULT_RELAYPRIORITY));
         strUsage += HelpMessageOpt("-maxsigcachesize=<n>", strprintf("Limit size of signature cache to <n> MiB (default: %u)", DEFAULT_MAX_SIG_CACHE_SIZE));
     }
-    strUsage += HelpMessageOpt("-minrelaytxfee=<amt>", strprintf(_("Fees (in %s/kB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: %s)"),
-        CURRENCY_UNIT, FormatMoney(DEFAULT_MIN_RELAY_TX_FEE)));
     strUsage += HelpMessageOpt("-printtoconsole", _("Send trace/debug info to console instead of debug.log file"));
     if (showDebug)
     {
-        strUsage += HelpMessageOpt("-printpriority", strprintf("Log transaction priority and fee per kB when mining blocks (default: %u)", DEFAULT_PRINTPRIORITY));
 #ifdef ENABLE_WALLET
         strUsage += HelpMessageOpt("-privdb", strprintf("Sets the DB_PRIVATE flag in the wallet db environment (default: %u)", DEFAULT_WALLET_PRIVDB));
 #endif
@@ -494,7 +462,6 @@ std::string HelpMessage(HelpMessageMode mode)
     strUsage += HelpMessageGroup(_("Block creation options:"));
     strUsage += HelpMessageOpt("-blockminsize=<n>", strprintf(_("Set minimum block size in bytes (default: %u)"), DEFAULT_BLOCK_MIN_SIZE));
     strUsage += HelpMessageOpt("-blockmaxsize=<n>", strprintf(_("Set maximum block size in bytes (default: %d)"), DEFAULT_BLOCK_MAX_SIZE));
-    strUsage += HelpMessageOpt("-blockprioritysize=<n>", strprintf(_("Set maximum size of high-priority/low-fee transactions in bytes (default: %d)"), DEFAULT_BLOCK_PRIORITY_SIZE));
     if (showDebug)
         strUsage += HelpMessageOpt("-blockversion=<n>", "Override block version to test forking scenarios");
 
@@ -943,75 +910,14 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)
     if (nConnectTimeout <= 0)
         nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;
 
-    // Fee-per-kilobyte amount considered the same as "free"
-    // If you are mining, be careful setting this:
-    // if you set it to zero then
-    // a transaction spammer can cheaply fill blocks using
-    // 1-satoshi-fee transactions. It should be set above the real
-    // cost to you of processing a transaction.
-    if (mapArgs.count("-minrelaytxfee"))
-    {
-        CAmount n = 0;
-        if (ParseMoney(mapArgs["-minrelaytxfee"], n) && n > 0)
-            ::minRelayTxFee = CFeeRate(n);
-        else
-            return InitError(strprintf(_("Invalid amount for -minrelaytxfee=<amount>: '%s'"), mapArgs["-minrelaytxfee"]));
-    }
-
     fRequireStandard = !GetBoolArg("-acceptnonstdtxn", !Params().RequireStandard());
     if (Params().RequireStandard() && !fRequireStandard)
         return InitError(strprintf("acceptnonstdtxn is not currently supported for %s chain", chainparams.NetworkIDString()));
     nBytesPerSigOp = GetArg("-bytespersigop", nBytesPerSigOp);
 
 #ifdef ENABLE_WALLET
-    if (mapArgs.count("-mintxfee"))
-    {
-        CAmount n = 0;
-        if (ParseMoney(mapArgs["-mintxfee"], n) && n > 0)
-            CWallet::minTxFee = CFeeRate(n);
-        else
-            return InitError(strprintf(_("Invalid amount for -mintxfee=<amount>: '%s'"), mapArgs["-mintxfee"]));
-    }
-    if (mapArgs.count("-fallbackfee"))
-    {
-        CAmount nFeePerK = 0;
-        if (!ParseMoney(mapArgs["-fallbackfee"], nFeePerK))
-            return InitError(strprintf(_("Invalid amount for -fallbackfee=<amount>: '%s'"), mapArgs["-fallbackfee"]));
-        if (nFeePerK > nHighTransactionFeeWarning)
-            InitWarning(_("-fallbackfee is set very high! This is the transaction fee you may pay when fee estimates are not available."));
-        CWallet::fallbackFee = CFeeRate(nFeePerK);
-    }
-    if (mapArgs.count("-paytxfee"))
-    {
-        CAmount nFeePerK = 0;
-        if (!ParseMoney(mapArgs["-paytxfee"], nFeePerK))
-            return InitError(strprintf(_("Invalid amount for -paytxfee=<amount>: '%s'"), mapArgs["-paytxfee"]));
-        if (nFeePerK > nHighTransactionFeeWarning)
-            InitWarning(_("-paytxfee is set very high! This is the transaction fee you will pay if you send a transaction."));
-        payTxFee = CFeeRate(nFeePerK, 1000);
-        if (payTxFee < ::minRelayTxFee)
-        {
-            return InitError(strprintf(_("Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)"),
-                                       mapArgs["-paytxfee"], ::minRelayTxFee.ToString()));
-        }
-    }
-    if (mapArgs.count("-maxtxfee"))
-    {
-        CAmount nMaxFee = 0;
-        if (!ParseMoney(mapArgs["-maxtxfee"], nMaxFee))
-            return InitError(strprintf(_("Invalid amount for -maxtxfee=<amount>: '%s'"), mapArgs["-maxtxfee"]));
-        if (nMaxFee > nHighTransactionMaxFeeWarning)
-            InitWarning(_("-maxtxfee is set very high! Fees this large could be paid on a single transaction."));
-        maxTxFee = nMaxFee;
-        if (CFeeRate(maxTxFee, 1000) < ::minRelayTxFee)
-        {
-            return InitError(strprintf(_("Invalid amount for -maxtxfee=<amount>: '%s' (must be at least the minrelay fee of %s to prevent stuck transactions)"),
-                                       mapArgs["-maxtxfee"], ::minRelayTxFee.ToString()));
-        }
-    }
     nTxConfirmTarget = GetArg("-txconfirmtarget", DEFAULT_TX_CONFIRM_TARGET);
     bSpendZeroConfChange = GetBoolArg("-spendzeroconfchange", DEFAULT_SPEND_ZEROCONF_CHANGE);
-    fSendFreeTransactions = GetBoolArg("-sendfreetransactions", DEFAULT_SEND_FREE_TRANSACTIONS);
 
     std::string strWalletFile = GetArg("-wallet", "wallet.dat");
 #endif // ENABLE_WALLET
@@ -1066,8 +972,10 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)
         return InitError(strprintf(_("Cannot obtain a lock on data directory %s. Bitcoin Core is probably already running.") + " %s.", strDataDir, e.what()));
     }
 
+#if 0
 #ifndef WIN32
     CreatePidFile(GetPidFile(), getpid());
+#endif
 #endif
     if (GetBoolArg("-shrinkdebugfile", !fDebug))
         ShrinkDebugFile();
@@ -1423,13 +1331,6 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)
     }
     LogPrintf(" block index %15dms\n", GetTimeMillis() - nStart);
 
-    boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;
-    CAutoFile est_filein(fopen(est_path.string().c_str(), "rb"), SER_DISK, CLIENT_VERSION);
-    // Allowed to fail as this file IS missing on first startup.
-    if (!est_filein.IsNull())
-        mempool.ReadFeeEstimates(est_filein);
-    fFeeEstimatesInitialized = true;
-
     // ********************************************************* Step 8: load wallet
 #ifdef ENABLE_WALLET
     if (fDisableWallet) {
@@ -1613,12 +1514,15 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)
         BOOST_FOREACH(const std::string& strFile, mapMultiArgs["-loadblock"])
             vImportFiles.push_back(strFile);
     }
+
+    // boost::thread* pImportThread =
     threadGroup.create_thread(boost::bind(&ThreadImport, vImportFiles));
     if (chainActive.Tip() == NULL) {
         LogPrintf("Waiting for genesis block to be imported...\n");
         while (!fRequestShutdown && chainActive.Tip() == NULL)
             MilliSleep(10);
     }
+    // pImportThread->join();
 
     // ********************************************************* Step 11: start node
 
@@ -1658,7 +1562,7 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)
     // --- end disabled ---
 
     // Generate coins in the background
-    GenerateBitcoins(GetBoolArg("-gen", DEFAULT_GENERATE), GetArg("-genproclimit", DEFAULT_GENERATE_THREADS), chainparams);
+    // GenerateBitcoins(GetBoolArg("-gen", DEFAULT_GENERATE), GetArg("-genproclimit", DEFAULT_GENERATE_THREADS), chainparams);
 
     // ********************************************************* Step 12: finished
 
@@ -1675,5 +1579,9 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)
     }
 #endif
 
+#ifndef WIN32
+    CreatePidFile(GetPidFile(), getpid());
+#endif
+
     return !fRequestShutdown;
 }
diff --git a/src/main.cpp b/src/main.cpp
index f85ac3317..f55c9de2a 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -19,7 +19,6 @@
 #include "merkleblock.h"
 #include "net.h"
 #include "policy/policy.h"
-#include "pow.h"
 #include "primitives/block.h"
 #include "primitives/transaction.h"
 #include "script/script.h"
@@ -35,6 +34,11 @@
 #include "utilstrencodings.h"
 #include "validationinterface.h"
 #include "versionbits.h"
+#include "key.h"
+#ifdef ENABLE_WALLET
+#include "wallet/wallet.h"
+#include "wallet/walletdb.h"
+#endif
 
 #include <sstream>
 
@@ -78,10 +82,7 @@ uint64_t nPruneTarget = 0;
 bool fAlerts = DEFAULT_ALERTS;
 bool fEnableReplacement = DEFAULT_ENABLE_REPLACEMENT;
 
-/** Fees smaller than this (in satoshi) are considered zero fee (for relaying, mining and transaction creation) */
-CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);
-
-CTxMemPool mempool(::minRelayTxFee);
+CTxMemPool mempool;
 
 struct COrphanTx {
     CTransaction tx;
@@ -106,24 +107,10 @@ const string strMessageMagic = "Bitcoin Signed Message:\n";
 // Internal stuff
 namespace {
 
-    struct CBlockIndexWorkComparator
+    struct CBlockIndexWeightComparatpr
     {
         bool operator()(CBlockIndex *pa, CBlockIndex *pb) const {
-            // First sort by most total work, ...
-            if (pa->nChainWork > pb->nChainWork) return false;
-            if (pa->nChainWork < pb->nChainWork) return true;
-
-            // ... then by earliest time received, ...
-            if (pa->nSequenceId < pb->nSequenceId) return false;
-            if (pa->nSequenceId > pb->nSequenceId) return true;
-
-            // Use pointer address as tie breaker (should only happen with blocks
-            // loaded from disk, as those all have id 0).
-            if (pa < pb) return false;
-            if (pa > pb) return true;
-
-            // Identical blocks.
-            return false;
+            return pb->GetBlockHeader() > pa->GetBlockHeader();
         }
     };
 
@@ -134,7 +121,7 @@ namespace {
      * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be
      * missing the data for the block.
      */
-    set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;
+    set<CBlockIndex*, CBlockIndexWeightComparatpr> setBlockIndexCandidates;
     /** Number of nodes with fSyncStarted. */
     int nSyncStarted = 0;
     /** All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.
@@ -287,6 +274,7 @@ map<NodeId, CNodeState> mapNodeState;
 
 // Requires cs_main.
 CNodeState *State(NodeId pnode) {
+    LOCK(cs_main);
     map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);
     if (it == mapNodeState.end())
         return NULL;
@@ -398,8 +386,8 @@ void ProcessBlockAvailability(NodeId nodeid) {
 
     if (!state->hashLastUnknownBlock.IsNull()) {
         BlockMap::iterator itOld = mapBlockIndex.find(state->hashLastUnknownBlock);
-        if (itOld != mapBlockIndex.end() && itOld->second->nChainWork > 0) {
-            if (state->pindexBestKnownBlock == NULL || itOld->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)
+        if (itOld != mapBlockIndex.end()) {
+            if (state->pindexBestKnownBlock == NULL || itOld->second->GetBlockHeader() > state->pindexBestKnownBlock->GetBlockHeader())
                 state->pindexBestKnownBlock = itOld->second;
             state->hashLastUnknownBlock.SetNull();
         }
@@ -414,9 +402,9 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {
     ProcessBlockAvailability(nodeid);
 
     BlockMap::iterator it = mapBlockIndex.find(hash);
-    if (it != mapBlockIndex.end() && it->second->nChainWork > 0) {
+    if (it != mapBlockIndex.end()) {
         // An actually better block was announced.
-        if (state->pindexBestKnownBlock == NULL || it->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)
+        if (state->pindexBestKnownBlock == NULL || it->second->GetBlockHeader() > state->pindexBestKnownBlock->GetBlockHeader())
             state->pindexBestKnownBlock = it->second;
     } else {
         // An unknown block was announced; just assume that the latest one is the best one.
@@ -425,9 +413,9 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {
 }
 
 // Requires cs_main
-bool CanDirectFetch(const Consensus::Params &consensusParams)
+bool CanDirectFetch(CNode* pfrom)
 {
-    return chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;
+    return chainActive.Height() > pfrom->nStartingHeight - MAX_BLOCKS_IN_TRANSIT_PER_PEER;
 }
 
 // Requires cs_main
@@ -472,7 +460,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl
     // Make sure pindexBestKnownBlock is up to date, we'll need it.
     ProcessBlockAvailability(nodeid);
 
-    if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork) {
+    if (state->pindexBestKnownBlock == NULL || !(state->pindexBestKnownBlock->GetBlockHeader() > chainActive.Tip()->GetBlockHeader())) {
         // This peer has nothing interesting.
         return;
     }
@@ -946,14 +934,12 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)
         return state.DoS(100, false, REJECT_INVALID, "bad-txns-oversize");
 
     // Check for negative or overflow output values
-    CAmount nValueOut = 0;
+    CAmount nValueOut;
     BOOST_FOREACH(const CTxOut& txout, tx.vout)
     {
-        if (txout.nValue < 0)
+        if (txout.nValue.second < 0)
             return state.DoS(100, false, REJECT_INVALID, "bad-txns-vout-negative");
-        if (txout.nValue > MAX_MONEY)
-            return state.DoS(100, false, REJECT_INVALID, "bad-txns-vout-toolarge");
-        nValueOut += txout.nValue;
+        nValueOut[txout.nValue.first] += txout.nValue.second;
         if (!MoneyRange(nValueOut))
             return state.DoS(100, false, REJECT_INVALID, "bad-txns-txouttotal-toolarge");
     }
@@ -969,7 +955,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)
 
     if (tx.IsCoinBase())
     {
-        if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)
+        if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 1000)
             return state.DoS(100, false, REJECT_INVALID, "bad-cb-length");
     }
     else
@@ -1002,8 +988,8 @@ std::string FormatStateMessage(const CValidationState &state)
         state.GetRejectCode());
 }
 
-bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,
-                              bool* pfMissingInputs, bool fOverrideMempoolLimit, bool fRejectAbsurdFee,
+bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const CTransaction &tx,
+                              bool* pfMissingInputs, bool fOverrideMempoolLimit,
                               std::vector<uint256>& vHashTxnToUncache)
 {
     AssertLockHeld(cs_main);
@@ -1025,10 +1011,12 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
     // Don't relay version 2 transactions until CSV is active, and we can be
     // sure that such transactions will be mined (unless we're on
     // -testnet/-regtest).
+#if 0
     const CChainParams& chainparams = Params();
     if (fRequireStandard && tx.nVersion >= 2 && VersionBitsTipState(chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV) != THRESHOLD_ACTIVE) {
         return state.DoS(0, false, REJECT_NONSTANDARD, "premature-version2-tx");
     }
+#endif
 
     // Only accept nLockTime-using transactions that can be mined in the next
     // block; we don't want our mempool filled up with transactions that can't
@@ -1089,7 +1077,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
         CCoinsView dummy;
         CCoinsViewCache view(&dummy);
 
-        CAmount nValueIn = 0;
+        CAmount nValueIn;
         LockPoints lp;
         {
         LOCK(pool.cs);
@@ -1145,15 +1133,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
         unsigned int nSigOps = GetLegacySigOpCount(tx);
         nSigOps += GetP2SHSigOpCount(tx, view);
 
-        CAmount nValueOut = tx.GetValueOut();
-        CAmount nFees = nValueIn-nValueOut;
-        // nModifiedFees includes any fee deltas from PrioritiseTransaction
-        CAmount nModifiedFees = nFees;
-        double nPriorityDummy = 0;
-        pool.ApplyDeltas(hash, nPriorityDummy, nModifiedFees);
-
-        CAmount inChainInputValue;
-        double dPriority = view.GetPriority(tx, chainActive.Height(), inChainInputValue);
+        CAmount inChainInputValue = view.GetInChainInputValue(tx, chainActive.Height());
 
         // Keep track of transactions that spend a coinbase, which we re-scan
         // during reorgs to ensure COINBASE_MATURITY is still met.
@@ -1166,7 +1146,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
             }
         }
 
-        CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), pool.HasNoInputsOf(tx), inChainInputValue, fSpendsCoinbase, nSigOps, lp);
+        CTxMemPoolEntry entry(tx, GetTime(), chainActive.Height(), pool.HasNoInputsOf(tx), inChainInputValue, fSpendsCoinbase, nSigOps, lp);
         unsigned int nSize = entry.GetTxSize();
 
         // Check that the transaction doesn't have an excessive number of
@@ -1178,41 +1158,6 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
             return state.DoS(0, false, REJECT_NONSTANDARD, "bad-txns-too-many-sigops", false,
                 strprintf("%d", nSigOps));
 
-        CAmount mempoolRejectFee = pool.GetMinFee(GetArg("-maxmempool", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);
-        if (mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {
-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, "mempool min fee not met", false, strprintf("%d < %d", nFees, mempoolRejectFee));
-        } else if (GetBoolArg("-relaypriority", DEFAULT_RELAYPRIORITY) && nModifiedFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(entry.GetPriority(chainActive.Height() + 1))) {
-            // Require that free transactions have sufficient priority to be mined in the next block.
-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, "insufficient priority");
-        }
-
-        // Continuously rate-limit free (really, very-low-fee) transactions
-        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to
-        // be annoying or make others' transactions take longer to confirm.
-        if (fLimitFree && nModifiedFees < ::minRelayTxFee.GetFee(nSize))
-        {
-            static CCriticalSection csFreeLimiter;
-            static double dFreeCount;
-            static int64_t nLastTime;
-            int64_t nNow = GetTime();
-
-            LOCK(csFreeLimiter);
-
-            // Use an exponentially decaying ~10-minute window:
-            dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));
-            nLastTime = nNow;
-            // -limitfreerelay unit is thousand-bytes-per-minute
-            // At default rate it would take over a month to fill 1GB
-            if (dFreeCount >= GetArg("-limitfreerelay", DEFAULT_LIMITFREERELAY) * 10 * 1000)
-                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, "rate limited free transaction");
-            LogPrint("mempool", "Rate limit dFreeCount: %g => %g\n", dFreeCount, dFreeCount+nSize);
-            dFreeCount += nSize;
-        }
-
-        if (fRejectAbsurdFee && nFees > ::minRelayTxFee.GetFee(nSize) * 10000)
-            return state.Invalid(false,
-                REJECT_HIGHFEE, "absurdly-high-fee",
-                strprintf("%d > %d", nFees, ::minRelayTxFee.GetFee(nSize) * 10000));
 
         // Calculate in-mempool ancestors, up to a limit.
         CTxMemPool::setEntries setAncestors;
@@ -1243,7 +1188,6 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
 
         // Check if it's economically rational to mine this transaction rather
         // than the ones it replaces.
-        CAmount nConflictingFees = 0;
         size_t nConflictingSize = 0;
         uint64_t nConflictingCount = 0;
         CTxMemPool::setEntries allConflicting;
@@ -1254,7 +1198,6 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
         LOCK(pool.cs);
         if (setConflicts.size())
         {
-            CFeeRate newFeeRate(nModifiedFees, nSize);
             set<uint256> setConflictsParents;
             const int maxDescendantsToVisit = 100;
             CTxMemPool::setEntries setIterConflicting;
@@ -1281,33 +1224,6 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
                             REJECT_NONSTANDARD, "too many potential replacements");
                 }
 
-                // Don't allow the replacement to reduce the feerate of the
-                // mempool.
-                //
-                // We usually don't want to accept replacements with lower
-                // feerates than what they replaced as that would lower the
-                // feerate of the next block. Requiring that the feerate always
-                // be increased is also an easy-to-reason about way to prevent
-                // DoS attacks via replacements.
-                //
-                // The mining code doesn't (currently) take children into
-                // account (CPFP) so we only consider the feerates of
-                // transactions being directly replaced, not their indirect
-                // descendants. While that does mean high feerate children are
-                // ignored when deciding whether or not to replace, we do
-                // require the replacement to pay more overall fees too,
-                // mitigating most cases.
-                CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());
-                if (newFeeRate <= oldFeeRate)
-                {
-                    return state.DoS(0,
-                            error("AcceptToMemoryPool: rejecting replacement %s; new feerate %s <= old feerate %s",
-                                  hash.ToString(),
-                                  newFeeRate.ToString(),
-                                  oldFeeRate.ToString()),
-                            REJECT_INSUFFICIENTFEE, "insufficient fee");
-                }
-
                 BOOST_FOREACH(const CTxIn &txin, mi->GetTx().vin)
                 {
                     setConflictsParents.insert(txin.prevout.hash);
@@ -1325,7 +1241,6 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
                     pool.CalculateDescendants(it, allConflicting);
                 }
                 BOOST_FOREACH(CTxMemPool::txiter it, allConflicting) {
-                    nConflictingFees += it->GetModifiedFee();
                     nConflictingSize += it->GetTxSize();
                 }
             } else {
@@ -1355,33 +1270,16 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
                 }
             }
 
-            // The replacement must pay greater fees than the transactions it
-            // replaces - if we did the bandwidth used by those conflicting
-            // transactions would not be paid for.
-            if (nModifiedFees < nConflictingFees)
-            {
-                return state.DoS(0, error("AcceptToMemoryPool: rejecting replacement %s, less fees than conflicting txs; %s < %s",
-                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)),
-                                 REJECT_INSUFFICIENTFEE, "insufficient fee");
-            }
-
-            // Finally in addition to paying more fees than the conflicts the
-            // new transaction must pay for its own bandwidth.
-            CAmount nDeltaFees = nModifiedFees - nConflictingFees;
-            if (nDeltaFees < ::minRelayTxFee.GetFee(nSize))
-            {
-                return state.DoS(0,
-                        error("AcceptToMemoryPool: rejecting replacement %s, not enough additional fees to relay; %s < %s",
-                              hash.ToString(),
-                              FormatMoney(nDeltaFees),
-                              FormatMoney(::minRelayTxFee.GetFee(nSize))),
-                        REJECT_INSUFFICIENTFEE, "insufficient fee");
-            }
         }
 
+        // Pay to self is not allowed
+        if (IsPayToSelfTx(tx, view))
+            return error("%s(): CheckEnds on %s failed, pay-self-transaction", __func__, tx.GetHash().ToString());
+
+
         // Check against previous transactions
         // This is done last to help prevent CPU exhaustion denial-of-service attacks.
-        if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))
+        if (!CheckEnds(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))
             return false;
 
         // Check again against just the consensus-critical mandatory script
@@ -1393,7 +1291,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
         // There is a similar check in CreateNewBlock() to prevent creating
         // invalid blocks, however allowing such transactions into the mempool
         // can be exploited as a DoS attack.
-        if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true))
+        if (!CheckEnds(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true))
         {
             return error("%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s, %s",
                 __func__, hash.ToString(), FormatStateMessage(state));
@@ -1402,10 +1300,9 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
         // Remove conflicting transactions from the mempool
         BOOST_FOREACH(const CTxMemPool::txiter it, allConflicting)
         {
-            LogPrint("mempool", "replacing tx %s with %s for %s BTC additional fees, %d delta bytes\n",
+            LogPrint("mempool", "replacing tx %s with %s for %d delta bytes\n",
                     it->GetTx().GetHash().ToString(),
                     hash.ToString(),
-                    FormatMoney(nModifiedFees - nConflictingFees),
                     (int)nSize - (int)nConflictingSize);
         }
         pool.RemoveStaged(allConflicting);
@@ -1426,11 +1323,11 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C
     return true;
 }
 
-bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,
-                        bool* pfMissingInputs, bool fOverrideMempoolLimit, bool fRejectAbsurdFee)
+bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx,
+                        bool* pfMissingInputs, bool fOverrideMempoolLimit)
 {
     std::vector<uint256> vHashTxToUncache;
-    bool res = AcceptToMemoryPoolWorker(pool, state, tx, fLimitFree, pfMissingInputs, fOverrideMempoolLimit, fRejectAbsurdFee, vHashTxToUncache);
+    bool res = AcceptToMemoryPoolWorker(pool, state, tx, pfMissingInputs, fOverrideMempoolLimit, vHashTxToUncache);
     if (!res) {
         BOOST_FOREACH(const uint256& hashTx, vHashTxToUncache)
             pcoinsTip->Uncache(hashTx);
@@ -1548,8 +1445,8 @@ bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos, const Consensus:
     }
 
     // Check the header
-    if (!CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))
-        return error("ReadBlockFromDisk: Errors in block header at %s", pos.ToString());
+    //if (!CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))
+    //    return error("ReadBlockFromDisk: Errors in block header at %s", pos.ToString());
 
     return true;
 }
@@ -1564,32 +1461,20 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus
     return true;
 }
 
-CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)
-{
-    int halvings = nHeight / consensusParams.nSubsidyHalvingInterval;
-    // Force block reward to zero when right shift is undefined.
-    if (halvings >= 64)
-        return 0;
-
-    CAmount nSubsidy = 50 * COIN;
-    // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.
-    nSubsidy >>= halvings;
-    return nSubsidy;
-}
-
 bool IsInitialBlockDownload()
 {
-    const CChainParams& chainParams = Params();
+    // const CChainParams& chainParams = Params();
     LOCK(cs_main);
     if (fImporting || fReindex)
         return true;
-    if (fCheckpointsEnabled && chainActive.Height() < Checkpoints::GetTotalBlocksEstimate(chainParams.Checkpoints()))
-        return true;
+    // if (fCheckpointsEnabled && chainActive.Height() < Checkpoints::GetTotalBlocksEstimate(chainParams.Checkpoints()))
+    //     return true;
     static bool lockIBDState = false;
     if (lockIBDState)
         return false;
-    bool state = (chainActive.Height() < pindexBestHeader->nHeight - 24 * 6 ||
-            pindexBestHeader->GetBlockTime() < GetTime() - chainParams.MaxTipAge());
+    bool state = chainActive.Height() < pindexBestHeader->nHeight - 24 * 6;
+    //bool state = (chainActive.Height() < pindexBestHeader->nHeight - 24 * 6 ||
+    //        pindexBestHeader->GetBlockTime() < GetTime() - chainParams.MaxTipAge());
     if (!state)
         lockIBDState = true;
     return state;
@@ -1597,8 +1482,8 @@ bool IsInitialBlockDownload()
 
 bool fLargeWorkForkFound = false;
 bool fLargeWorkInvalidChainFound = false;
-CBlockIndex *pindexBestForkTip = NULL, *pindexBestForkBase = NULL;
-
+// CBlockIndex *pindexBestForkTip = NULL, *pindexBestForkBase = NULL;
+#if 0
 void CheckForkWarningConditions()
 {
     AssertLockHeld(cs_main);
@@ -1663,7 +1548,7 @@ void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)
     // We define it this way because it allows us to only store the highest fork tip (+ base) which meets
     // the 7-block condition and from this always have the most-likely-to-cause-warning fork
     if (pfork && (!pindexBestForkTip || (pindexBestForkTip && pindexNewForkTip->nHeight > pindexBestForkTip->nHeight)) &&
-            pindexNewForkTip->nChainWork - pfork->nChainWork > (GetBlockProof(*pfork) * 7) &&
+            pindexNewForkTip->nChainStakeSeconds - pfork->nChainStakeSeconds > 1*1000*1000*60*60*24 &&
             chainActive.Height() - pindexNewForkTip->nHeight < 72)
     {
         pindexBestForkTip = pindexNewForkTip;
@@ -1672,6 +1557,7 @@ void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)
 
     CheckForkWarningConditions();
 }
+#endif
 
 // Requires cs_main.
 void Misbehaving(NodeId pnode, int howmuch)
@@ -1695,19 +1581,19 @@ void Misbehaving(NodeId pnode, int howmuch)
 
 void static InvalidChainFound(CBlockIndex* pindexNew)
 {
-    if (!pindexBestInvalid || pindexNew->nChainWork > pindexBestInvalid->nChainWork)
+    if (!pindexBestInvalid || pindexNew->GetBlockHeader() > pindexBestInvalid->GetBlockHeader())
         pindexBestInvalid = pindexNew;
 
-    LogPrintf("%s: invalid block=%s  height=%d  log2_work=%.8g  date=%s\n", __func__,
+    LogPrintf("%s: invalid block=%s  height=%d root height = %d operator height = %d total stake seconds = %d  date=%s\n", __func__,
       pindexNew->GetBlockHash().ToString(), pindexNew->nHeight,
-      log(pindexNew->nChainWork.getdouble())/log(2.0), DateTimeStrFormat("%Y-%m-%d %H:%M:%S",
+      pindexNew->nRootHeight, pindexNew->nOperatorHeight, pindexNew->nChainStakeSeconds, DateTimeStrFormat("%Y-%m-%d %H:%M:%S",
       pindexNew->GetBlockTime()));
     CBlockIndex *tip = chainActive.Tip();
     assert (tip);
-    LogPrintf("%s:  current best=%s  height=%d  log2_work=%.8g  date=%s\n", __func__,
-      tip->GetBlockHash().ToString(), chainActive.Height(), log(tip->nChainWork.getdouble())/log(2.0),
+    LogPrintf("%s:  current best=%s  height=%d root height = %d operator height = %d total stake seconds = %d  date=%s\n", __func__,
+      tip->GetBlockHash().ToString(), chainActive.Height(), tip->nRootHeight, tip->nOperatorHeight, tip->nChainStakeSeconds, 
       DateTimeStrFormat("%Y-%m-%d %H:%M:%S", tip->GetBlockTime()));
-    CheckForkWarningConditions();
+    // CheckForkWarningConditions();
 }
 
 void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {
@@ -1793,8 +1679,8 @@ bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoins
         if (!inputs.HaveInputs(tx))
             return state.Invalid(false, 0, "", "Inputs unavailable");
 
-        CAmount nValueIn = 0;
-        CAmount nFees = 0;
+        CAmount nValueIn;
+        CValue cval;
         for (unsigned int i = 0; i < tx.vin.size(); i++)
         {
             const COutPoint &prevout = tx.vin[i].prevout;
@@ -1810,28 +1696,86 @@ bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoins
             }
 
             // Check for negative or overflow input values
-            nValueIn += coins->vout[prevout.n].nValue;
-            if (!MoneyRange(coins->vout[prevout.n].nValue) || !MoneyRange(nValueIn))
+            cval = coins->vout[prevout.n].nValue;
+            nValueIn[cval.first] += cval.second;
+            if (!MoneyRange(cval) || !MoneyRange(nValueIn))
                 return state.DoS(100, false, REJECT_INVALID, "bad-txns-inputvalues-outofrange");
 
         }
 
-        if (nValueIn < tx.GetValueOut())
+        if (nValueIn != tx.GetValueOut())
             return state.DoS(100, false, REJECT_INVALID, "bad-txns-in-belowout", false,
-                strprintf("value in (%s) < value out (%s)", FormatMoney(nValueIn), FormatMoney(tx.GetValueOut())));
-
-        // Tally transaction fees
-        CAmount nTxFee = nValueIn - tx.GetValueOut();
-        if (nTxFee < 0)
-            return state.DoS(100, false, REJECT_INVALID, "bad-txns-fee-negative");
-        nFees += nTxFee;
-        if (!MoneyRange(nFees))
-            return state.DoS(100, false, REJECT_INVALID, "bad-txns-fee-outofrange");
+                strprintf("value in (%s) < value out (%s)", FormatMoney(nValueIn[ABC_ID]), FormatMoney(tx.GetValueOut()[ABC_ID])));
+
     return true;
 }
 }// namespace Consensus
 
-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, std::vector<CScriptCheck> *pvChecks)
+namespace {
+class CScriptVisitor : public boost::static_visitor<uint160>
+{
+public:
+    uint160 operator()(const CNoDestination &dest) const {
+        return uint160();
+    }
+
+    uint160 operator()(const CKeyID &keyID) const {
+        return (uint160)keyID;
+    }
+
+    uint160 operator()(const CScriptID &scriptID) const {
+        return (uint160)scriptID;
+    }
+};
+
+}
+
+bool GetScriptId(const CScript& script, suint160& id) {
+    txnouttype stype;
+    std::vector<CTxDestination> vAddress;
+    int nRequiredRet;
+
+    if (!ExtractDestinations(script, stype, vAddress, nRequiredRet) || \
+        !(stype == TX_PUBKEYHASH || stype == TX_SCRIPTHASH) || nRequiredRet != 1)
+        return false;
+
+    id.first = (stype == TX_SCRIPTHASH);
+
+    id.second = boost::apply_visitor(CScriptVisitor(), vAddress[0]);
+
+    return true;
+}
+
+// The inputs and outputs must be from the same prime id
+bool IsPayToSelfTx(const CTransaction& tx, const CCoinsViewCache &inputs) {
+    suint160 primeID;
+
+    // Check the input id
+    for (unsigned int i = 0; i < tx.vin.size(); i++) {
+        suint160 id, primeid;
+        const COutPoint &prevout = tx.vin[i].prevout;
+        const CCoins* coins = inputs.AccessCoins(prevout.hash);
+        assert(coins);
+
+        if (!chainActive.IdAuthorized(coins->vout[prevout.n].scriptPubKey, id, primeid))
+            return false;
+        if (i > 0 && primeid != primeID) return false;
+        primeID = primeid;
+    }
+
+    // Check the output id: only pay to script hash or public key hash accepted
+    for(uint32_t i = 0; i < tx.vout.size(); i++) {
+        if (tx.vout[i].nValue.second == 0) continue;
+        suint160 id, primeid;
+        // Make sure id is authorized
+        if (!chainActive.IdAuthorized(tx.vout[i].scriptPubKey, id, primeid) || primeid != primeID) return false;
+    }
+
+    return true;
+
+}
+
+bool CheckEnds(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, std::vector<CScriptCheck> *pvChecks, CBlockIndex* pNewBlock)
 {
     if (!tx.IsCoinBase())
     {
@@ -1849,13 +1793,70 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi
         // before the last block chain checkpoint. This is safe because block merkle hashes are
         // still computed and checked, and any change will be caught at the next checkpoint.
         if (fScriptChecks) {
+
+            suint160 idParent = make_pair(false, uint160());
+
+            const CBlockIndex* pTip = mapBlockIndex.at(inputs.GetBestBlock());
+
+            if (pNewBlock) {
+                assert(pNewBlock->pprev == pTip);
+                if (pNewBlock->mIDSigCount == NULL) pNewBlock->mIDSigCount = new std::map<suint160, uint32_t>;
+            }
+
             for (unsigned int i = 0; i < tx.vin.size(); i++) {
                 const COutPoint &prevout = tx.vin[i].prevout;
-                const CCoins* coins = inputs.AccessCoins(prevout.hash);
-                assert(coins);
+                const CCoins* pcoins = inputs.AccessCoins(prevout.hash);
+                assert(pcoins);
+
+                CCoins coins = *pcoins;
+
+                suint160 id, primeid;
+                // Make sure id is authorized
+                if (!chainActive.IdAuthorized(coins.vout[prevout.n].scriptPubKey, id, primeid)) {
+                    CBlockIndex *bi = chainActive.Tip();
+                    const uint160* pIdWizard = NULL;
+
+                    // Iterate back through active chain for wizard id. Wizard transaction is rare, and thus no serious performance penalty.
+                    while (bi) {
+                        if (bi->nStatus & BLOCK_WIZARD) {
+                            pIdWizard = bi->idNextWizardScript;
+                            break;
+                        }
+                        bi = bi->pprev;
+                    }
+
+                    if (pIdWizard == NULL) return state.Invalid(false, REJECT_NONSTANDARD, "auth-id-revoked");
+
+                    coins.vout[prevout.n].scriptPubKey = GetScriptForDestination(CScriptID(*pIdWizard));
+                }
+                else {
+
+                    if (i == 0) {
+                        opcodetype opcode;
+                        vector<unsigned char> vch;
+                        CScript script = tx.vin[0].scriptSig;
+                        CScript::const_iterator pc = script.begin();
+
+                        // Pay to public key hash: The signature hash type must be SIGHASH_ALL
+                        // Pay to script: Skip the first unused value per bitcoin OP_CHECKMULTISIG opcode protocol, the first signature hash type must be SIGHASH_ALL
+                        if ((id.first == false && script.GetOp(pc, opcode, vch) && opcode <= OP_PUSHDATA4 && vch.size() > 0 && vch.back() == SIGHASH_ALL) || \
+                            (id.first == true && script.GetOp(pc, opcode, vch) && opcode <= OP_PUSHDATA4 && \
+                            script.GetOp(pc, opcode, vch) && opcode <= OP_PUSHDATA4 && vch.size() > 0 && vch.back() == SIGHASH_ALL))
+                            idParent = primeid;
+                    }
+
+                    if (pNewBlock) {
+                        pNewBlock->nStatus |= BLOCK_SIGNCOUNT;
+                        if (pNewBlock->mIDSigCount == NULL)
+                            pNewBlock->mIDSigCount = new std::map<suint160, uint32_t>;
+
+                        uint32_t& nSigCount = pNewBlock->mIDSigCount->operator[](id);
+                        nSigCount += 1;
+                    }
+                }
 
                 // Verify signature
-                CScriptCheck check(*coins, tx, i, flags, cacheStore);
+                CScriptCheck check(coins, tx, i, flags, cacheStore);
                 if (pvChecks) {
                     pvChecks->push_back(CScriptCheck());
                     check.swap(pvChecks->back());
@@ -1867,7 +1868,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi
                         // arguments; if so, don't trigger DoS protection to
                         // avoid splitting the network between upgraded and
                         // non-upgraded nodes.
-                        CScriptCheck check2(*coins, tx, i,
+                        CScriptCheck check2(coins, tx, i,
                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheStore);
                         if (check2())
                             return state.Invalid(false, REJECT_NONSTANDARD, strprintf("non-mandatory-script-verify-flag (%s)", ScriptErrorString(check.GetScriptError())));
@@ -1882,9 +1883,91 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi
                     return state.DoS(100,false, REJECT_INVALID, strprintf("mandatory-script-verify-flag-failed (%s)", ScriptErrorString(check.GetScriptError())));
                 }
             }
+
+            // Check the output id: only pay to script hash or public key hash accepted
+            for(uint32_t i = 0; i < tx.vout.size(); i++) {
+                if (tx.vout[i].nValue.second == 0) continue;
+                suint160 id, primeid;
+                // Make sure id is authorized
+                if (!chainActive.IdAuthorized(tx.vout[i].scriptPubKey, id, primeid)) return state.Invalid(false, REJECT_NONSTANDARD, "dest-id-auth-error");
+            }
+
+            // if (!pNewBlock) return true;
+
+            ////////////////////////////////////////
+            
+            set<suint160> sAuthID;
+
+            // Get Null data authorization information
+            const CTxOut& lastOut = tx.vout[tx.vout.size() - 1];
+            if (idParent == make_pair(false, uint160()) && lastOut.nValue.second == 0) {
+                return state.Invalid(false, REJECT_NONSTANDARD, "bad-user-auth-payload-nonstandard-tx");
+            }
+
+            if (idParent != make_pair(false, uint160()) && lastOut.nValue.second == 0) {
+                opcodetype opcode;
+                vector<unsigned char> vch;
+                CScript scriptAuth = lastOut.scriptPubKey ;
+                CScript::const_iterator pc = scriptAuth.begin();
+
+                // Get the chunk of id data
+                if (!scriptAuth.GetOp(pc, opcode, vch) || opcode != OP_RETURN)
+                    return state.Invalid(false, REJECT_NONSTANDARD, "bad-auth-payload-not-nulldata");
+
+                 while (scriptAuth.GetOp(pc, opcode, vch)) {
+                    if (vch.size() == 0) {
+                        return state.Invalid(false, REJECT_NONSTANDARD, "bad-auth-payload-format-no-data");
+                    }
+
+                    switch (vch[0]) {
+                        case USER_AUTH_TRANS_IDS:
+                            if ((vch.size() - 1) % 21) {
+                                return state.Invalid(false, REJECT_NONSTANDARD, "bad-auth-payload-bad-data-length");
+                            }
+                            for (unsigned int num = 0; num < (vch.size() - 1)/ 21; num++) {
+                                unsigned char addrtype = vch[1 + num * 21];
+
+                                if (addrtype != 0 && addrtype != 5)
+                                    return state.Invalid(false, REJECT_NONSTANDARD, "bad-auth-payload-address-type " + boost::to_string(addrtype));
+
+                                bool isScript = (addrtype == 5);
+                                suint160 tid = make_pair(isScript, uint160(vector<unsigned char>(vch.begin() + 1 + num * 21 + 1, vch.begin() + 1 + num * 21 + 1 + 20)));
+
+                                if (sAuthID.insert(tid).second == false)
+                                    return state.Invalid(false, REJECT_NONSTANDARD, "bad-auth-payload-duplicate-id" + boost::to_string(tid.first) + " " + tid.second.ToString());
+
+                            }
+                            break;
+                        default:
+                                return state.Invalid(false, REJECT_NONSTANDARD, "bad-auth-payload-unknown-authid");
+                    }
+                 }
+
+            }
+
+            // Add chained authorized ids to current block index
+            if (sAuthID.size() > 0) {
+
+                BOOST_FOREACH(const suint160& tid, sAuthID) {
+                    if (chainActive.TransIdPresent(tid))
+                        return state.Invalid(false, REJECT_NONSTANDARD, "bad-auth-payload-already-in " + boost::to_string(tid.first) + " " + tid.second.ToString());
+                }
+
+                if (pNewBlock) {
+                    pNewBlock->nStatus |= BLOCK_AUTHCHAIN;
+
+                    if (pNewBlock->mPlusTransID == NULL) pNewBlock->mPlusTransID = new std::map<suint160, std::set<suint160> >;
+
+                    std::set<suint160>& sTransID = pNewBlock->mPlusTransID->operator[](idParent);
+
+                    BOOST_FOREACH(const suint160& id, sAuthID)
+                        sTransID.insert(id);
+                }
+            }
+
         }
     }
-
+    
     return true;
 }
 
@@ -2006,6 +2089,8 @@ bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockI
 
     bool fClean = true;
 
+    bool bCoinBaseBlock = block.vtx[0].IsCoinBase();
+
     CBlockUndo blockUndo;
     CDiskBlockPos pos = pindex->GetUndoPos();
     if (pos.IsNull())
@@ -2013,7 +2098,7 @@ bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockI
     if (!UndoReadFromDisk(blockUndo, pos, pindex->pprev->GetBlockHash()))
         return error("DisconnectBlock(): failure reading undo data");
 
-    if (blockUndo.vtxundo.size() + 1 != block.vtx.size())
+    if (blockUndo.vtxundo.size() + (bCoinBaseBlock ? 1 : 0) != block.vtx.size())
         return error("DisconnectBlock(): block and undo data inconsistent");
 
     // undo transactions in reverse order
@@ -2041,8 +2126,8 @@ bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockI
         }
 
         // restore inputs
-        if (i > 0) { // not coinbases
-            const CTxUndo &txundo = blockUndo.vtxundo[i-1];
+        if (i > 0 || !bCoinBaseBlock) { // not coinbases
+            const CTxUndo &txundo = blockUndo.vtxundo[i-(bCoinBaseBlock ? 1 : 0)];
             if (txundo.vprevout.size() != tx.vin.size())
                 return error("DisconnectBlock(): transaction and undo data inconsistent");
             for (unsigned int j = tx.vin.size(); j-- > 0;) {
@@ -2102,6 +2187,7 @@ void ThreadScriptCheck() {
 // we're being fed a bad chain (blocks being generated much
 // too slowly or too quickly).
 //
+#if 0
 void PartitionCheck(bool (*initialDownloadCheck)(), CCriticalSection& cs, const CBlockIndex *const &bestHeader,
                     int64_t nPowTargetSpacing)
 {
@@ -2158,6 +2244,7 @@ void PartitionCheck(bool (*initialDownloadCheck)(), CCriticalSection& cs, const
         lastAlertTime = now;
     }
 }
+#endif
 
 // Protected by cs_main
 static VersionBitsCache versionbitscache;
@@ -2220,92 +2307,69 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin
     int64_t nTimeStart = GetTimeMicros();
 
     // Check it again in case a previous version let a bad block in
-    if (!CheckBlock(block, state, !fJustCheck, !fJustCheck))
+    if (!CheckBlock(block, state, !fJustCheck))
         return false;
 
     // verify that the view's current state corresponds to the previous block
     uint256 hashPrevBlock = pindex->pprev == NULL ? uint256() : pindex->pprev->GetBlockHash();
     assert(hashPrevBlock == view.GetBestBlock());
 
+    CBlockIndex *tip = chainActive.Tip();
+
+    uint256 hashTip = (tip != NULL) ? tip->GetBlockHash(): uint256();
+
+    assert(hashPrevBlock == hashTip);
+
     // Special case for the genesis block, skipping connection of its transactions
     // (its coinbase is unspendable)
+    const uint160 *idRootScript = NULL;
+    const uint160 *idOperatorPubKey = NULL;
+
     if (block.GetHash() == chainparams.GetConsensus().hashGenesisBlock) {
-        if (!fJustCheck)
-            view.SetBestBlock(pindex->GetBlockHash());
-        return true;
+        idRootScript = &(chainparams.GetConsensus().idRootScript);
     }
-
-    bool fScriptChecks = true;
-    if (fCheckpointsEnabled) {
-        CBlockIndex *pindexLastCheckpoint = Checkpoints::GetLastCheckpoint(chainparams.Checkpoints());
-        if (pindexLastCheckpoint && pindexLastCheckpoint->GetAncestor(pindex->nHeight) == pindex) {
-            // This block is an ancestor of a checkpoint: disable script checks
-            fScriptChecks = false;
+    else {
+        idRootScript = chainActive[pindex->pprev->nRootHeight]->idNextRootScript;
+        int nOperatorHeight = pindex->pprev->nOperatorHeight;
+        int nRootHeight = pindex->pprev->nRootHeight;
+        while (nRootHeight > nOperatorHeight) {
+            if (chainActive[nRootHeight]->WithData(BLOCK_OPERATOR)) {
+                nOperatorHeight = nRootHeight;
+                break;
+            }
+            nRootHeight = chainActive[nRootHeight]->pprev->nRootHeight;
         }
+        idOperatorPubKey = chainActive[nOperatorHeight]->idNextOperatorPubKey;
     }
 
+    bool fScriptChecks = true;
+
     int64_t nTime1 = GetTimeMicros(); nTimeCheck += nTime1 - nTimeStart;
     LogPrint("bench", "    - Sanity checks: %.2fms [%.2fs]\n", 0.001 * (nTime1 - nTimeStart), nTimeCheck * 0.000001);
 
-    // Do not allow blocks that contain transactions which 'overwrite' older transactions,
-    // unless those are already completely spent.
-    // If such overwrites are allowed, coinbases and transactions depending upon those
-    // can be duplicated to remove the ability to spend the first instance -- even after
-    // being sent to another address.
-    // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.
-    // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool
-    // already refuses previously-known transaction ids entirely.
-    // This rule was originally applied to all blocks with a timestamp after March 15, 2012, 0:00 UTC.
-    // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the
-    // two in the chain that violate it. This prevents exploiting the issue against nodes during their
-    // initial block download.
-    bool fEnforceBIP30 = (!pindex->phashBlock) || // Enforce on CreateNewBlock invocations which don't have a hash.
-                          !((pindex->nHeight==91842 && pindex->GetBlockHash() == uint256S("0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec")) ||
-                           (pindex->nHeight==91880 && pindex->GetBlockHash() == uint256S("0x00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721")));
-
-    // Once BIP34 activated it was not possible to create new duplicate coinbases and thus other than starting
-    // with the 2 existing duplicate coinbase pairs, not possible to create overwriting txs.  But by the
-    // time BIP34 activated, in each of the existing pairs the duplicate coinbase had overwritten the first
-    // before the first had been spent.  Since those coinbases are sufficiently buried its no longer possible to create further
-    // duplicate transactions descending from the known pairs either.
-    // If we're on the known chain at height greater than where BIP34 activated, we can save the db accesses needed for the BIP30 check.
-    CBlockIndex *pindexBIP34height = pindex->pprev->GetAncestor(chainparams.GetConsensus().BIP34Height);
-    //Only continue to enforce if we're below BIP34 activation height or the block hash at that height doesn't correspond.
-    fEnforceBIP30 = fEnforceBIP30 && (!pindexBIP34height || !(pindexBIP34height->GetBlockHash() == chainparams.GetConsensus().BIP34Hash));
-
-    if (fEnforceBIP30) {
-        BOOST_FOREACH(const CTransaction& tx, block.vtx) {
-            const CCoins* coins = view.AccessCoins(tx.GetHash());
-            if (coins && !coins->IsPruned())
-                return state.DoS(100, error("ConnectBlock(): tried to overwrite transaction"),
-                                 REJECT_INVALID, "bad-txns-BIP30");
-        }
-    }
-
-    // BIP16 didn't become active until Apr 1 2012
-    int64_t nBIP16SwitchTime = 1333238400;
-    bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);
+    BOOST_FOREACH(const CTransaction& tx, block.vtx) {
+        const CCoins* coins = view.AccessCoins(tx.GetHash());
+        if (coins && !coins->IsPruned())
+            return state.DoS(100, error("ConnectBlock(): tried to overwrite transaction"),
+                             REJECT_INVALID, "bad-txns-BIP30");
+    }
+
+    bool fStrictPayToScriptHash = true;
 
     unsigned int flags = fStrictPayToScriptHash ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE;
 
     // Start enforcing the DERSIG (BIP66) rules, for block.nVersion=3 blocks,
     // when 75% of the network has upgraded:
-    if (block.nVersion >= 3 && IsSuperMajority(3, pindex->pprev, chainparams.GetConsensus().nMajorityEnforceBlockUpgrade, chainparams.GetConsensus())) {
-        flags |= SCRIPT_VERIFY_DERSIG;
-    }
+    flags |= SCRIPT_VERIFY_DERSIG;
 
-    // Start enforcing CHECKLOCKTIMEVERIFY, (BIP65) for block.nVersion=4
-    // blocks, when 75% of the network has upgraded:
-    if (block.nVersion >= 4 && IsSuperMajority(4, pindex->pprev, chainparams.GetConsensus().nMajorityEnforceBlockUpgrade, chainparams.GetConsensus())) {
-        flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;
-    }
+    flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;
 
     // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.
     int nLockTimeFlags = 0;
-    if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {
+    // if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {
         flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;
         nLockTimeFlags |= LOCKTIME_VERIFY_SEQUENCE;
-    }
+    // }
 
     int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;
     LogPrint("bench", "    - Fork checks: %.2fms [%.2fs]\n", 0.001 * (nTime2 - nTime1), nTimeForks * 0.000001);
@@ -2315,14 +2379,242 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin
     CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);
 
     std::vector<int> prevheights;
-    CAmount nFees = 0;
     int nInputs = 0;
     unsigned int nSigOps = 0;
     CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));
     std::vector<std::pair<uint256, CDiskTxPos> > vPos;
     vPos.reserve(block.vtx.size());
     blockundo.vtxundo.reserve(block.vtx.size() - 1);
-    for (unsigned int i = 0; i < block.vtx.size(); i++)
+
+    // Check priviledged transaction first
+    const CTransaction &tx = block.vtx[0];
+
+    CScript scriptCheck;
+
+    if (tx.IsCoinBase()) {
+        ScriptError error;
+        // Root is pay to script hash
+        scriptCheck = GetScriptForDestination(CScriptID(*idRootScript));
+        if (VerifyScript(tx.vin[0].scriptSig, scriptCheck, flags, CachingTransactionSignatureChecker(&tx, 0, false), &error)) {
+            if (pindex->nRootHeight != pindex->nHeight) goto priverror;
+            if (pindex->pprev && pindex->nOperatorHeight != pindex->pprev->nOperatorHeight) goto priverror;
+
+            pindex->SetType(BLOCK_ROOT);
+
+            // Check the issuer address
+            if (tx.vout[0].nValue.second > 0) {
+                suint160 id, primeid;
+
+                if (!chainActive.IdAuthorized(tx.vout[0].scriptPubKey, id, primeid))
+                    goto priverror;
+            }
+
+            opcodetype opcode;
+            vector<unsigned char> vch;
+
+            CScript scriptAuth = tx.vout[tx.vout.size() == 1 ? 0:1].scriptPubKey ;
+
+            CScript::const_iterator pc = scriptAuth.begin();
+            if (!scriptAuth.GetOp(pc, opcode, vch)) goto priverror; // skip OP_RETURN
+            if (!scriptAuth.GetOp(pc, opcode, vch) || vch.size() != 20) goto priverror;
+            pindex->idNextRootScript = new uint160(vch);
+
+            while (scriptAuth.GetOp(pc, opcode, vch)) {
+                size_t szData = vch.size();
+
+                if (szData == 0) goto priverror;
+                vector<unsigned char>::const_iterator it = vch.begin() + 1;
+                uint160 id;
+
+                szData -= 1;
+
+                switch (vch.at(0)) {
+                    case ROOT_ASSIGN_OPERATOR:
+                        if (szData != 20) goto priverror;
+
+                        pindex->nStatus |= BLOCK_OPERATOR;
+                        pindex->idNextOperatorPubKey = new uint160(vector<unsigned char>(it, it + 20));
+                        break;
+
+                    case ROOT_CREDITING:
+                        while (it != vch.end()) {
+                            if (it + *it + 1 > vch.end()) goto priverror;
+                            it += *it + 1;
+                        }
+                        break;
+                    case ROOT_ASSIGN_WIZARD:
+                        if (szData != 20) goto priverror;
+
+                        pindex->nStatus |= BLOCK_WIZARD;
+                        pindex->idNextWizardScript = new uint160(vector<unsigned char>(it, it + 20));
+                        break;
+                    default:
+                        goto priverror;
+                }
+            }
+        }
+        else {
+            // Operater is pay to public hash
+            scriptCheck = GetScriptForDestination(CKeyID(*idOperatorPubKey));
+            if (VerifyScript(tx.vin[0].scriptSig, scriptCheck, flags, CachingTransactionSignatureChecker(&tx, 0, false), &error)) {
+                if (tx.vout.size() != 1) goto priverror;
+                if (tx.vout[0].nValue.second > 0) goto priverror;
+
+                if (pindex->nRootHeight != pindex->pprev->nRootHeight) goto priverror;
+                if (pindex->nOperatorHeight != pindex->nHeight) goto priverror;
+
+                pindex->SetType(BLOCK_OP);
+
+                opcodetype opcode;
+                vector<unsigned char> vch;
+                CScript scriptAuth = tx.vout[tx.vout.size() == 1 ? 0:1].scriptPubKey ;
+
+                CScript::const_iterator pc = scriptAuth.begin();
+
+                if (!scriptAuth.GetOp(pc, opcode, vch)) goto priverror; // skip OP_RETURN
+                if (!scriptAuth.GetOp(pc, opcode, vch)) goto priverror;
+                if (vch.size() != 20) goto priverror;
+
+                pindex->idNextOperatorPubKey = new uint160(vch);
+
+                while (scriptAuth.GetOp(pc, opcode, vch)) {
+                    size_t szData = vch.size();
+
+                    if (szData == 0) goto priverror;
+                    vector<unsigned char>::const_iterator it = vch.begin() + 1;
+                    uint160 id;
+
+                    szData -= 1;
+
+                    switch (vch.at(0)) {
+                        case OP_AUTH_TRANS_IDS:
+                            if (szData == 0 || szData % 21) goto priverror;
+
+                            pindex->nStatus |= BLOCK_AUTH;
+
+                            pindex->sPlusPrimeID = new std::set<suint160>;
+
+                            for(uint32_t num = 0; num < szData/21; num++) {
+                                unsigned char addrtype = it[num * 21];
+
+                                bool isScript = !(addrtype == 0);
+
+                                id = uint160(vector<unsigned char>(it + num * 21 + 1, it + num * 21 + 1 + 20));
+                                // Avoid authorizing a zero id
+                                if (id == uint160()) goto priverror;
+                                // Avoid authorizing a present id
+                                // Top level transactor id chains to zero
+                                if (chainActive.PrimeIdPresent(make_pair(isScript, id))) goto priverror;
+                                pindex->sPlusPrimeID->insert(make_pair(isScript, id));
+                            }
+                            break;
+                        case OP_DEAUTH_TRANS_IDS:
+                            if (szData == 0 || szData % 21) goto priverror;
+
+                            pindex->nStatus |= BLOCK_DEAUTH;
+
+                            pindex->sMinusPrimeID = new std::set<suint160>;
+
+                            for(uint32_t num = 0; num < szData/21; num++) {
+                                unsigned char addrtype = it[num * 21];
+
+                                bool isScript = !(addrtype == 0);
+
+                                id = uint160(vector<unsigned char>(it + num * 21 + 1, it + num * 21 + 1 + 20));
+                                if (id == uint160()) goto priverror;
+                                if (!chainActive.PrimeIdPresent(make_pair(isScript, id))) goto priverror;
+                                pindex->sMinusPrimeID->insert(make_pair(isScript, id));
+                            }
+                            break;
+                        case OP_CURVE_DECAYING:
+                            if (szData == 0 || szData % 8) goto priverror;
+
+                            pindex->nStatus |= BLOCK_CURVE;
+
+                            pindex->mTimeDecaying = new std::map<uint32_t, uint32_t>;
+
+                            for(uint32_t num = 0; num < szData/8; num++) {
+                                uint32_t index = 0, value = 0;
+                                for(int i = 0; i < 4; i++) {
+                                    index <<= 8; index += *it;
+                                    value <<= 8; value += *(it + 4);
+                                    it++;
+                                }
+                                pindex->mTimeDecaying->insert(std::make_pair(index, value));
+                            }
+
+                            break;
+                        default:
+                            goto priverror;
+                    }
+                }
+
+            }
+            else goto priverror;
+        }
+    }
+    else {
+        // Check the root and operator heights
+        if (pindex->nRootHeight != pindex->pprev->nRootHeight) goto priverror;
+        if (pindex->nOperatorHeight != pindex->pprev->nOperatorHeight) goto priverror;
+
+        pindex->SetType(BLOCK_POS);
+        // Get the public key script for input 0 to check block signature
+        int64_t totalCoinSeconds = 0;
+        for (uint32_t i = 0; i < tx.vin.size(); i++) {
+            const COutPoint &prevout = tx.vin[i].prevout;
+            const CCoins* coins = view.AccessCoins(prevout.hash);
+            const CTxOut& out = coins->vout[prevout.n];
+
+            assert(coins);
+
+            if (out.nValue.first != 0) goto priverror;
+
+            if (i == 0) scriptCheck = out.scriptPubKey;
+
+            int64_t coinSeconds = pindex->pprev->GetBlockTime() - pindex->GetAncestor(coins->nHeight)->GetBlockTime();
+            if (coinSeconds < 0) goto priverror;
+            if (coinSeconds == 0) coinSeconds = 1;
+            coinSeconds = chainActive.GetSecondsDecayed(coinSeconds);
+
+            totalCoinSeconds += coinSeconds * out.nValue.second;
+        }
+
+        // Check stake seconds
+        if (pindex->nChainStakeSeconds != pindex->pprev->nChainStakeSeconds + totalCoinSeconds) goto priverror;
+    }
+
+
+{
+    // Get out key or hash information from tx[0] to avoid redundance
+    vector<unsigned char> vSnip;
+
+    CScript scriptAuth = tx.vin[0].scriptSig;
+
+    scriptAuth >> vSnip;
+
+    CScript scriptSig = block.vchBlockSig;
+    // Concatenate to signature for verification
+    scriptSig << vSnip;
+
+    CMutableTransaction mtx(tx);
+
+    mtx.vout[0].scriptPubKey = CScript() << OP_RETURN << ToByteVector(block.GetHash());
+
+    CTransaction ctx = CTransaction(mtx);
+    ScriptError error;
+    if (!VerifyScript(scriptSig, scriptCheck, flags, CachingTransactionSignatureChecker(&ctx, 0, false), &error))
+        goto priverror;
+}
+
+goto nextstep;
+
+priverror:
+return state.DoS(100, error("ConnectBlock(): priviledged transaction invalid"),
+                 REJECT_INVALID, "bad-previledged-trans");
+nextstep:
+
+    for (uint32_t i = 0; i < block.vtx.size(); i++)
     {
         const CTransaction &tx = block.vtx[i];
 
@@ -2362,47 +2654,51 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin
                                      REJECT_INVALID, "bad-blk-sigops");
             }
 
-            nFees += view.GetValueIn(tx)-tx.GetValueOut();
+            if (i == 0 && !IsPayToSelfTx(tx, view))
+                return error("ConnectBlock(): CheckEnds on %s failed, invalid-POS-transaction",
+                    tx.GetHash().ToString());
+
+            if (i != 0 && IsPayToSelfTx(tx, view))
+                return error("ConnectBlock(): CheckEnds on %s failed, pay-self-transaction",
+                    tx.GetHash().ToString());
 
             std::vector<CScriptCheck> vChecks;
             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */
-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, nScriptCheckThreads ? &vChecks : NULL))
-                return error("ConnectBlock(): CheckInputs on %s failed with %s",
+            if (!CheckEnds(tx, state, view, fScriptChecks, flags, fCacheResults, nScriptCheckThreads ? &vChecks : NULL, pindex))
+                return error("ConnectBlock(): CheckEnds on %s failed with %s",
                     tx.GetHash().ToString(), FormatStateMessage(state));
             control.Add(vChecks);
         }
 
         CTxUndo undoDummy;
-        if (i > 0) {
+        
+        if (!tx.IsCoinBase()) {
             blockundo.vtxundo.push_back(CTxUndo());
         }
-        UpdateCoins(tx, state, view, i == 0 ? undoDummy : blockundo.vtxundo.back(), pindex->nHeight);
+        //UpdateCoins(tx, state, view, i == 0 ? undoDummy : blockundo.vtxundo.back(), pindex->nHeight);
+        UpdateCoins(tx, state, view, tx.IsCoinBase() ? undoDummy : blockundo.vtxundo.back(), pindex->nHeight);
 
         vPos.push_back(std::make_pair(tx.GetHash(), pos));
         pos.nTxOffset += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);
     }
+
     int64_t nTime3 = GetTimeMicros(); nTimeConnect += nTime3 - nTime2;
     LogPrint("bench", "      - Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin) [%.2fs]\n", (unsigned)block.vtx.size(), 0.001 * (nTime3 - nTime2), 0.001 * (nTime3 - nTime2) / block.vtx.size(), nInputs <= 1 ? 0 : 0.001 * (nTime3 - nTime2) / (nInputs-1), nTimeConnect * 0.000001);
 
-    CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());
-    if (block.vtx[0].GetValueOut() > blockReward)
-        return state.DoS(100,
-                         error("ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)",
-                               block.vtx[0].GetValueOut(), blockReward),
-                               REJECT_INVALID, "bad-cb-amount");
-
     if (!control.Wait())
         return state.DoS(100, false);
     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;
     LogPrint("bench", "    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs]\n", nInputs - 1, 0.001 * (nTime4 - nTime2), nInputs <= 1 ? 0 : 0.001 * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * 0.000001);
 
+    // Check block signature
+
     if (fJustCheck)
         return true;
 
     // Write undo information to disk
     if (pindex->GetUndoPos().IsNull() || !pindex->IsValid(BLOCK_VALID_SCRIPTS))
     {
-        if (pindex->GetUndoPos().IsNull()) {
+        if (pindex->GetUndoPos().IsNull() && pindex->pprev) {
             CDiskBlockPos pos;
             if (!FindUndoPos(state, pindex->nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))
                 return error("ConnectBlock(): FindUndoPos failed");
@@ -2569,9 +2865,8 @@ void static UpdateTip(CBlockIndex *pindexNew) {
     nTimeBestReceived = GetTime();
     mempool.AddTransactionsUpdated(1);
 
-    LogPrintf("%s: new best=%s  height=%d  log2_work=%.8g  tx=%lu  date=%s progress=%f  cache=%.1fMiB(%utx)\n", __func__,
-      chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)chainActive.Tip()->nChainTx,
-      DateTimeStrFormat("%Y-%m-%d %H:%M:%S", chainActive.Tip()->GetBlockTime()),
+    LogPrintf("%s: new best=%s  height=%d  nRootHeight=%d nOperatorHeight=%d nChainStakeSeconds=%d tx=%lu  date=%s progress=%f  cache=%.1fMiB(%utx)\n", __func__,
+      chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), chainActive.Tip()->nRootHeight, chainActive.Tip()->nOperatorHeight, chainActive.Tip()->nChainStakeSeconds, (unsigned long)chainActive.Tip()->nChainTx, DateTimeStrFormat("%Y-%m-%d %H:%M:%S", chainActive.Tip()->GetBlockTime()),
       Checkpoints::GuessVerificationProgress(chainParams.Checkpoints(), chainActive.Tip()), pcoinsTip->DynamicMemoryUsage() * (1.0 / (1<<20)), pcoinsTip->GetCacheSize());
 
     cvBlockChange.notify_all();
@@ -2641,15 +2936,17 @@ bool static DisconnectTip(CValidationState& state, const Consensus::Params& cons
         return false;
     // Resurrect mempool transactions from the disconnected block.
     std::vector<uint256> vHashUpdate;
+    bool bFirstTrans = true;
     BOOST_FOREACH(const CTransaction &tx, block.vtx) {
         // ignore validation errors in resurrected transactions
         list<CTransaction> removed;
         CValidationState stateDummy;
-        if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL, true)) {
+        if (bFirstTrans || !AcceptToMemoryPool(mempool, stateDummy, tx, NULL, true)) {
             mempool.remove(tx, removed, true);
         } else if (mempool.exists(tx.GetHash())) {
             vHashUpdate.push_back(tx.GetHash());
         }
+        bFirstTrans = false;
     }
     // AcceptToMemoryPool/addUnchecked all assume that new mempool entries have
     // no in-mempool children, which is generally not true when adding
@@ -2664,6 +2961,10 @@ bool static DisconnectTip(CValidationState& state, const Consensus::Params& cons
     BOOST_FOREACH(const CTransaction &tx, block.vtx) {
         SyncWithWallets(tx, NULL);
     }
+
+    if (!block.vtx[0].IsCoinBase()) {
+        GetMainSignals().ReverseTransForBooking(block);
+    }
     return true;
 }
 
@@ -2744,7 +3045,7 @@ static CBlockIndex* FindMostWorkChain() {
 
         // Find the best candidate header.
         {
-            std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexCandidates.rbegin();
+            std::set<CBlockIndex*, CBlockIndexWeightComparatpr>::reverse_iterator it = setBlockIndexCandidates.rbegin();
             if (it == setBlockIndexCandidates.rend())
                 return NULL;
             pindexNew = *it;
@@ -2765,7 +3066,7 @@ static CBlockIndex* FindMostWorkChain() {
             bool fMissingData = !(pindexTest->nStatus & BLOCK_HAVE_DATA);
             if (fFailedChain || fMissingData) {
                 // Candidate chain is not usable (either invalid or missing data)
-                if (fFailedChain && (pindexBestInvalid == NULL || pindexNew->nChainWork > pindexBestInvalid->nChainWork))
+                if (fFailedChain && (pindexBestInvalid == NULL || pindexNew->GetBlockHeader() > pindexBestInvalid->GetBlockHeader()))
                     pindexBestInvalid = pindexNew;
                 CBlockIndex *pindexFailed = pindexNew;
                 // Remove the entire chain from the set.
@@ -2796,7 +3097,7 @@ static CBlockIndex* FindMostWorkChain() {
 static void PruneBlockIndexCandidates() {
     // Note that we can't delete the current block itself, as we may need to return to it later in case a
     // reorganization to a better block fails.
-    std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator it = setBlockIndexCandidates.begin();
+    std::set<CBlockIndex*, CBlockIndexWeightComparatpr>::iterator it = setBlockIndexCandidates.begin();
     while (it != setBlockIndexCandidates.end() && setBlockIndexCandidates.value_comp()(*it, chainActive.Tip())) {
         setBlockIndexCandidates.erase(it++);
     }
@@ -2811,7 +3112,7 @@ static void PruneBlockIndexCandidates() {
 static bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const CBlock* pblock)
 {
     AssertLockHeld(cs_main);
-    bool fInvalidFound = false;
+    // bool fInvalidFound = false;
     const CBlockIndex *pindexOldTip = chainActive.Tip();
     const CBlockIndex *pindexFork = chainActive.FindFork(pindexMostWork);
 
@@ -2843,12 +3144,21 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c
         // Connect new blocks.
         BOOST_REVERSE_FOREACH(CBlockIndex *pindexConnect, vpindexToConnect) {
             if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : NULL)) {
+
+                if (pindexConnect->idNextRootScript != NULL) { delete pindexConnect->idNextRootScript; pindexConnect->idNextRootScript = NULL;}
+                if (pindexConnect->idNextOperatorPubKey != NULL) { delete pindexConnect->idNextOperatorPubKey; pindexConnect->idNextOperatorPubKey= NULL;}
+                if (pindexConnect->mIDSigCount != NULL) { delete pindexConnect->mIDSigCount; pindexConnect->mIDSigCount = NULL;}
+                if (pindexConnect->sPlusPrimeID != NULL) { delete pindexConnect->sPlusPrimeID; pindexConnect->sPlusPrimeID = NULL;}
+                if (pindexConnect->sMinusPrimeID != NULL) { delete pindexConnect->sMinusPrimeID; pindexConnect->sMinusPrimeID = NULL;}
+                if (pindexConnect->mPlusTransID != NULL) { delete pindexConnect->mPlusTransID; pindexConnect->mPlusTransID = NULL;}
+                if (pindexConnect->mTimeDecaying != NULL) { delete pindexConnect->mTimeDecaying; pindexConnect->mTimeDecaying = NULL;}
+
                 if (state.IsInvalid()) {
                     // The block violates a consensus rule.
                     if (!state.CorruptionPossible())
                         InvalidChainFound(vpindexToConnect.back());
                     state = CValidationState();
-                    fInvalidFound = true;
+                    // fInvalidFound = true;
                     fContinue = false;
                     break;
                 } else {
@@ -2857,7 +3167,7 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c
                 }
             } else {
                 PruneBlockIndexCandidates();
-                if (!pindexOldTip || chainActive.Tip()->nChainWork > pindexOldTip->nChainWork) {
+                if (!pindexOldTip || chainActive.Tip()->GetBlockHeader() > pindexOldTip->GetBlockHeader()) {
                     // We're in a better position than we were. Return temporarily to release the lock.
                     fContinue = false;
                     break;
@@ -2872,11 +3182,13 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c
     }
     mempool.check(pcoinsTip);
 
+#if 0
     // Callbacks/notifications for a new best chain.
     if (fInvalidFound)
         CheckForkWarningConditionsOnNewFork(vpindexToConnect.back());
     else
         CheckForkWarningConditions();
+#endif
 
     return true;
 }
@@ -3057,11 +3369,11 @@ CBlockIndex* AddToBlockIndex(const CBlockHeader& block)
     {
         pindexNew->pprev = (*miPrev).second;
         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;
+
         pindexNew->BuildSkip();
     }
-    pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + GetBlockProof(*pindexNew);
     pindexNew->RaiseValidity(BLOCK_VALID_TREE);
-    if (pindexBestHeader == NULL || pindexBestHeader->nChainWork < pindexNew->nChainWork)
+    if (pindexBestHeader == NULL || pindexNew->GetBlockHeader() > pindexBestHeader->GetBlockHeader())
         pindexBestHeader = pindexNew;
 
     setDirtyBlockIndex.insert(pindexNew);
@@ -3203,22 +3515,18 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne
     return true;
 }
 
-bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool fCheckPOW)
+bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state)
 {
-    // Check proof of work matches claimed amount
-    if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, Params().GetConsensus()))
-        return state.DoS(50, error("CheckBlockHeader(): proof of work failed"),
-                         REJECT_INVALID, "high-hash");
-
     // Check timestamp
-    if (block.GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)
+    // if (block.GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)
+    if (block.GetBlockTime() > GetAdjustedTime() + 2 * 60)
         return state.Invalid(error("CheckBlockHeader(): block timestamp too far in the future"),
                              REJECT_INVALID, "time-too-new");
 
     return true;
 }
 
-bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bool fCheckMerkleRoot)
+bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckMerkleRoot)
 {
     // These are checks that are independent of context.
 
@@ -3227,7 +3535,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo
 
     // Check that the header is valid (particularly PoW).  This is mostly
     // redundant with the call in AcceptBlockHeader.
-    if (!CheckBlockHeader(block, state, fCheckPOW))
+    if (!CheckBlockHeader(block, state))
         return false;
 
     // Check the merkle root.
@@ -3256,9 +3564,14 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo
                          REJECT_INVALID, "bad-blk-length");
 
     // First transaction must be coinbase, the rest must not be
-    if (block.vtx.empty() || !block.vtx[0].IsCoinBase())
+    // if (block.vtx.empty() || !block.vtx[0].IsCoinBase())
+    /* Delayed later to check booking information
+    if (!block.vtx[0].IsCoinBase()) {
         return state.DoS(100, error("CheckBlock(): first tx is not coinbase"),
                          REJECT_INVALID, "bad-cb-missing");
+    }
+    */
+
     for (unsigned int i = 1; i < block.vtx.size(); i++)
         if (block.vtx[i].IsCoinBase())
             return state.DoS(100, error("CheckBlock(): more than one coinbase"),
@@ -3280,7 +3593,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo
         return state.DoS(100, error("CheckBlock(): out-of-bounds SigOpCount"),
                          REJECT_INVALID, "bad-blk-sigops");
 
-    if (fCheckPOW && fCheckMerkleRoot)
+    if (fCheckMerkleRoot)
         block.fChecked = true;
 
     return true;
@@ -3304,9 +3617,9 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta
 {
     const Consensus::Params& consensusParams = Params().GetConsensus();
     // Check proof of work
-    if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))
-        return state.DoS(100, error("%s: incorrect proof of work", __func__),
-                         REJECT_INVALID, "bad-diffbits");
+    // if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))
+     //   return state.DoS(100, error("%s: incorrect proof of work", __func__),
+      //                   REJECT_INVALID, "bad-diffbits");
 
     // Check timestamp against prev
     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())
@@ -3334,13 +3647,13 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta
 bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIndex * const pindexPrev)
 {
     const int nHeight = pindexPrev == NULL ? 0 : pindexPrev->nHeight + 1;
-    const Consensus::Params& consensusParams = Params().GetConsensus();
+    // const Consensus::Params& consensusParams = Params().GetConsensus();
 
     // Start enforcing BIP113 (Median Time Past) using versionbits logic.
     int nLockTimeFlags = 0;
-    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {
+    // if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {
         nLockTimeFlags |= LOCKTIME_MEDIAN_TIME_PAST;
-    }
+    //}
 
     int64_t nLockTimeCutoff = (nLockTimeFlags & LOCKTIME_MEDIAN_TIME_PAST)
                               ? pindexPrev->GetMedianTimePast()
@@ -3353,9 +3666,10 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn
         }
     }
 
+#if 0
     // Enforce block.nVersion=2 rule that the coinbase starts with serialized block height
     // if 750 of the last 1,000 blocks are version 2 or greater (51/100 if testnet):
-    if (block.nVersion >= 2 && IsSuperMajority(2, pindexPrev, consensusParams.nMajorityEnforceBlockUpgrade, consensusParams))
+    // if (block.nVersion >= 2 && IsSuperMajority(2, pindexPrev, consensusParams.nMajorityEnforceBlockUpgrade, consensusParams))
     {
         CScript expect = CScript() << nHeight;
         if (block.vtx[0].vin[0].scriptSig.size() < expect.size() ||
@@ -3363,6 +3677,7 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn
             return state.DoS(100, error("%s: block height mismatch in coinbase", __func__), REJECT_INVALID, "bad-cb-height");
         }
     }
+#endif
 
     return true;
 }
@@ -3399,8 +3714,8 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state
             return state.DoS(100, error("%s: prev block invalid", __func__), REJECT_INVALID, "bad-prevblk");
 
         assert(pindexPrev);
-        if (fCheckpointsEnabled && !CheckIndexAgainstCheckpoint(pindexPrev, state, chainparams, hash))
-            return error("%s: CheckIndexAgainstCheckpoint(): %s", __func__, state.GetRejectReason().c_str());
+        // if (fCheckpointsEnabled && !CheckIndexAgainstCheckpoint(pindexPrev, state, chainparams, hash))
+        //    return error("%s: CheckIndexAgainstCheckpoint(): %s", __func__, state.GetRejectReason().c_str());
 
         if (!ContextualCheckBlockHeader(block, state, pindexPrev))
             return false;
@@ -3428,7 +3743,7 @@ static bool AcceptBlock(const CBlock& block, CValidationState& state, const CCha
     // process an unrequested block if it's new and has enough work to
     // advance our tip, and isn't too many blocks ahead.
     bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;
-    bool fHasMoreWork = (chainActive.Tip() ? pindex->nChainWork > chainActive.Tip()->nChainWork : true);
+    bool fHasMoreWork = (chainActive.Tip() ? pindex->GetBlockHeader() > chainActive.Tip()->GetBlockHeader() : true);
     // Blocks that are too out-of-order needlessly limit the effectiveness of
     // pruning, because pruning will not delete block files that contain any
     // blocks which are too close in height to the tip.  Apply this test
@@ -3521,8 +3836,10 @@ bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, c
     return true;
 }
 
-bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)
+bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckMerkleRoot)
 {
+    bool bRet;
+
     AssertLockHeld(cs_main);
     assert(pindexPrev && pindexPrev == chainActive.Tip());
     if (fCheckpointsEnabled && !CheckIndexAgainstCheckpoint(pindexPrev, state, chainparams, block.GetHash()))
@@ -3536,12 +3853,27 @@ bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams,
     // NOTE: CheckBlockHeader is called by CheckBlock
     if (!ContextualCheckBlockHeader(block, state, pindexPrev))
         return false;
-    if (!CheckBlock(block, state, fCheckPOW, fCheckMerkleRoot))
+    if (!CheckBlock(block, state, fCheckMerkleRoot))
         return false;
     if (!ContextualCheckBlock(block, state, pindexPrev))
         return false;
-    if (!ConnectBlock(block, state, &indexDummy, viewNew, true))
-        return false;
+    if (!ConnectBlock(block, state, &indexDummy, viewNew, true)) {
+        // return false;
+        bRet = false;
+    }
+    else
+        bRet = true;
+
+    if (indexDummy.idNextRootScript != NULL) { delete indexDummy.idNextRootScript; indexDummy.idNextRootScript = NULL;}
+    if (indexDummy.idNextOperatorPubKey != NULL) { delete indexDummy.idNextOperatorPubKey; indexDummy.idNextOperatorPubKey= NULL;}
+    if (indexDummy.mIDSigCount != NULL) { delete indexDummy.mIDSigCount; indexDummy.mIDSigCount = NULL;}
+    if (indexDummy.sPlusPrimeID != NULL) { delete indexDummy.sPlusPrimeID; indexDummy.sPlusPrimeID = NULL;}
+    if (indexDummy.sMinusPrimeID != NULL) { delete indexDummy.sMinusPrimeID; indexDummy.sMinusPrimeID = NULL;}
+    if (indexDummy.mPlusTransID != NULL) { delete indexDummy.mPlusTransID; indexDummy.mPlusTransID = NULL;}
+    if (indexDummy.mTimeDecaying != NULL) { delete indexDummy.mTimeDecaying; indexDummy.mTimeDecaying = NULL;}
+
+    if (bRet == false) return false;
+
     assert(state.IsValid());
 
     return true;
@@ -3728,18 +4060,18 @@ bool static LoadBlockIndexDB()
     boost::this_thread::interruption_point();
 
     // Calculate nChainWork
-    vector<pair<int, CBlockIndex*> > vSortedByHeight;
-    vSortedByHeight.reserve(mapBlockIndex.size());
+    vector<CBlockIndex*> vSortedByWeight;
+    vSortedByWeight.reserve(mapBlockIndex.size());
     BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)
     {
         CBlockIndex* pindex = item.second;
-        vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));
+        vSortedByWeight.push_back(pindex);
     }
-    sort(vSortedByHeight.begin(), vSortedByHeight.end());
-    BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)
+    sort(vSortedByWeight.begin(), vSortedByWeight.end(), CBlockIndexWeightComparatpr());
+
+    BOOST_FOREACH(CBlockIndex* pindex, vSortedByWeight)
     {
-        CBlockIndex* pindex = item.second;
-        pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + GetBlockProof(*pindex);
+        // pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + GetBlockProof(*pindex);
         // We can link the chain of blocks for which we've received transactions at some point.
         // Pruned nodes may have deleted the block.
         if (pindex->nTx > 0) {
@@ -3756,11 +4088,11 @@ bool static LoadBlockIndexDB()
         }
         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == NULL))
             setBlockIndexCandidates.insert(pindex);
-        if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))
+        if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->GetBlockHeader() > pindexBestInvalid->GetBlockHeader()))
             pindexBestInvalid = pindex;
         if (pindex->pprev)
             pindex->BuildSkip();
-        if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == NULL || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))
+        if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == NULL || pindex->GetBlockHeader() > pindexBestHeader->GetBlockHeader()))
             pindexBestHeader = pindex;
     }
 
@@ -3907,8 +4239,9 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,
             CBlock block;
             if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))
                 return error("VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s", pindex->nHeight, pindex->GetBlockHash().ToString());
-            if (!ConnectBlock(block, state, pindex, coins))
+            if (!ConnectBlock(block, state, pindex, coins)) {
                 return error("VerifyDB(): *** found unconnectable block at %d, hash=%s", pindex->nHeight, pindex->GetBlockHash().ToString());
+            }
         }
     }
 
@@ -4178,7 +4511,7 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)
         assert((pindexFirstNeverProcessed != NULL) == (pindex->nChainTx == 0)); // nChainTx != 0 is used to signal that all parent blocks have been processed (but may have been pruned).
         assert((pindexFirstNotTransactionsValid != NULL) == (pindex->nChainTx == 0));
         assert(pindex->nHeight == nHeight); // nHeight must be consistent.
-        assert(pindex->pprev == NULL || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.
+        // assert(pindex->pprev == NULL || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.
         assert(nHeight < 2 || (pindex->pskip && (pindex->pskip->nHeight < nHeight))); // The pskip pointer must point back for all but the first 2 blocks.
         assert(pindexFirstNotTreeValid == NULL); // All mapBlockIndex entries must at least be TREE valid
         if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TREE) assert(pindexFirstNotTreeValid == NULL); // TREE valid implies all parents are TREE valid
@@ -4188,7 +4521,7 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)
             // Checks for not-invalid blocks.
             assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0); // The failed mask cannot be set for blocks without invalid parents.
         }
-        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == NULL) {
+        if (!CBlockIndexWeightComparatpr()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == NULL) {
             if (pindexFirstInvalid == NULL) {
                 // If this block sorts at least as good as the current tip and
                 // is valid and we have all data for its parents, it must be in
@@ -4232,7 +4565,7 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)
             //    tip.
             // So if this block is itself better than chainActive.Tip() and it wasn't in
             // setBlockIndexCandidates, then it must be in mapBlocksUnlinked.
-            if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {
+            if (!CBlockIndexWeightComparatpr()(pindex, chainActive.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {
                 if (pindexFirstInvalid == NULL) {
                     assert(foundInUnlinked);
                 }
@@ -4426,8 +4759,8 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam
                         // chain if they are valid, and no more than a month older (both in time, and in
                         // best equivalent proof of work) than the best header chain we know about.
                         send = mi->second->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != NULL) &&
-                            (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() < nOneMonth) &&
-                            (GetBlockProofEquivalentTime(*pindexBestHeader, *mi->second, *pindexBestHeader, consensusParams) < nOneMonth);
+                            (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() < nOneMonth); // &&
+                            // (GetBlockProofEquivalentTime(*pindexBestHeader, *mi->second, *pindexBestHeader, consensusParams) < nOneMonth);
                         if (!send) {
                             LogPrintf("%s: ignoring request from peer=%i for old block that isn't in the main chain\n", __func__, pfrom->GetId());
                         }
@@ -4577,7 +4910,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
         int64_t nTime;
         CAddress addrMe;
         CAddress addrFrom;
-        uint64_t nNonce = 1;
+        uint256 nNonce = uint256S("0000000000000000000000000000000000000000000000000000000000000001");
         vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;
         if (pfrom->nVersion < MIN_PEER_PROTO_VERSION)
         {
@@ -4605,7 +4938,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
             pfrom->fRelayTxes = true;
 
         // Disconnect if we connected to ourself
-        if (nNonce == nLocalHostNonce && nNonce > 1)
+        if (nNonce == pfrom->nLocalHostNonce && uint256S("0000000000000000000000000000000000000000000000000000000000000001") < nNonce)
         {
             LogPrintf("connected to self at %s, disconnecting\n", pfrom->addr.ToString());
             pfrom->fDisconnect = true;
@@ -4628,7 +4961,26 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
         UpdatePreferredDownload(pfrom, State(pfrom->GetId()));
 
         // Change version
-        pfrom->PushMessage(NetMsgType::VERACK);
+        if (pfrom->fInbound)
+            pfrom->PushMessage(NetMsgType::VERACK);
+        else {
+            CKey key;
+            vector<unsigned char> vchSig;
+
+            if (!pwalletMain->GetKey(pwalletMain->vchDefaultKey.GetID(), key)) {
+                LogPrintf("Cannot get primary key for %s, disconnecting\n", pfrom->addr.ToString());
+                pfrom->fDisconnect = true;
+                return true;
+            }
+
+            if (!key.Sign(nNonce, vchSig)) {
+                LogPrintf("Primary key signing nonce failed for %s, disconnecting\n", pfrom->addr.ToString());
+                pfrom->fDisconnect = true;
+                return true;
+            }
+            pfrom->PushMessage(NetMsgType::VERACK, pwalletMain->vchDefaultKey, vchSig);
+        }
+
         pfrom->ssSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));
 
         if (!pfrom->fInbound)
@@ -4697,6 +5049,26 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
 
     else if (strCommand == NetMsgType::VERACK)
     {
+        if (pfrom->fInbound) {
+            CPubKey pk;
+            vector<unsigned char> vchSig;
+            vRecv >> pk >> vchSig;
+
+            if (chainActive.GetPrimeId(make_pair(false, pk.GetID())) == std::make_pair(false, uint160())) {
+                LogPrintf("peer=%d not authorized; disconnecting\n", pfrom->id);
+                pfrom->PushMessage(NetMsgType::REJECT, strCommand, REJECT_INVALID, string("Must be authorized before joining network"));
+                pfrom->fDisconnect = true;
+                return false;
+            }
+
+            if (!pk.Verify(pfrom->nLocalHostNonce, vchSig)) {
+                LogPrintf("peer=%d with bad signature; disconnecting\n", pfrom->id);
+                pfrom->PushMessage(NetMsgType::REJECT, strCommand, REJECT_INVALID, string("Must carry a valid signature in VERACK"));
+                pfrom->fDisconnect = true;
+                return false;
+            }
+        }
+
         pfrom->SetRecvVersion(min(pfrom->nVersion, PROTOCOL_VERSION));
 
         // Mark this node as currently connected, so we update its timestamp later.
@@ -4831,7 +5203,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
                     // not a direct successor.
                     pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash);
                     CNodeState *nodestate = State(pfrom->GetId());
-                    if (CanDirectFetch(chainparams.GetConsensus()) &&
+                    if (CanDirectFetch(pfrom) &&
                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {
                         vToFetch.push_back(inv);
                         // Mark block as in flight already, even though the actual "getdata" message only goes out
@@ -4909,7 +5281,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
             }
             // If pruning, don't inv blocks unless we have on disk and are likely to still have
             // for some reasonable time window (1 hour) that block relay might require.
-            const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / chainparams.GetConsensus().nPowTargetSpacing;
+            // const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / chainparams.GetConsensus().nPowTargetSpacing;
+            const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP;
             if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= chainActive.Tip()->nHeight - nPrunedBlocksLikelyToHave))
             {
                 LogPrint("net", " getblocks stopping, pruned or too old block at %d %s\n", pindex->nHeight, pindex->GetBlockHash().ToString());
@@ -5003,7 +5376,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
         pfrom->setAskFor.erase(inv.hash);
         mapAlreadyAskedFor.erase(inv);
 
-        if (!AlreadyHave(inv) && AcceptToMemoryPool(mempool, state, tx, true, &fMissingInputs))
+        if (!AlreadyHave(inv) && AcceptToMemoryPool(mempool, state, tx, &fMissingInputs))
         {
             mempool.check(pcoinsTip);
             RelayTransaction(tx);
@@ -5037,7 +5410,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
 
                     if (setMisbehaving.count(fromPeer))
                         continue;
-                    if (AcceptToMemoryPool(mempool, stateDummy, orphanTx, true, &fMissingInputs2))
+                    if (AcceptToMemoryPool(mempool, stateDummy, orphanTx, &fMissingInputs2))
                     {
                         LogPrint("mempool", "   accepted orphan tx %s\n", orphanHash.ToString());
                         RelayTransaction(orphanTx);
@@ -5166,11 +5539,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
             pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256());
         }
 
-        bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());
+        bool fCanDirectFetch = CanDirectFetch(pfrom);
         CNodeState *nodestate = State(pfrom->GetId());
         // If this set of headers is valid and ends in a block with at least as
         // much work as our tip, download as much as possible.
-        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {
+        // if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {
+        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && !(chainActive.Tip()->GetBlockHeader() > pindexLast->GetBlockHeader())) {
             vector<CBlockIndex *> vToFetch;
             CBlockIndex *pindexWalk = pindexLast;
             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.
@@ -5731,7 +6105,8 @@ bool SendMessages(CNode* pto)
         // transactions become unconfirmed and spams other nodes.
         if (!fReindex && !fImporting && !IsInitialBlockDownload())
         {
-            GetMainSignals().Broadcast(nTimeBestReceived);
+            // GetMainSignals().Broadcast(nTimeBestReceived);
+            GetMainSignals().Broadcast(GetTime());
         }
 
         //
@@ -5765,7 +6140,7 @@ bool SendMessages(CNode* pto)
                         fRevertToInv = true;
                         break;
                     }
-                    assert(pBestIndex == NULL || pindex->pprev == pBestIndex);
+                    // assert(pBestIndex == NULL || pindex->pprev == pBestIndex);
                     pBestIndex = pindex;
                     if (fFoundStartingHeader) {
                         // add this to the headers message
@@ -5896,7 +6271,7 @@ bool SendMessages(CNode* pto)
         if (!pto->fDisconnect && state.vBlocksInFlight.size() > 0) {
             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();
             int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);
-            if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {
+            if (nNow > state.nDownloadingSince + (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {
                 LogPrintf("Timeout downloading block %s from peer=%d, disconnecting\n", queuedBlock.hash.ToString(), pto->id);
                 pto->fDisconnect = true;
             }
diff --git a/src/main.h b/src/main.h
index 1a696dcd9..af3c72914 100644
--- a/src/main.h
+++ b/src/main.h
@@ -10,6 +10,7 @@
 #include "config/bitcoin-config.h"
 #endif
 
+#include "chainparams.h"
 #include "amount.h"
 #include "chain.h"
 #include "coins.h"
@@ -48,18 +49,16 @@ static const bool DEFAULT_ALERTS = false;
 static const bool DEFAULT_WHITELISTRELAY = true;
 /** Default for DEFAULT_WHITELISTFORCERELAY. */
 static const bool DEFAULT_WHITELISTFORCERELAY = true;
-/** Default for -minrelaytxfee, minimum relay fee for transactions */
-static const unsigned int DEFAULT_MIN_RELAY_TX_FEE = 1000;
 /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */
 static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;
 /** Default for -limitancestorcount, max number of in-mempool ancestors */
-static const unsigned int DEFAULT_ANCESTOR_LIMIT = 25;
+static const unsigned int DEFAULT_ANCESTOR_LIMIT = 250;
 /** Default for -limitancestorsize, maximum kilobytes of tx + all in-mempool ancestors */
-static const unsigned int DEFAULT_ANCESTOR_SIZE_LIMIT = 101;
+static const unsigned int DEFAULT_ANCESTOR_SIZE_LIMIT = 1010;
 /** Default for -limitdescendantcount, max number of in-mempool descendants */
-static const unsigned int DEFAULT_DESCENDANT_LIMIT = 25;
+static const unsigned int DEFAULT_DESCENDANT_LIMIT = 250;
 /** Default for -limitdescendantsize, maximum kilobytes of in-mempool descendants */
-static const unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT = 101;
+static const unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT = 1010;
 /** Default for -mempoolexpiry, expiration time for mempool transactions in hours */
 static const unsigned int DEFAULT_MEMPOOL_EXPIRY = 72;
 /** The maximum size of a blk?????.dat file (since 0.8) */
@@ -103,11 +102,8 @@ static const int64_t BLOCK_DOWNLOAD_TIMEOUT_BASE = 1000000;
 /** Additional block download timeout per parallel downloading peer (i.e. 5 min) */
 static const int64_t BLOCK_DOWNLOAD_TIMEOUT_PER_PEER = 500000;
 
-static const unsigned int DEFAULT_LIMITFREERELAY = 15;
-static const bool DEFAULT_RELAYPRIORITY = true;
-
 /** Default for -permitbaremultisig */
-static const bool DEFAULT_PERMIT_BAREMULTISIG = true;
+static const bool DEFAULT_PERMIT_BAREMULTISIG = false;
 static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20;
 static const bool DEFAULT_CHECKPOINTS_ENABLED = true;
 static const bool DEFAULT_TXINDEX = false;
@@ -145,7 +141,6 @@ extern unsigned int nBytesPerSigOp;
 extern bool fCheckBlockIndex;
 extern bool fCheckpointsEnabled;
 extern size_t nCoinCacheUsage;
-extern CFeeRate minRelayTxFee;
 extern bool fAlerts;
 extern bool fEnableReplacement;
 
@@ -223,7 +218,7 @@ bool SendMessages(CNode* pto);
 /** Run an instance of the script checking thread */
 void ThreadScriptCheck();
 /** Try to detect Partition (network isolation) attacks against us */
-void PartitionCheck(bool (*initialDownloadCheck)(), CCriticalSection& cs, const CBlockIndex *const &bestHeader, int64_t nPowTargetSpacing);
+//void PartitionCheck(bool (*initialDownloadCheck)(), CCriticalSection& cs, const CBlockIndex *const &bestHeader, int64_t nPowTargetSpacing);
 /** Check whether we are doing an initial block download (synchronizing from disk or network) */
 bool IsInitialBlockDownload();
 /** Format a string that describes several potential problems detected by the core.
@@ -238,7 +233,6 @@ std::string GetWarnings(const std::string& strFor);
 bool GetTransaction(const uint256 &hash, CTransaction &tx, const Consensus::Params& params, uint256 &hashBlock, bool fAllowSlow = false);
 /** Find the best known block, and make it the tip of the block chain */
 bool ActivateBestChain(CValidationState& state, const CChainParams& chainparams, const CBlock* pblock = NULL);
-CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams);
 
 /**
  * Prune block and undo files (blk???.dat and undo???.dat) so that the disk space used is less than a user-defined target.
@@ -274,8 +268,8 @@ void FlushStateToDisk();
 void PruneAndFlush();
 
 /** (try to) add transaction to memory pool **/
-bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,
-                        bool* pfMissingInputs, bool fOverrideMempoolLimit=false, bool fRejectAbsurdFee=false);
+bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx,
+                        bool* pfMissingInputs, bool fOverrideMempoolLimit=false);
 
 /** Convert CValidationState to a human-readable message for logging */
 std::string FormatStateMessage(const CValidationState &state);
@@ -332,14 +326,16 @@ unsigned int GetLegacySigOpCount(const CTransaction& tx);
  */
 unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& mapInputs);
 
+// Check whether the tx is pay-to-self
+bool IsPayToSelfTx(const CTransaction& tx, const CCoinsViewCache &inputs);
 
 /**
  * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)
  * This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it
  * instead of being performed inline.
  */
-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,
-                 unsigned int flags, bool cacheStore, std::vector<CScriptCheck> *pvChecks = NULL);
+bool CheckEnds(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,
+                 unsigned int flags, bool cacheStore, std::vector<CScriptCheck> *pvChecks = NULL, CBlockIndex* pNewBlock = NULL);
 
 /** Apply the effects of this transaction on the UTXO set represented by view */
 void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCache &inputs, int nHeight);
@@ -438,15 +434,15 @@ bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockI
 bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool fJustCheck = false);
 
 /** Context-independent validity checks */
-bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool fCheckPOW = true);
-bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW = true, bool fCheckMerkleRoot = true);
+bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state);
+bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckMerkleRoot = true);
 
 /** Context-dependent validity checks */
 bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, CBlockIndex *pindexPrev);
 bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIndex *pindexPrev);
 
 /** Check a block is completely valid from start to finish (only works on top of our current best block, with cs_main held) */
-bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW = true, bool fCheckMerkleRoot = true);
+bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckMerkleRoot = true);
 
 
 class CBlockFileInfo
@@ -546,11 +542,23 @@ int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Para
  * be sent over the P2P network.
  */
 static const unsigned int REJECT_INTERNAL = 0x100;
-/** Too high fee. Can not be triggered by P2P transactions */
-static const unsigned int REJECT_HIGHFEE = 0x100;
 /** Transaction is already known (either in mempool or blockchain) */
 static const unsigned int REJECT_ALREADY_KNOWN = 0x101;
 /** Transaction conflicts with a transaction already known */
 static const unsigned int REJECT_CONFLICT = 0x102;
 
+#if 0
+struct CCertificate {
+    enum cert_type {
+        CERT_ROOT = 0,
+        CERT_LINK,
+        CERT_TRANS,
+        CERT_ISSUE,
+    } type;
+    CPubKey pk;
+    std::vector<unsigned char> data;
+    CPubKey auth;
+};
+#endif
+
 #endif // BITCOIN_MAIN_H
diff --git a/src/miner.cpp b/src/miner.cpp
deleted file mode 100644
index d095d418f..000000000
--- a/src/miner.cpp
+++ /dev/null
@@ -1,521 +0,0 @@
-// Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-2015 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include "miner.h"
-
-#include "amount.h"
-#include "chain.h"
-#include "chainparams.h"
-#include "coins.h"
-#include "consensus/consensus.h"
-#include "consensus/merkle.h"
-#include "consensus/validation.h"
-#include "hash.h"
-#include "main.h"
-#include "net.h"
-#include "policy/policy.h"
-#include "pow.h"
-#include "primitives/transaction.h"
-#include "script/standard.h"
-#include "timedata.h"
-#include "txmempool.h"
-#include "util.h"
-#include "utilmoneystr.h"
-#include "validationinterface.h"
-
-#include <boost/thread.hpp>
-#include <boost/tuple/tuple.hpp>
-#include <queue>
-
-using namespace std;
-
-//////////////////////////////////////////////////////////////////////////////
-//
-// BitcoinMiner
-//
-
-//
-// Unconfirmed transactions in the memory pool often depend on other
-// transactions in the memory pool. When we select transactions from the
-// pool, we select by highest priority or fee rate, so we might consider
-// transactions that depend on transactions that aren't yet in the block.
-
-uint64_t nLastBlockTx = 0;
-uint64_t nLastBlockSize = 0;
-
-class ScoreCompare
-{
-public:
-    ScoreCompare() {}
-
-    bool operator()(const CTxMemPool::txiter a, const CTxMemPool::txiter b)
-    {
-        return CompareTxMemPoolEntryByScore()(*b,*a); // Convert to less than
-    }
-};
-
-int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)
-{
-    int64_t nOldTime = pblock->nTime;
-    int64_t nNewTime = std::max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());
-
-    if (nOldTime < nNewTime)
-        pblock->nTime = nNewTime;
-
-    // Updating time can change work required on testnet:
-    if (consensusParams.fPowAllowMinDifficultyBlocks)
-        pblock->nBits = GetNextWorkRequired(pindexPrev, pblock, consensusParams);
-
-    return nNewTime - nOldTime;
-}
-
-CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& scriptPubKeyIn)
-{
-    // Create new block
-    auto_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());
-    if(!pblocktemplate.get())
-        return NULL;
-    CBlock *pblock = &pblocktemplate->block; // pointer for convenience
-
-    // Create coinbase tx
-    CMutableTransaction txNew;
-    txNew.vin.resize(1);
-    txNew.vin[0].prevout.SetNull();
-    txNew.vout.resize(1);
-    txNew.vout[0].scriptPubKey = scriptPubKeyIn;
-
-    // Add dummy coinbase tx as first transaction
-    pblock->vtx.push_back(CTransaction());
-    pblocktemplate->vTxFees.push_back(-1); // updated at end
-    pblocktemplate->vTxSigOps.push_back(-1); // updated at end
-
-    // Largest block you're willing to create:
-    unsigned int nBlockMaxSize = GetArg("-blockmaxsize", DEFAULT_BLOCK_MAX_SIZE);
-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:
-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));
-
-    // How much of the block should be dedicated to high-priority transactions,
-    // included regardless of the fees they pay
-    unsigned int nBlockPrioritySize = GetArg("-blockprioritysize", DEFAULT_BLOCK_PRIORITY_SIZE);
-    nBlockPrioritySize = std::min(nBlockMaxSize, nBlockPrioritySize);
-
-    // Minimum block size you want to create; block will be filled with free transactions
-    // until there are no more or the block reaches this size:
-    unsigned int nBlockMinSize = GetArg("-blockminsize", DEFAULT_BLOCK_MIN_SIZE);
-    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);
-
-    // Collect memory pool transactions into the block
-    CTxMemPool::setEntries inBlock;
-    CTxMemPool::setEntries waitSet;
-
-    // This vector will be sorted into a priority queue:
-    vector<TxCoinAgePriority> vecPriority;
-    TxCoinAgePriorityCompare pricomparer;
-    std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash> waitPriMap;
-    typedef std::map<CTxMemPool::txiter, double, CTxMemPool::CompareIteratorByHash>::iterator waitPriIter;
-    double actualPriority = -1;
-
-    std::priority_queue<CTxMemPool::txiter, std::vector<CTxMemPool::txiter>, ScoreCompare> clearedTxs;
-    bool fPrintPriority = GetBoolArg("-printpriority", DEFAULT_PRINTPRIORITY);
-    uint64_t nBlockSize = 1000;
-    uint64_t nBlockTx = 0;
-    unsigned int nBlockSigOps = 100;
-    int lastFewTxs = 0;
-    CAmount nFees = 0;
-
-    {
-        LOCK2(cs_main, mempool.cs);
-        CBlockIndex* pindexPrev = chainActive.Tip();
-        const int nHeight = pindexPrev->nHeight + 1;
-        pblock->nTime = GetAdjustedTime();
-        const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();
-
-        pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());
-        // -regtest only: allow overriding block.nVersion with
-        // -blockversion=N to test forking scenarios
-        if (chainparams.MineBlocksOnDemand())
-            pblock->nVersion = GetArg("-blockversion", pblock->nVersion);
-
-        int64_t nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)
-                                ? nMedianTimePast
-                                : pblock->GetBlockTime();
-
-        bool fPriorityBlock = nBlockPrioritySize > 0;
-        if (fPriorityBlock) {
-            vecPriority.reserve(mempool.mapTx.size());
-            for (CTxMemPool::indexed_transaction_set::iterator mi = mempool.mapTx.begin();
-                 mi != mempool.mapTx.end(); ++mi)
-            {
-                double dPriority = mi->GetPriority(nHeight);
-                CAmount dummy;
-                mempool.ApplyDeltas(mi->GetTx().GetHash(), dPriority, dummy);
-                vecPriority.push_back(TxCoinAgePriority(dPriority, mi));
-            }
-            std::make_heap(vecPriority.begin(), vecPriority.end(), pricomparer);
-        }
-
-        CTxMemPool::indexed_transaction_set::nth_index<3>::type::iterator mi = mempool.mapTx.get<3>().begin();
-        CTxMemPool::txiter iter;
-
-        while (mi != mempool.mapTx.get<3>().end() || !clearedTxs.empty())
-        {
-            bool priorityTx = false;
-            if (fPriorityBlock && !vecPriority.empty()) { // add a tx from priority queue to fill the blockprioritysize
-                priorityTx = true;
-                iter = vecPriority.front().second;
-                actualPriority = vecPriority.front().first;
-                std::pop_heap(vecPriority.begin(), vecPriority.end(), pricomparer);
-                vecPriority.pop_back();
-            }
-            else if (clearedTxs.empty()) { // add tx with next highest score
-                iter = mempool.mapTx.project<0>(mi);
-                mi++;
-            }
-            else {  // try to add a previously postponed child tx
-                iter = clearedTxs.top();
-                clearedTxs.pop();
-            }
-
-            if (inBlock.count(iter))
-                continue; // could have been added to the priorityBlock
-
-            const CTransaction& tx = iter->GetTx();
-
-            bool fOrphan = false;
-            BOOST_FOREACH(CTxMemPool::txiter parent, mempool.GetMemPoolParents(iter))
-            {
-                if (!inBlock.count(parent)) {
-                    fOrphan = true;
-                    break;
-                }
-            }
-            if (fOrphan) {
-                if (priorityTx)
-                    waitPriMap.insert(std::make_pair(iter,actualPriority));
-                else
-                    waitSet.insert(iter);
-                continue;
-            }
-
-            unsigned int nTxSize = iter->GetTxSize();
-            if (fPriorityBlock &&
-                (nBlockSize + nTxSize >= nBlockPrioritySize || !AllowFree(actualPriority))) {
-                fPriorityBlock = false;
-                waitPriMap.clear();
-            }
-            if (!priorityTx &&
-                (iter->GetModifiedFee() < ::minRelayTxFee.GetFee(nTxSize) && nBlockSize >= nBlockMinSize)) {
-                break;
-            }
-            if (nBlockSize + nTxSize >= nBlockMaxSize) {
-                if (nBlockSize >  nBlockMaxSize - 100 || lastFewTxs > 50) {
-                    break;
-                }
-                // Once we're within 1000 bytes of a full block, only look at 50 more txs
-                // to try to fill the remaining space.
-                if (nBlockSize > nBlockMaxSize - 1000) {
-                    lastFewTxs++;
-                }
-                continue;
-            }
-
-            if (!IsFinalTx(tx, nHeight, nLockTimeCutoff))
-                continue;
-
-            unsigned int nTxSigOps = iter->GetSigOpCount();
-            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS) {
-                if (nBlockSigOps > MAX_BLOCK_SIGOPS - 2) {
-                    break;
-                }
-                continue;
-            }
-
-            CAmount nTxFees = iter->GetFee();
-            // Added
-            pblock->vtx.push_back(tx);
-            pblocktemplate->vTxFees.push_back(nTxFees);
-            pblocktemplate->vTxSigOps.push_back(nTxSigOps);
-            nBlockSize += nTxSize;
-            ++nBlockTx;
-            nBlockSigOps += nTxSigOps;
-            nFees += nTxFees;
-
-            if (fPrintPriority)
-            {
-                double dPriority = iter->GetPriority(nHeight);
-                CAmount dummy;
-                mempool.ApplyDeltas(tx.GetHash(), dPriority, dummy);
-                LogPrintf("priority %.1f fee %s txid %s\n",
-                          dPriority , CFeeRate(iter->GetModifiedFee(), nTxSize).ToString(), tx.GetHash().ToString());
-            }
-
-            inBlock.insert(iter);
-
-            // Add transactions that depend on this one to the priority queue
-            BOOST_FOREACH(CTxMemPool::txiter child, mempool.GetMemPoolChildren(iter))
-            {
-                if (fPriorityBlock) {
-                    waitPriIter wpiter = waitPriMap.find(child);
-                    if (wpiter != waitPriMap.end()) {
-                        vecPriority.push_back(TxCoinAgePriority(wpiter->second,child));
-                        std::push_heap(vecPriority.begin(), vecPriority.end(), pricomparer);
-                        waitPriMap.erase(wpiter);
-                    }
-                }
-                else {
-                    if (waitSet.count(child)) {
-                        clearedTxs.push(child);
-                        waitSet.erase(child);
-                    }
-                }
-            }
-        }
-        nLastBlockTx = nBlockTx;
-        nLastBlockSize = nBlockSize;
-        LogPrintf("CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\n", nBlockSize, nBlockTx, nFees, nBlockSigOps);
-
-        // Compute final coinbase transaction.
-        txNew.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());
-        txNew.vin[0].scriptSig = CScript() << nHeight << OP_0;
-        pblock->vtx[0] = txNew;
-        pblocktemplate->vTxFees[0] = -nFees;
-
-        // Fill in header
-        pblock->hashPrevBlock  = pindexPrev->GetBlockHash();
-        UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);
-        pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus());
-        pblock->nNonce         = 0;
-        pblocktemplate->vTxSigOps[0] = GetLegacySigOpCount(pblock->vtx[0]);
-
-        CValidationState state;
-        if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {
-            throw std::runtime_error(strprintf("%s: TestBlockValidity failed: %s", __func__, FormatStateMessage(state)));
-        }
-    }
-
-    return pblocktemplate.release();
-}
-
-void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned int& nExtraNonce)
-{
-    // Update nExtraNonce
-    static uint256 hashPrevBlock;
-    if (hashPrevBlock != pblock->hashPrevBlock)
-    {
-        nExtraNonce = 0;
-        hashPrevBlock = pblock->hashPrevBlock;
-    }
-    ++nExtraNonce;
-    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2
-    CMutableTransaction txCoinbase(pblock->vtx[0]);
-    txCoinbase.vin[0].scriptSig = (CScript() << nHeight << CScriptNum(nExtraNonce)) + COINBASE_FLAGS;
-    assert(txCoinbase.vin[0].scriptSig.size() <= 100);
-
-    pblock->vtx[0] = txCoinbase;
-    pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);
-}
-
-//////////////////////////////////////////////////////////////////////////////
-//
-// Internal miner
-//
-
-//
-// ScanHash scans nonces looking for a hash with at least some zero bits.
-// The nonce is usually preserved between calls, but periodically or if the
-// nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at
-// zero.
-//
-bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phash)
-{
-    // Write the first 76 bytes of the block header to a double-SHA256 state.
-    CHash256 hasher;
-    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
-    ss << *pblock;
-    assert(ss.size() == 80);
-    hasher.Write((unsigned char*)&ss[0], 76);
-
-    while (true) {
-        nNonce++;
-
-        // Write the last 4 bytes of the block header (the nonce) to a copy of
-        // the double-SHA256 state, and compute the result.
-        CHash256(hasher).Write((unsigned char*)&nNonce, 4).Finalize((unsigned char*)phash);
-
-        // Return the nonce if the hash has at least some zero bits,
-        // caller will check if it has enough to reach the target
-        if (((uint16_t*)phash)[15] == 0)
-            return true;
-
-        // If nothing found after trying for a while, return -1
-        if ((nNonce & 0xfff) == 0)
-            return false;
-    }
-}
-
-static bool ProcessBlockFound(const CBlock* pblock, const CChainParams& chainparams)
-{
-    LogPrintf("%s\n", pblock->ToString());
-    LogPrintf("generated %s\n", FormatMoney(pblock->vtx[0].vout[0].nValue));
-
-    // Found a solution
-    {
-        LOCK(cs_main);
-        if (pblock->hashPrevBlock != chainActive.Tip()->GetBlockHash())
-            return error("BitcoinMiner: generated block is stale");
-    }
-
-    // Inform about the new block
-    GetMainSignals().BlockFound(pblock->GetHash());
-
-    // Process this block the same as if we had received it from another node
-    CValidationState state;
-    if (!ProcessNewBlock(state, chainparams, NULL, pblock, true, NULL))
-        return error("BitcoinMiner: ProcessNewBlock, block not accepted");
-
-    return true;
-}
-
-void static BitcoinMiner(const CChainParams& chainparams)
-{
-    LogPrintf("BitcoinMiner started\n");
-    SetThreadPriority(THREAD_PRIORITY_LOWEST);
-    RenameThread("bitcoin-miner");
-
-    unsigned int nExtraNonce = 0;
-
-    boost::shared_ptr<CReserveScript> coinbaseScript;
-    GetMainSignals().ScriptForMining(coinbaseScript);
-
-    try {
-        // Throw an error if no script was provided.  This can happen
-        // due to some internal error but also if the keypool is empty.
-        // In the latter case, already the pointer is NULL.
-        if (!coinbaseScript || coinbaseScript->reserveScript.empty())
-            throw std::runtime_error("No coinbase script available (mining requires a wallet)");
-
-        while (true) {
-            if (chainparams.MiningRequiresPeers()) {
-                // Busy-wait for the network to come online so we don't waste time mining
-                // on an obsolete chain. In regtest mode we expect to fly solo.
-                do {
-                    bool fvNodesEmpty;
-                    {
-                        LOCK(cs_vNodes);
-                        fvNodesEmpty = vNodes.empty();
-                    }
-                    if (!fvNodesEmpty && !IsInitialBlockDownload())
-                        break;
-                    MilliSleep(1000);
-                } while (true);
-            }
-
-            //
-            // Create new block
-            //
-            unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();
-            CBlockIndex* pindexPrev = chainActive.Tip();
-
-            auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlock(chainparams, coinbaseScript->reserveScript));
-            if (!pblocktemplate.get())
-            {
-                LogPrintf("Error in BitcoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\n");
-                return;
-            }
-            CBlock *pblock = &pblocktemplate->block;
-            IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);
-
-            LogPrintf("Running BitcoinMiner with %u transactions in block (%u bytes)\n", pblock->vtx.size(),
-                ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));
-
-            //
-            // Search
-            //
-            int64_t nStart = GetTime();
-            arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);
-            uint256 hash;
-            uint32_t nNonce = 0;
-            while (true) {
-                // Check if something found
-                if (ScanHash(pblock, nNonce, &hash))
-                {
-                    if (UintToArith256(hash) <= hashTarget)
-                    {
-                        // Found a solution
-                        pblock->nNonce = nNonce;
-                        assert(hash == pblock->GetHash());
-
-                        SetThreadPriority(THREAD_PRIORITY_NORMAL);
-                        LogPrintf("BitcoinMiner:\n");
-                        LogPrintf("proof-of-work found  \n  hash: %s  \ntarget: %s\n", hash.GetHex(), hashTarget.GetHex());
-                        ProcessBlockFound(pblock, chainparams);
-                        SetThreadPriority(THREAD_PRIORITY_LOWEST);
-                        coinbaseScript->KeepScript();
-
-                        // In regression test mode, stop mining after a block is found.
-                        if (chainparams.MineBlocksOnDemand())
-                            throw boost::thread_interrupted();
-
-                        break;
-                    }
-                }
-
-                // Check for stop or if block needs to be rebuilt
-                boost::this_thread::interruption_point();
-                // Regtest mode doesn't require peers
-                if (vNodes.empty() && chainparams.MiningRequiresPeers())
-                    break;
-                if (nNonce >= 0xffff0000)
-                    break;
-                if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60)
-                    break;
-                if (pindexPrev != chainActive.Tip())
-                    break;
-
-                // Update nTime every few seconds
-                if (UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev) < 0)
-                    break; // Recreate the block if the clock has run backwards,
-                           // so that we can use the correct time.
-                if (chainparams.GetConsensus().fPowAllowMinDifficultyBlocks)
-                {
-                    // Changing pblock->nTime can change work required on testnet:
-                    hashTarget.SetCompact(pblock->nBits);
-                }
-            }
-        }
-    }
-    catch (const boost::thread_interrupted&)
-    {
-        LogPrintf("BitcoinMiner terminated\n");
-        throw;
-    }
-    catch (const std::runtime_error &e)
-    {
-        LogPrintf("BitcoinMiner runtime error: %s\n", e.what());
-        return;
-    }
-}
-
-void GenerateBitcoins(bool fGenerate, int nThreads, const CChainParams& chainparams)
-{
-    static boost::thread_group* minerThreads = NULL;
-
-    if (nThreads < 0)
-        nThreads = GetNumCores();
-
-    if (minerThreads != NULL)
-    {
-        minerThreads->interrupt_all();
-        delete minerThreads;
-        minerThreads = NULL;
-    }
-
-    if (nThreads == 0 || !fGenerate)
-        return;
-
-    minerThreads = new boost::thread_group();
-    for (int i = 0; i < nThreads; i++)
-        minerThreads->create_thread(boost::bind(&BitcoinMiner, boost::cref(chainparams)));
-}
diff --git a/src/net.cpp b/src/net.cpp
index 2f60cfa1c..2b8de97e3 100644
--- a/src/net.cpp
+++ b/src/net.cpp
@@ -80,7 +80,6 @@ map<CNetAddr, LocalServiceInfo> mapLocalHost;
 static bool vfReachable[NET_MAX] = {};
 static bool vfLimited[NET_MAX] = {};
 static CNode* pnodeLocalHost = NULL;
-uint64_t nLocalHostNonce = 0;
 static std::vector<ListenSocket> vhListenSocket;
 CAddrMan addrman;
 int nMaxConnections = DEFAULT_MAX_PEER_CONNECTIONS;
@@ -456,7 +455,6 @@ void CNode::PushVersion()
     int64_t nTime = (fInbound ? GetAdjustedTime() : GetTime());
     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService("0.0.0.0",0)));
     CAddress addrMe = GetLocalAddress(&addr);
-    GetRandBytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));
     if (fLogIPs)
         LogPrint("net", "send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\n", PROTOCOL_VERSION, nBestHeight, addrMe.ToString(), addrYou.ToString(), id);
     else
@@ -1114,6 +1112,12 @@ void ThreadSocketHandler()
             LOCK(cs_vNodes);
             BOOST_FOREACH(CNode* pnode, vNodes)
             {
+                // FD_SET(pnode->hSocket, &fdsetRecv); fails often for INVALID_SOCKET, tighten locking
+                TRY_LOCK(pnode->cs_vSend, lockSend);
+                if (!lockSend) continue;
+                TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);
+                if (!lockRecv) continue;
+
                 if (pnode->hSocket == INVALID_SOCKET)
                     continue;
                 FD_SET(pnode->hSocket, &fdsetError);
@@ -1136,17 +1140,16 @@ void ThreadSocketHandler()
                 // * We wait for data to be received (and disconnect after timeout).
                 // * We process a message in the buffer (message handler thread).
                 {
-                    TRY_LOCK(pnode->cs_vSend, lockSend);
-                    if (lockSend && !pnode->vSendMsg.empty()) {
+                    // TRY_LOCK(pnode->cs_vSend, lockSend);
+                    if (!pnode->vSendMsg.empty()) {
                         FD_SET(pnode->hSocket, &fdsetSend);
                         continue;
                     }
                 }
                 {
-                    TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);
-                    if (lockRecv && (
-                        pnode->vRecvMsg.empty() || !pnode->vRecvMsg.front().complete() ||
-                        pnode->GetTotalRecvSize() <= ReceiveFloodSize()))
+                    // TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);
+                    if (pnode->vRecvMsg.empty() || !pnode->vRecvMsg.front().complete() ||
+                        pnode->GetTotalRecvSize() <= ReceiveFloodSize())
                         FD_SET(pnode->hSocket, &fdsetRecv);
                 }
             }
@@ -1673,7 +1676,8 @@ void ThreadOpenAddedConnections()
             OpenNetworkConnection(CAddress(vserv[i % vserv.size()]), &grant);
             MilliSleep(500);
         }
-        MilliSleep(120000); // Retry every 2 minutes
+        // MilliSleep(120000); // Retry every 2 minutes
+        MilliSleep(15000); // Retry every 15 seconds 
     }
 }
 
@@ -2380,6 +2384,7 @@ CNode::CNode(SOCKET hSocketIn, const CAddress& addrIn, const std::string& addrNa
     nPingUsecTime = 0;
     fPingQueued = false;
     nMinPingUsecTime = std::numeric_limits<int64_t>::max();
+    GetRandBytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));
 
     {
         LOCK(cs_nLastNodeId);
diff --git a/src/net.h b/src/net.h
index 07083341d..833049cfc 100644
--- a/src/net.h
+++ b/src/net.h
@@ -153,7 +153,6 @@ CAddress GetLocalAddress(const CNetAddr *paddrPeer = NULL);
 extern bool fDiscover;
 extern bool fListen;
 extern uint64_t nLocalServices;
-extern uint64_t nLocalHostNonce;
 extern CAddrMan addrman;
 
 /** Maximum number of connections to simultaneously allow (aka connection slots) */
@@ -360,6 +359,7 @@ public:
     CBloomFilter* pfilter;
     int nRefCount;
     NodeId id;
+    uint256 nLocalHostNonce;
 protected:
 
     // Denial-of-service detection/prevention
diff --git a/src/obj-test/.gitignore b/src/obj-test/.gitignore
deleted file mode 100644
index d6b7ef32c..000000000
--- a/src/obj-test/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-*
-!.gitignore
diff --git a/src/obj/.gitignore b/src/obj/.gitignore
deleted file mode 100644
index d6b7ef32c..000000000
--- a/src/obj/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-*
-!.gitignore
diff --git a/src/policy/fees.cpp b/src/policy/fees.cpp
deleted file mode 100644
index 980ecf10d..000000000
--- a/src/policy/fees.cpp
+++ /dev/null
@@ -1,582 +0,0 @@
-// Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-2015 The Bitcoin developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include "policy/fees.h"
-#include "policy/policy.h"
-
-#include "amount.h"
-#include "primitives/transaction.h"
-#include "streams.h"
-#include "txmempool.h"
-#include "util.h"
-
-void TxConfirmStats::Initialize(std::vector<double>& defaultBuckets,
-                                unsigned int maxConfirms, double _decay, std::string _dataTypeString)
-{
-    decay = _decay;
-    dataTypeString = _dataTypeString;
-    for (unsigned int i = 0; i < defaultBuckets.size(); i++) {
-        buckets.push_back(defaultBuckets[i]);
-        bucketMap[defaultBuckets[i]] = i;
-    }
-    confAvg.resize(maxConfirms);
-    curBlockConf.resize(maxConfirms);
-    unconfTxs.resize(maxConfirms);
-    for (unsigned int i = 0; i < maxConfirms; i++) {
-        confAvg[i].resize(buckets.size());
-        curBlockConf[i].resize(buckets.size());
-        unconfTxs[i].resize(buckets.size());
-    }
-
-    oldUnconfTxs.resize(buckets.size());
-    curBlockTxCt.resize(buckets.size());
-    txCtAvg.resize(buckets.size());
-    curBlockVal.resize(buckets.size());
-    avg.resize(buckets.size());
-}
-
-// Zero out the data for the current block
-void TxConfirmStats::ClearCurrent(unsigned int nBlockHeight)
-{
-    for (unsigned int j = 0; j < buckets.size(); j++) {
-        oldUnconfTxs[j] += unconfTxs[nBlockHeight%unconfTxs.size()][j];
-        unconfTxs[nBlockHeight%unconfTxs.size()][j] = 0;
-        for (unsigned int i = 0; i < curBlockConf.size(); i++)
-            curBlockConf[i][j] = 0;
-        curBlockTxCt[j] = 0;
-        curBlockVal[j] = 0;
-    }
-}
-
-
-void TxConfirmStats::Record(int blocksToConfirm, double val)
-{
-    // blocksToConfirm is 1-based
-    if (blocksToConfirm < 1)
-        return;
-    unsigned int bucketindex = bucketMap.lower_bound(val)->second;
-    for (size_t i = blocksToConfirm; i <= curBlockConf.size(); i++) {
-        curBlockConf[i - 1][bucketindex]++;
-    }
-    curBlockTxCt[bucketindex]++;
-    curBlockVal[bucketindex] += val;
-}
-
-void TxConfirmStats::UpdateMovingAverages()
-{
-    for (unsigned int j = 0; j < buckets.size(); j++) {
-        for (unsigned int i = 0; i < confAvg.size(); i++)
-            confAvg[i][j] = confAvg[i][j] * decay + curBlockConf[i][j];
-        avg[j] = avg[j] * decay + curBlockVal[j];
-        txCtAvg[j] = txCtAvg[j] * decay + curBlockTxCt[j];
-    }
-}
-
-// returns -1 on error conditions
-double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,
-                                         double successBreakPoint, bool requireGreater,
-                                         unsigned int nBlockHeight)
-{
-    // Counters for a bucket (or range of buckets)
-    double nConf = 0; // Number of tx's confirmed within the confTarget
-    double totalNum = 0; // Total number of tx's that were ever confirmed
-    int extraNum = 0;  // Number of tx's still in mempool for confTarget or longer
-
-    int maxbucketindex = buckets.size() - 1;
-
-    // requireGreater means we are looking for the lowest fee/priority such that all higher
-    // values pass, so we start at maxbucketindex (highest fee) and look at succesively
-    // smaller buckets until we reach failure.  Otherwise, we are looking for the highest
-    // fee/priority such that all lower values fail, and we go in the opposite direction.
-    unsigned int startbucket = requireGreater ? maxbucketindex : 0;
-    int step = requireGreater ? -1 : 1;
-
-    // We'll combine buckets until we have enough samples.
-    // The near and far variables will define the range we've combined
-    // The best variables are the last range we saw which still had a high
-    // enough confirmation rate to count as success.
-    // The cur variables are the current range we're counting.
-    unsigned int curNearBucket = startbucket;
-    unsigned int bestNearBucket = startbucket;
-    unsigned int curFarBucket = startbucket;
-    unsigned int bestFarBucket = startbucket;
-
-    bool foundAnswer = false;
-    unsigned int bins = unconfTxs.size();
-
-    // Start counting from highest(default) or lowest fee/pri transactions
-    for (int bucket = startbucket; bucket >= 0 && bucket <= maxbucketindex; bucket += step) {
-        curFarBucket = bucket;
-        nConf += confAvg[confTarget - 1][bucket];
-        totalNum += txCtAvg[bucket];
-        for (unsigned int confct = confTarget; confct < GetMaxConfirms(); confct++)
-            extraNum += unconfTxs[(nBlockHeight - confct)%bins][bucket];
-        extraNum += oldUnconfTxs[bucket];
-        // If we have enough transaction data points in this range of buckets,
-        // we can test for success
-        // (Only count the confirmed data points, so that each confirmation count
-        // will be looking at the same amount of data and same bucket breaks)
-        if (totalNum >= sufficientTxVal / (1 - decay)) {
-            double curPct = nConf / (totalNum + extraNum);
-
-            // Check to see if we are no longer getting confirmed at the success rate
-            if (requireGreater && curPct < successBreakPoint)
-                break;
-            if (!requireGreater && curPct > successBreakPoint)
-                break;
-
-            // Otherwise update the cumulative stats, and the bucket variables
-            // and reset the counters
-            else {
-                foundAnswer = true;
-                nConf = 0;
-                totalNum = 0;
-                extraNum = 0;
-                bestNearBucket = curNearBucket;
-                bestFarBucket = curFarBucket;
-                curNearBucket = bucket + step;
-            }
-        }
-    }
-
-    double median = -1;
-    double txSum = 0;
-
-    // Calculate the "average" fee of the best bucket range that met success conditions
-    // Find the bucket with the median transaction and then report the average fee from that bucket
-    // This is a compromise between finding the median which we can't since we don't save all tx's
-    // and reporting the average which is less accurate
-    unsigned int minBucket = bestNearBucket < bestFarBucket ? bestNearBucket : bestFarBucket;
-    unsigned int maxBucket = bestNearBucket > bestFarBucket ? bestNearBucket : bestFarBucket;
-    for (unsigned int j = minBucket; j <= maxBucket; j++) {
-        txSum += txCtAvg[j];
-    }
-    if (foundAnswer && txSum != 0) {
-        txSum = txSum / 2;
-        for (unsigned int j = minBucket; j <= maxBucket; j++) {
-            if (txCtAvg[j] < txSum)
-                txSum -= txCtAvg[j];
-            else { // we're in the right bucket
-                median = avg[j] / txCtAvg[j];
-                break;
-            }
-        }
-    }
-
-    LogPrint("estimatefee", "%3d: For conf success %s %4.2f need %s %s: %12.5g from buckets %8g - %8g  Cur Bucket stats %6.2f%%  %8.1f/(%.1f+%d mempool)\n",
-             confTarget, requireGreater ? ">" : "<", successBreakPoint, dataTypeString,
-             requireGreater ? ">" : "<", median, buckets[minBucket], buckets[maxBucket],
-             100 * nConf / (totalNum + extraNum), nConf, totalNum, extraNum);
-
-    return median;
-}
-
-void TxConfirmStats::Write(CAutoFile& fileout)
-{
-    fileout << decay;
-    fileout << buckets;
-    fileout << avg;
-    fileout << txCtAvg;
-    fileout << confAvg;
-}
-
-void TxConfirmStats::Read(CAutoFile& filein)
-{
-    // Read data file into temporary variables and do some very basic sanity checking
-    std::vector<double> fileBuckets;
-    std::vector<double> fileAvg;
-    std::vector<std::vector<double> > fileConfAvg;
-    std::vector<double> fileTxCtAvg;
-    double fileDecay;
-    size_t maxConfirms;
-    size_t numBuckets;
-
-    filein >> fileDecay;
-    if (fileDecay <= 0 || fileDecay >= 1)
-        throw std::runtime_error("Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)");
-    filein >> fileBuckets;
-    numBuckets = fileBuckets.size();
-    if (numBuckets <= 1 || numBuckets > 1000)
-        throw std::runtime_error("Corrupt estimates file. Must have between 2 and 1000 fee/pri buckets");
-    filein >> fileAvg;
-    if (fileAvg.size() != numBuckets)
-        throw std::runtime_error("Corrupt estimates file. Mismatch in fee/pri average bucket count");
-    filein >> fileTxCtAvg;
-    if (fileTxCtAvg.size() != numBuckets)
-        throw std::runtime_error("Corrupt estimates file. Mismatch in tx count bucket count");
-    filein >> fileConfAvg;
-    maxConfirms = fileConfAvg.size();
-    if (maxConfirms <= 0 || maxConfirms > 6 * 24 * 7) // one week
-        throw std::runtime_error("Corrupt estimates file.  Must maintain estimates for between 1 and 1008 (one week) confirms");
-    for (unsigned int i = 0; i < maxConfirms; i++) {
-        if (fileConfAvg[i].size() != numBuckets)
-            throw std::runtime_error("Corrupt estimates file. Mismatch in fee/pri conf average bucket count");
-    }
-    // Now that we've processed the entire fee estimate data file and not
-    // thrown any errors, we can copy it to our data structures
-    decay = fileDecay;
-    buckets = fileBuckets;
-    avg = fileAvg;
-    confAvg = fileConfAvg;
-    txCtAvg = fileTxCtAvg;
-    bucketMap.clear();
-
-    // Resize the current block variables which aren't stored in the data file
-    // to match the number of confirms and buckets
-    curBlockConf.resize(maxConfirms);
-    for (unsigned int i = 0; i < maxConfirms; i++) {
-        curBlockConf[i].resize(buckets.size());
-    }
-    curBlockTxCt.resize(buckets.size());
-    curBlockVal.resize(buckets.size());
-
-    unconfTxs.resize(maxConfirms);
-    for (unsigned int i = 0; i < maxConfirms; i++) {
-        unconfTxs[i].resize(buckets.size());
-    }
-    oldUnconfTxs.resize(buckets.size());
-
-    for (unsigned int i = 0; i < buckets.size(); i++)
-        bucketMap[buckets[i]] = i;
-
-    LogPrint("estimatefee", "Reading estimates: %u %s buckets counting confirms up to %u blocks\n",
-             numBuckets, dataTypeString, maxConfirms);
-}
-
-unsigned int TxConfirmStats::NewTx(unsigned int nBlockHeight, double val)
-{
-    unsigned int bucketindex = bucketMap.lower_bound(val)->second;
-    unsigned int blockIndex = nBlockHeight % unconfTxs.size();
-    unconfTxs[blockIndex][bucketindex]++;
-    LogPrint("estimatefee", "adding to %s", dataTypeString);
-    return bucketindex;
-}
-
-void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight, unsigned int bucketindex)
-{
-    //nBestSeenHeight is not updated yet for the new block
-    int blocksAgo = nBestSeenHeight - entryHeight;
-    if (nBestSeenHeight == 0)  // the BlockPolicyEstimator hasn't seen any blocks yet
-        blocksAgo = 0;
-    if (blocksAgo < 0) {
-        LogPrint("estimatefee", "Blockpolicy error, blocks ago is negative for mempool tx\n");
-        return;  //This can't happen because we call this with our best seen height, no entries can have higher
-    }
-
-    if (blocksAgo >= (int)unconfTxs.size()) {
-        if (oldUnconfTxs[bucketindex] > 0)
-            oldUnconfTxs[bucketindex]--;
-        else
-            LogPrint("estimatefee", "Blockpolicy error, mempool tx removed from >25 blocks,bucketIndex=%u already\n",
-                     bucketindex);
-    }
-    else {
-        unsigned int blockIndex = entryHeight % unconfTxs.size();
-        if (unconfTxs[blockIndex][bucketindex] > 0)
-            unconfTxs[blockIndex][bucketindex]--;
-        else
-            LogPrint("estimatefee", "Blockpolicy error, mempool tx removed from blockIndex=%u,bucketIndex=%u already\n",
-                     blockIndex, bucketindex);
-    }
-}
-
-void CBlockPolicyEstimator::removeTx(uint256 hash)
-{
-    std::map<uint256, TxStatsInfo>::iterator pos = mapMemPoolTxs.find(hash);
-    if (pos == mapMemPoolTxs.end()) {
-        LogPrint("estimatefee", "Blockpolicy error mempool tx %s not found for removeTx\n",
-                 hash.ToString().c_str());
-        return;
-    }
-    TxConfirmStats *stats = pos->second.stats;
-    unsigned int entryHeight = pos->second.blockHeight;
-    unsigned int bucketIndex = pos->second.bucketIndex;
-
-    if (stats != NULL)
-        stats->removeTx(entryHeight, nBestSeenHeight, bucketIndex);
-    mapMemPoolTxs.erase(hash);
-}
-
-CBlockPolicyEstimator::CBlockPolicyEstimator(const CFeeRate& _minRelayFee)
-    : nBestSeenHeight(0)
-{
-    minTrackedFee = _minRelayFee < CFeeRate(MIN_FEERATE) ? CFeeRate(MIN_FEERATE) : _minRelayFee;
-    std::vector<double> vfeelist;
-    for (double bucketBoundary = minTrackedFee.GetFeePerK(); bucketBoundary <= MAX_FEERATE; bucketBoundary *= FEE_SPACING) {
-        vfeelist.push_back(bucketBoundary);
-    }
-    vfeelist.push_back(INF_FEERATE);
-    feeStats.Initialize(vfeelist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY, "FeeRate");
-
-    minTrackedPriority = AllowFreeThreshold() < MIN_PRIORITY ? MIN_PRIORITY : AllowFreeThreshold();
-    std::vector<double> vprilist;
-    for (double bucketBoundary = minTrackedPriority; bucketBoundary <= MAX_PRIORITY; bucketBoundary *= PRI_SPACING) {
-        vprilist.push_back(bucketBoundary);
-    }
-    vprilist.push_back(INF_PRIORITY);
-    priStats.Initialize(vprilist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY, "Priority");
-
-    feeUnlikely = CFeeRate(0);
-    feeLikely = CFeeRate(INF_FEERATE);
-    priUnlikely = 0;
-    priLikely = INF_PRIORITY;
-}
-
-bool CBlockPolicyEstimator::isFeeDataPoint(const CFeeRate &fee, double pri)
-{
-    if ((pri < minTrackedPriority && fee >= minTrackedFee) ||
-        (pri < priUnlikely && fee > feeLikely)) {
-        return true;
-    }
-    return false;
-}
-
-bool CBlockPolicyEstimator::isPriDataPoint(const CFeeRate &fee, double pri)
-{
-    if ((fee < minTrackedFee && pri >= minTrackedPriority) ||
-        (fee < feeUnlikely && pri > priLikely)) {
-        return true;
-    }
-    return false;
-}
-
-void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, bool fCurrentEstimate)
-{
-    unsigned int txHeight = entry.GetHeight();
-    uint256 hash = entry.GetTx().GetHash();
-    if (mapMemPoolTxs[hash].stats != NULL) {
-        LogPrint("estimatefee", "Blockpolicy error mempool tx %s already being tracked\n",
-                 hash.ToString().c_str());
-	return;
-    }
-
-    if (txHeight < nBestSeenHeight) {
-        // Ignore side chains and re-orgs; assuming they are random they don't
-        // affect the estimate.  We'll potentially double count transactions in 1-block reorgs.
-        return;
-    }
-
-    // Only want to be updating estimates when our blockchain is synced,
-    // otherwise we'll miscalculate how many blocks its taking to get included.
-    if (!fCurrentEstimate)
-        return;
-
-    if (!entry.WasClearAtEntry()) {
-        // This transaction depends on other transactions in the mempool to
-        // be included in a block before it will be able to be included, so
-        // we shouldn't include it in our calculations
-        return;
-    }
-
-    // Fees are stored and reported as BTC-per-kb:
-    CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());
-
-    // Want the priority of the tx at confirmation. However we don't know
-    // what that will be and its too hard to continue updating it
-    // so use starting priority as a proxy
-    double curPri = entry.GetPriority(txHeight);
-    mapMemPoolTxs[hash].blockHeight = txHeight;
-
-    LogPrint("estimatefee", "Blockpolicy mempool tx %s ", hash.ToString().substr(0,10));
-    // Record this as a priority estimate
-    if (entry.GetFee() == 0 || isPriDataPoint(feeRate, curPri)) {
-        mapMemPoolTxs[hash].stats = &priStats;
-        mapMemPoolTxs[hash].bucketIndex =  priStats.NewTx(txHeight, curPri);
-    }
-    // Record this as a fee estimate
-    else if (isFeeDataPoint(feeRate, curPri)) {
-        mapMemPoolTxs[hash].stats = &feeStats;
-        mapMemPoolTxs[hash].bucketIndex = feeStats.NewTx(txHeight, (double)feeRate.GetFeePerK());
-    }
-    else {
-        LogPrint("estimatefee", "not adding");
-    }
-    LogPrint("estimatefee", "\n");
-}
-
-void CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry& entry)
-{
-    if (!entry.WasClearAtEntry()) {
-        // This transaction depended on other transactions in the mempool to
-        // be included in a block before it was able to be included, so
-        // we shouldn't include it in our calculations
-        return;
-    }
-
-    // How many blocks did it take for miners to include this transaction?
-    // blocksToConfirm is 1-based, so a transaction included in the earliest
-    // possible block has confirmation count of 1
-    int blocksToConfirm = nBlockHeight - entry.GetHeight();
-    if (blocksToConfirm <= 0) {
-        // This can't happen because we don't process transactions from a block with a height
-        // lower than our greatest seen height
-        LogPrint("estimatefee", "Blockpolicy error Transaction had negative blocksToConfirm\n");
-        return;
-    }
-
-    // Fees are stored and reported as BTC-per-kb:
-    CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());
-
-    // Want the priority of the tx at confirmation.  The priority when it
-    // entered the mempool could easily be very small and change quickly
-    double curPri = entry.GetPriority(nBlockHeight);
-
-    // Record this as a priority estimate
-    if (entry.GetFee() == 0 || isPriDataPoint(feeRate, curPri)) {
-        priStats.Record(blocksToConfirm, curPri);
-    }
-    // Record this as a fee estimate
-    else if (isFeeDataPoint(feeRate, curPri)) {
-        feeStats.Record(blocksToConfirm, (double)feeRate.GetFeePerK());
-    }
-}
-
-void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,
-                                         std::vector<CTxMemPoolEntry>& entries, bool fCurrentEstimate)
-{
-    if (nBlockHeight <= nBestSeenHeight) {
-        // Ignore side chains and re-orgs; assuming they are random
-        // they don't affect the estimate.
-        // And if an attacker can re-org the chain at will, then
-        // you've got much bigger problems than "attacker can influence
-        // transaction fees."
-        return;
-    }
-    nBestSeenHeight = nBlockHeight;
-
-    // Only want to be updating estimates when our blockchain is synced,
-    // otherwise we'll miscalculate how many blocks its taking to get included.
-    if (!fCurrentEstimate)
-        return;
-
-    // Update the dynamic cutoffs
-    // a fee/priority is "likely" the reason your tx was included in a block if >85% of such tx's
-    // were confirmed in 2 blocks and is "unlikely" if <50% were confirmed in 10 blocks
-    LogPrint("estimatefee", "Blockpolicy recalculating dynamic cutoffs:\n");
-    priLikely = priStats.EstimateMedianVal(2, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT, true, nBlockHeight);
-    if (priLikely == -1)
-        priLikely = INF_PRIORITY;
-
-    double feeLikelyEst = feeStats.EstimateMedianVal(2, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBlockHeight);
-    if (feeLikelyEst == -1)
-        feeLikely = CFeeRate(INF_FEERATE);
-    else
-        feeLikely = CFeeRate(feeLikelyEst);
-
-    priUnlikely = priStats.EstimateMedianVal(10, SUFFICIENT_PRITXS, UNLIKELY_PCT, false, nBlockHeight);
-    if (priUnlikely == -1)
-        priUnlikely = 0;
-
-    double feeUnlikelyEst = feeStats.EstimateMedianVal(10, SUFFICIENT_FEETXS, UNLIKELY_PCT, false, nBlockHeight);
-    if (feeUnlikelyEst == -1)
-        feeUnlikely = CFeeRate(0);
-    else
-        feeUnlikely = CFeeRate(feeUnlikelyEst);
-
-    // Clear the current block states
-    feeStats.ClearCurrent(nBlockHeight);
-    priStats.ClearCurrent(nBlockHeight);
-
-    // Repopulate the current block states
-    for (unsigned int i = 0; i < entries.size(); i++)
-        processBlockTx(nBlockHeight, entries[i]);
-
-    // Update all exponential averages with the current block states
-    feeStats.UpdateMovingAverages();
-    priStats.UpdateMovingAverages();
-
-    LogPrint("estimatefee", "Blockpolicy after updating estimates for %u confirmed entries, new mempool map size %u\n",
-             entries.size(), mapMemPoolTxs.size());
-}
-
-CFeeRate CBlockPolicyEstimator::estimateFee(int confTarget)
-{
-    // Return failure if trying to analyze a target we're not tracking
-    if (confTarget <= 0 || (unsigned int)confTarget > feeStats.GetMaxConfirms())
-        return CFeeRate(0);
-
-    double median = feeStats.EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);
-
-    if (median < 0)
-        return CFeeRate(0);
-
-    return CFeeRate(median);
-}
-
-CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool)
-{
-    if (answerFoundAtTarget)
-        *answerFoundAtTarget = confTarget;
-    // Return failure if trying to analyze a target we're not tracking
-    if (confTarget <= 0 || (unsigned int)confTarget > feeStats.GetMaxConfirms())
-        return CFeeRate(0);
-
-    double median = -1;
-    while (median < 0 && (unsigned int)confTarget <= feeStats.GetMaxConfirms()) {
-        median = feeStats.EstimateMedianVal(confTarget++, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);
-    }
-
-    if (answerFoundAtTarget)
-        *answerFoundAtTarget = confTarget - 1;
-
-    // If mempool is limiting txs , return at least the min fee from the mempool
-    CAmount minPoolFee = pool.GetMinFee(GetArg("-maxmempool", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();
-    if (minPoolFee > 0 && minPoolFee > median)
-        return CFeeRate(minPoolFee);
-
-    if (median < 0)
-        return CFeeRate(0);
-
-    return CFeeRate(median);
-}
-
-double CBlockPolicyEstimator::estimatePriority(int confTarget)
-{
-    // Return failure if trying to analyze a target we're not tracking
-    if (confTarget <= 0 || (unsigned int)confTarget > priStats.GetMaxConfirms())
-        return -1;
-
-    return priStats.EstimateMedianVal(confTarget, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);
-}
-
-double CBlockPolicyEstimator::estimateSmartPriority(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool)
-{
-    if (answerFoundAtTarget)
-        *answerFoundAtTarget = confTarget;
-    // Return failure if trying to analyze a target we're not tracking
-    if (confTarget <= 0 || (unsigned int)confTarget > priStats.GetMaxConfirms())
-        return -1;
-
-    // If mempool is limiting txs, no priority txs are allowed
-    CAmount minPoolFee = pool.GetMinFee(GetArg("-maxmempool", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();
-    if (minPoolFee > 0)
-        return INF_PRIORITY;
-
-    double median = -1;
-    while (median < 0 && (unsigned int)confTarget <= priStats.GetMaxConfirms()) {
-        median = priStats.EstimateMedianVal(confTarget++, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);
-    }
-
-    if (answerFoundAtTarget)
-        *answerFoundAtTarget = confTarget - 1;
-
-    return median;
-}
-
-void CBlockPolicyEstimator::Write(CAutoFile& fileout)
-{
-    fileout << nBestSeenHeight;
-    feeStats.Write(fileout);
-    priStats.Write(fileout);
-}
-
-void CBlockPolicyEstimator::Read(CAutoFile& filein)
-{
-    int nFileBestSeenHeight;
-    filein >> nFileBestSeenHeight;
-    feeStats.Read(filein);
-    priStats.Read(filein);
-    nBestSeenHeight = nFileBestSeenHeight;
-}
diff --git a/src/policy/fees.h b/src/policy/fees.h
deleted file mode 100644
index 7a293267d..000000000
--- a/src/policy/fees.h
+++ /dev/null
@@ -1,289 +0,0 @@
-// Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-2015 The Bitcoin developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-#ifndef BITCOIN_POLICYESTIMATOR_H
-#define BITCOIN_POLICYESTIMATOR_H
-
-#include "amount.h"
-#include "uint256.h"
-
-#include <map>
-#include <string>
-#include <vector>
-
-class CAutoFile;
-class CFeeRate;
-class CTxMemPoolEntry;
-class CTxMemPool;
-
-/** \class CBlockPolicyEstimator
- * The BlockPolicyEstimator is used for estimating the fee or priority needed
- * for a transaction to be included in a block within a certain number of
- * blocks.
- *
- * At a high level the algorithm works by grouping transactions into buckets
- * based on having similar priorities or fees and then tracking how long it
- * takes transactions in the various buckets to be mined.  It operates under
- * the assumption that in general transactions of higher fee/priority will be
- * included in blocks before transactions of lower fee/priority.   So for
- * example if you wanted to know what fee you should put on a transaction to
- * be included in a block within the next 5 blocks, you would start by looking
- * at the bucket with with the highest fee transactions and verifying that a
- * sufficiently high percentage of them were confirmed within 5 blocks and
- * then you would look at the next highest fee bucket, and so on, stopping at
- * the last bucket to pass the test.   The average fee of transactions in this
- * bucket will give you an indication of the lowest fee you can put on a
- * transaction and still have a sufficiently high chance of being confirmed
- * within your desired 5 blocks.
- *
- * When a transaction enters the mempool or is included within a block we
- * decide whether it can be used as a data point for fee estimation, priority
- * estimation or neither.  If the value of exactly one of those properties was
- * below the required minimum it can be used to estimate the other.  In
- * addition, if a priori our estimation code would indicate that the
- * transaction would be much more quickly included in a block because of one
- * of the properties compared to the other, we can also decide to use it as
- * an estimate for that property.
- *
- * Here is a brief description of the implementation for fee estimation.
- * When a transaction that counts for fee estimation enters the mempool, we
- * track the height of the block chain at entry.  Whenever a block comes in,
- * we count the number of transactions in each bucket and the total amount of fee
- * paid in each bucket. Then we calculate how many blocks Y it took each
- * transaction to be mined and we track an array of counters in each bucket
- * for how long it to took transactions to get confirmed from 1 to a max of 25
- * and we increment all the counters from Y up to 25. This is because for any
- * number Z>=Y the transaction was successfully mined within Z blocks.  We
- * want to save a history of this information, so at any time we have a
- * counter of the total number of transactions that happened in a given fee
- * bucket and the total number that were confirmed in each number 1-25 blocks
- * or less for any bucket.   We save this history by keeping an exponentially
- * decaying moving average of each one of these stats.  Furthermore we also
- * keep track of the number unmined (in mempool) transactions in each bucket
- * and for how many blocks they have been outstanding and use that to increase
- * the number of transactions we've seen in that fee bucket when calculating
- * an estimate for any number of confirmations below the number of blocks
- * they've been outstanding.
- */
-
-/**
- * We will instantiate two instances of this class, one to track transactions
- * that were included in a block due to fee, and one for tx's included due to
- * priority.  We will lump transactions into a bucket according to their approximate
- * fee or priority and then track how long it took for those txs to be included in a block
- *
- * The tracking of unconfirmed (mempool) transactions is completely independent of the
- * historical tracking of transactions that have been confirmed in a block.
- */
-class TxConfirmStats
-{
-private:
-    //Define the buckets we will group transactions into (both fee buckets and priority buckets)
-    std::vector<double> buckets;              // The upper-bound of the range for the bucket (inclusive)
-    std::map<double, unsigned int> bucketMap; // Map of bucket upper-bound to index into all vectors by bucket
-
-    // For each bucket X:
-    // Count the total # of txs in each bucket
-    // Track the historical moving average of this total over blocks
-    std::vector<double> txCtAvg;
-    // and calcuate the total for the current block to update the moving average
-    std::vector<int> curBlockTxCt;
-
-    // Count the total # of txs confirmed within Y blocks in each bucket
-    // Track the historical moving average of theses totals over blocks
-    std::vector<std::vector<double> > confAvg; // confAvg[Y][X]
-    // and calcuate the totals for the current block to update the moving averages
-    std::vector<std::vector<int> > curBlockConf; // curBlockConf[Y][X]
-
-    // Sum the total priority/fee of all tx's in each bucket
-    // Track the historical moving average of this total over blocks
-    std::vector<double> avg;
-    // and calculate the total for the current block to update the moving average
-    std::vector<double> curBlockVal;
-
-    // Combine the conf counts with tx counts to calculate the confirmation % for each Y,X
-    // Combine the total value with the tx counts to calculate the avg fee/priority per bucket
-
-    std::string dataTypeString;
-    double decay;
-
-    // Mempool counts of outstanding transactions
-    // For each bucket X, track the number of transactions in the mempool
-    // that are unconfirmed for each possible confirmation value Y
-    std::vector<std::vector<int> > unconfTxs;  //unconfTxs[Y][X]
-    // transactions still unconfirmed after MAX_CONFIRMS for each bucket
-    std::vector<int> oldUnconfTxs;
-
-public:
-    /**
-     * Initialize the data structures.  This is called by BlockPolicyEstimator's
-     * constructor with default values.
-     * @param defaultBuckets contains the upper limits for the bucket boundaries
-     * @param maxConfirms max number of confirms to track
-     * @param decay how much to decay the historical moving average per block
-     * @param dataTypeString for logging purposes
-     */
-    void Initialize(std::vector<double>& defaultBuckets, unsigned int maxConfirms, double decay, std::string dataTypeString);
-
-    /** Clear the state of the curBlock variables to start counting for the new block */
-    void ClearCurrent(unsigned int nBlockHeight);
-
-    /**
-     * Record a new transaction data point in the current block stats
-     * @param blocksToConfirm the number of blocks it took this transaction to confirm
-     * @param val either the fee or the priority when entered of the transaction
-     * @warning blocksToConfirm is 1-based and has to be >= 1
-     */
-    void Record(int blocksToConfirm, double val);
-
-    /** Record a new transaction entering the mempool*/
-    unsigned int NewTx(unsigned int nBlockHeight, double val);
-
-    /** Remove a transaction from mempool tracking stats*/
-    void removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight,
-                  unsigned int bucketIndex);
-
-    /** Update our estimates by decaying our historical moving average and updating
-        with the data gathered from the current block */
-    void UpdateMovingAverages();
-
-    /**
-     * Calculate a fee or priority estimate.  Find the lowest value bucket (or range of buckets
-     * to make sure we have enough data points) whose transactions still have sufficient likelihood
-     * of being confirmed within the target number of confirmations
-     * @param confTarget target number of confirmations
-     * @param sufficientTxVal required average number of transactions per block in a bucket range
-     * @param minSuccess the success probability we require
-     * @param requireGreater return the lowest fee/pri such that all higher values pass minSuccess OR
-     *        return the highest fee/pri such that all lower values fail minSuccess
-     * @param nBlockHeight the current block height
-     */
-    double EstimateMedianVal(int confTarget, double sufficientTxVal,
-                             double minSuccess, bool requireGreater, unsigned int nBlockHeight);
-
-    /** Return the max number of confirms we're tracking */
-    unsigned int GetMaxConfirms() { return confAvg.size(); }
-
-    /** Write state of estimation data to a file*/
-    void Write(CAutoFile& fileout);
-
-    /**
-     * Read saved state of estimation data from a file and replace all internal data structures and
-     * variables with this state.
-     */
-    void Read(CAutoFile& filein);
-};
-
-
-
-/** Track confirm delays up to 25 blocks, can't estimate beyond that */
-static const unsigned int MAX_BLOCK_CONFIRMS = 25;
-
-/** Decay of .998 is a half-life of 346 blocks or about 2.4 days */
-static const double DEFAULT_DECAY = .998;
-
-/** Require greater than 95% of X fee transactions to be confirmed within Y blocks for X to be big enough */
-static const double MIN_SUCCESS_PCT = .95;
-static const double UNLIKELY_PCT = .5;
-
-/** Require an avg of 1 tx in the combined fee bucket per block to have stat significance */
-static const double SUFFICIENT_FEETXS = 1;
-
-/** Require only an avg of 1 tx every 5 blocks in the combined pri bucket (way less pri txs) */
-static const double SUFFICIENT_PRITXS = .2;
-
-// Minimum and Maximum values for tracking fees and priorities
-static const double MIN_FEERATE = 10;
-static const double MAX_FEERATE = 1e7;
-static const double INF_FEERATE = MAX_MONEY;
-static const double MIN_PRIORITY = 10;
-static const double MAX_PRIORITY = 1e16;
-static const double INF_PRIORITY = 1e9 * MAX_MONEY;
-
-// We have to lump transactions into buckets based on fee or priority, but we want to be able
-// to give accurate estimates over a large range of potential fees and priorities
-// Therefore it makes sense to exponentially space the buckets
-/** Spacing of FeeRate buckets */
-static const double FEE_SPACING = 1.1;
-
-/** Spacing of Priority buckets */
-static const double PRI_SPACING = 2;
-
-/**
- *  We want to be able to estimate fees or priorities that are needed on tx's to be included in
- * a certain number of blocks.  Every time a block is added to the best chain, this class records
- * stats on the transactions included in that block
- */
-class CBlockPolicyEstimator
-{
-public:
-    /** Create new BlockPolicyEstimator and initialize stats tracking classes with default values */
-    CBlockPolicyEstimator(const CFeeRate& minRelayFee);
-
-    /** Process all the transactions that have been included in a block */
-    void processBlock(unsigned int nBlockHeight,
-                      std::vector<CTxMemPoolEntry>& entries, bool fCurrentEstimate);
-
-    /** Process a transaction confirmed in a block*/
-    void processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry& entry);
-
-    /** Process a transaction accepted to the mempool*/
-    void processTransaction(const CTxMemPoolEntry& entry, bool fCurrentEstimate);
-
-    /** Remove a transaction from the mempool tracking stats*/
-    void removeTx(uint256 hash);
-
-    /** Is this transaction likely included in a block because of its fee?*/
-    bool isFeeDataPoint(const CFeeRate &fee, double pri);
-
-    /** Is this transaction likely included in a block because of its priority?*/
-    bool isPriDataPoint(const CFeeRate &fee, double pri);
-
-    /** Return a fee estimate */
-    CFeeRate estimateFee(int confTarget);
-
-    /** Estimate fee rate needed to get be included in a block within
-     *  confTarget blocks. If no answer can be given at confTarget, return an
-     *  estimate at the lowest target where one can be given.
-     */
-    CFeeRate estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool);
-
-    /** Return a priority estimate */
-    double estimatePriority(int confTarget);
-
-    /** Estimate priority needed to get be included in a block within
-     *  confTarget blocks. If no answer can be given at confTarget, return an
-     *  estimate at the lowest target where one can be given.
-     */
-    double estimateSmartPriority(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool);
-
-    /** Write estimation data to a file */
-    void Write(CAutoFile& fileout);
-
-    /** Read estimation data from a file */
-    void Read(CAutoFile& filein);
-
-private:
-    CFeeRate minTrackedFee; //! Passed to constructor to avoid dependency on main
-    double minTrackedPriority; //! Set to AllowFreeThreshold
-    unsigned int nBestSeenHeight;
-    struct TxStatsInfo
-    {
-        TxConfirmStats *stats;
-        unsigned int blockHeight;
-        unsigned int bucketIndex;
-        TxStatsInfo() : stats(NULL), blockHeight(0), bucketIndex(0) {}
-    };
-
-    // map of txids to information about that transaction
-    std::map<uint256, TxStatsInfo> mapMemPoolTxs;
-
-    /** Classes to track historical data on transaction confirmations */
-    TxConfirmStats feeStats, priStats;
-
-    /** Breakpoints to help determine whether a transaction was confirmed by priority or Fee */
-    CFeeRate feeLikely, feeUnlikely;
-    double priLikely, priUnlikely;
-};
-#endif /*BITCOIN_POLICYESTIMATOR_H */
diff --git a/src/policy/policy.cpp b/src/policy/policy.cpp
index 018b3d25b..cb52f3eec 100644
--- a/src/policy/policy.cpp
+++ b/src/policy/policy.cpp
@@ -53,7 +53,7 @@ bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType)
                (!fAcceptDatacarrier || scriptPubKey.size() > nMaxDatacarrierBytes))
           return false;
 
-    return whichType != TX_NONSTANDARD;
+    return whichType != TX_NONSTANDARD && whichType != TX_PUBKEY;
 }
 
 bool IsStandardTx(const CTransaction& tx, std::string& reason)
@@ -92,6 +92,13 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason)
         }
     }
 
+    if (tx.IsCoinBase()) {
+        if (tx.vout.size() > 2) {
+            reason = "invalid-privileged-transaction";
+            return false;
+        }
+    }
+
     unsigned int nDataOut = 0;
     txnouttype whichType;
     BOOST_FOREACH(const CTxOut& txout, tx.vout) {
@@ -105,9 +112,6 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason)
         else if ((whichType == TX_MULTISIG) && (!fIsBareMultisigStd)) {
             reason = "bare-multisig";
             return false;
-        } else if (txout.IsDust(::minRelayTxFee)) {
-            reason = "dust";
-            return false;
         }
     }
 
diff --git a/src/policy/policy.h b/src/policy/policy.h
index 4f9354e36..4daa5aec9 100644
--- a/src/policy/policy.h
+++ b/src/policy/policy.h
@@ -17,8 +17,6 @@ class CCoinsViewCache;
 /** Default for -blockmaxsize and -blockminsize, which control the range of sizes the mining code will create **/
 static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 750000;
 static const unsigned int DEFAULT_BLOCK_MIN_SIZE = 0;
-/** Default for -blockprioritysize, maximum space for zero/low-fee transactions **/
-static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 0;
 /** The maximum size for transactions we're willing to relay/mine */
 static const unsigned int MAX_STANDARD_TX_SIZE = 100000;
 /** Maximum number of signature check operations in an IsStandard() P2SH script */
diff --git a/src/pow.cpp b/src/pow.cpp
deleted file mode 100644
index 7392defe6..000000000
--- a/src/pow.cpp
+++ /dev/null
@@ -1,136 +0,0 @@
-// Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-2015 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include "pow.h"
-
-#include "arith_uint256.h"
-#include "chain.h"
-#include "primitives/block.h"
-#include "uint256.h"
-#include "util.h"
-
-unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params& params)
-{
-    unsigned int nProofOfWorkLimit = UintToArith256(params.powLimit).GetCompact();
-
-    // Genesis block
-    if (pindexLast == NULL)
-        return nProofOfWorkLimit;
-
-    // Only change once per difficulty adjustment interval
-    if ((pindexLast->nHeight+1) % params.DifficultyAdjustmentInterval() != 0)
-    {
-        if (params.fPowAllowMinDifficultyBlocks)
-        {
-            // Special difficulty rule for testnet:
-            // If the new block's timestamp is more than 2* 10 minutes
-            // then allow mining of a min-difficulty block.
-            if (pblock->GetBlockTime() > pindexLast->GetBlockTime() + params.nPowTargetSpacing*2)
-                return nProofOfWorkLimit;
-            else
-            {
-                // Return the last non-special-min-difficulty-rules-block
-                const CBlockIndex* pindex = pindexLast;
-                while (pindex->pprev && pindex->nHeight % params.DifficultyAdjustmentInterval() != 0 && pindex->nBits == nProofOfWorkLimit)
-                    pindex = pindex->pprev;
-                return pindex->nBits;
-            }
-        }
-        return pindexLast->nBits;
-    }
-
-    // Go back by what we want to be 14 days worth of blocks
-    int nHeightFirst = pindexLast->nHeight - (params.DifficultyAdjustmentInterval()-1);
-    assert(nHeightFirst >= 0);
-    const CBlockIndex* pindexFirst = pindexLast->GetAncestor(nHeightFirst);
-    assert(pindexFirst);
-
-    return CalculateNextWorkRequired(pindexLast, pindexFirst->GetBlockTime(), params);
-}
-
-unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params& params)
-{
-    if (params.fPowNoRetargeting)
-        return pindexLast->nBits;
-
-    // Limit adjustment step
-    int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime;
-    LogPrintf("  nActualTimespan = %d  before bounds\n", nActualTimespan);
-    if (nActualTimespan < params.nPowTargetTimespan/4)
-        nActualTimespan = params.nPowTargetTimespan/4;
-    if (nActualTimespan > params.nPowTargetTimespan*4)
-        nActualTimespan = params.nPowTargetTimespan*4;
-
-    // Retarget
-    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);
-    arith_uint256 bnNew;
-    arith_uint256 bnOld;
-    bnNew.SetCompact(pindexLast->nBits);
-    bnOld = bnNew;
-    bnNew *= nActualTimespan;
-    bnNew /= params.nPowTargetTimespan;
-
-    if (bnNew > bnPowLimit)
-        bnNew = bnPowLimit;
-
-    /// debug print
-    LogPrintf("GetNextWorkRequired RETARGET\n");
-    LogPrintf("params.nPowTargetTimespan = %d    nActualTimespan = %d\n", params.nPowTargetTimespan, nActualTimespan);
-    LogPrintf("Before: %08x  %s\n", pindexLast->nBits, bnOld.ToString());
-    LogPrintf("After:  %08x  %s\n", bnNew.GetCompact(), bnNew.ToString());
-
-    return bnNew.GetCompact();
-}
-
-bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params& params)
-{
-    bool fNegative;
-    bool fOverflow;
-    arith_uint256 bnTarget;
-
-    bnTarget.SetCompact(nBits, &fNegative, &fOverflow);
-
-    // Check range
-    if (fNegative || bnTarget == 0 || fOverflow || bnTarget > UintToArith256(params.powLimit))
-        return error("CheckProofOfWork(): nBits below minimum work");
-
-    // Check proof of work matches claimed amount
-    if (UintToArith256(hash) > bnTarget)
-        return error("CheckProofOfWork(): hash doesn't match nBits");
-
-    return true;
-}
-
-arith_uint256 GetBlockProof(const CBlockIndex& block)
-{
-    arith_uint256 bnTarget;
-    bool fNegative;
-    bool fOverflow;
-    bnTarget.SetCompact(block.nBits, &fNegative, &fOverflow);
-    if (fNegative || fOverflow || bnTarget == 0)
-        return 0;
-    // We need to compute 2**256 / (bnTarget+1), but we can't represent 2**256
-    // as it's too large for a arith_uint256. However, as 2**256 is at least as large
-    // as bnTarget+1, it is equal to ((2**256 - bnTarget - 1) / (bnTarget+1)) + 1,
-    // or ~bnTarget / (nTarget+1) + 1.
-    return (~bnTarget / (bnTarget + 1)) + 1;
-}
-
-int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params& params)
-{
-    arith_uint256 r;
-    int sign = 1;
-    if (to.nChainWork > from.nChainWork) {
-        r = to.nChainWork - from.nChainWork;
-    } else {
-        r = from.nChainWork - to.nChainWork;
-        sign = -1;
-    }
-    r = r * arith_uint256(params.nPowTargetSpacing) / GetBlockProof(tip);
-    if (r.bits() > 63) {
-        return sign * std::numeric_limits<int64_t>::max();
-    }
-    return sign * r.GetLow64();
-}
diff --git a/src/pow.h b/src/pow.h
deleted file mode 100644
index 439944092..000000000
--- a/src/pow.h
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2009-2015 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#ifndef BITCOIN_POW_H
-#define BITCOIN_POW_H
-
-#include "consensus/params.h"
-
-#include <stdint.h>
-
-class CBlockHeader;
-class CBlockIndex;
-class uint256;
-class arith_uint256;
-
-unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params&);
-unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&);
-
-/** Check whether a block hash satisfies the proof-of-work requirement specified by nBits */
-bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params&);
-arith_uint256 GetBlockProof(const CBlockIndex& block);
-
-/** Return the time it would take to redo the work difference between from and to, assuming the current hashrate corresponds to the difficulty at tip, in seconds. */
-int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params&);
-
-#endif // BITCOIN_POW_H
diff --git a/src/primitives/block.cpp b/src/primitives/block.cpp
index 59e949d71..bc230dc1e 100644
--- a/src/primitives/block.cpp
+++ b/src/primitives/block.cpp
@@ -18,12 +18,12 @@ uint256 CBlockHeader::GetHash() const
 std::string CBlock::ToString() const
 {
     std::stringstream s;
-    s << strprintf("CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%u)\n",
+    s << strprintf("CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nRootHeight=%u, nOperatorHeight=%u, nChainStakeSeconds=%lx, vtx=%u)\n",
         GetHash().ToString(),
         nVersion,
         hashPrevBlock.ToString(),
         hashMerkleRoot.ToString(),
-        nTime, nBits, nNonce,
+        nTime, nRootHeight, nOperatorHeight, nChainStakeSeconds,
         vtx.size());
     for (unsigned int i = 0; i < vtx.size(); i++)
     {
@@ -31,3 +31,18 @@ std::string CBlock::ToString() const
     }
     return s.str();
 }
+
+bool operator>(const CBlockHeader& a, const CBlockHeader& b) {
+    if (a.nRootHeight > b.nRootHeight) return true;
+    if (a.nRootHeight < b.nRootHeight) return false;
+
+    if (a.nOperatorHeight > b.nOperatorHeight) return true;
+    if (a.nOperatorHeight < b.nOperatorHeight) return false;
+
+    if (a.nChainStakeSeconds > b.nChainStakeSeconds) return true;
+    if (a.nChainStakeSeconds < b.nChainStakeSeconds) return false;
+
+    // Random determination
+    return a.GetHash() < b.GetHash();
+}
+
diff --git a/src/primitives/block.h b/src/primitives/block.h
index 42276b2bc..fa420e9b9 100644
--- a/src/primitives/block.h
+++ b/src/primitives/block.h
@@ -25,8 +25,12 @@ public:
     uint256 hashPrevBlock;
     uint256 hashMerkleRoot;
     uint32_t nTime;
-    uint32_t nBits;
-    uint32_t nNonce;
+    int nRootHeight;
+    int nOperatorHeight;
+    uint64_t nChainStakeSeconds;
+    // uint32_t nBits;
+    // uint32_t nNonce;
+    CScript vchBlockSig;
 
     CBlockHeader()
     {
@@ -42,8 +46,13 @@ public:
         READWRITE(hashPrevBlock);
         READWRITE(hashMerkleRoot);
         READWRITE(nTime);
-        READWRITE(nBits);
-        READWRITE(nNonce);
+        // READWRITE(nBits);
+        // READWRITE(nNonce);
+        READWRITE(nRootHeight);
+        READWRITE(nOperatorHeight);
+        READWRITE(nChainStakeSeconds);
+        if (!(nType & SER_GETHASH))
+            READWRITE(*(CScriptBase*)(&vchBlockSig));
     }
 
     void SetNull()
@@ -52,13 +61,17 @@ public:
         hashPrevBlock.SetNull();
         hashMerkleRoot.SetNull();
         nTime = 0;
-        nBits = 0;
-        nNonce = 0;
+        nRootHeight = -1;
+        nOperatorHeight = -1;
+        nChainStakeSeconds = 0;
+        // nBits = 0;
+        // nNonce = 0;
     }
 
     bool IsNull() const
     {
-        return (nBits == 0);
+        // return (nBits == 0);
+        return (nRootHeight == -1);
     }
 
     uint256 GetHash() const;
@@ -69,6 +82,7 @@ public:
     }
 };
 
+bool operator>(const CBlockHeader& a, const CBlockHeader& b);
 
 class CBlock : public CBlockHeader
 {
@@ -112,8 +126,11 @@ public:
         block.hashPrevBlock  = hashPrevBlock;
         block.hashMerkleRoot = hashMerkleRoot;
         block.nTime          = nTime;
-        block.nBits          = nBits;
-        block.nNonce         = nNonce;
+        // block.nBits          = nBits;
+        // block.nNonce         = nNonce;
+        block.nRootHeight        = nRootHeight;
+        block.nOperatorHeight    = nOperatorHeight;
+        block.nChainStakeSeconds = nChainStakeSeconds;
         return block;
     }
 
diff --git a/src/primitives/transaction.cpp b/src/primitives/transaction.cpp
index 947f2e6a7..b2a2cc87d 100644
--- a/src/primitives/transaction.cpp
+++ b/src/primitives/transaction.cpp
@@ -11,7 +11,7 @@
 
 std::string COutPoint::ToString() const
 {
-    return strprintf("COutPoint(%s, %u)", hash.ToString().substr(0,10), n);
+    return strprintf("COutPoint(%s, %u)", hash.ToString(), n);
 }
 
 CTxIn::CTxIn(COutPoint prevoutIn, CScript scriptSigIn, uint32_t nSequenceIn)
@@ -36,14 +36,14 @@ std::string CTxIn::ToString() const
     if (prevout.IsNull())
         str += strprintf(", coinbase %s", HexStr(scriptSig));
     else
-        str += strprintf(", scriptSig=%s", HexStr(scriptSig).substr(0, 24));
+        str += strprintf(", scriptSig=%s", HexStr(scriptSig));
     if (nSequence != SEQUENCE_FINAL)
         str += strprintf(", nSequence=%u", nSequence);
     str += ")";
     return str;
 }
 
-CTxOut::CTxOut(const CAmount& nValueIn, CScript scriptPubKeyIn)
+CTxOut::CTxOut(const CValue& nValueIn, CScript scriptPubKeyIn)
 {
     nValue = nValueIn;
     scriptPubKey = scriptPubKeyIn;
@@ -56,7 +56,7 @@ uint256 CTxOut::GetHash() const
 
 std::string CTxOut::ToString() const
 {
-    return strprintf("CTxOut(nValue=%d.%08d, scriptPubKey=%s)", nValue / COIN, nValue % COIN, HexStr(scriptPubKey).substr(0, 30));
+    return strprintf("CTxOut(nValue=%d:%ld, scriptPubKey=%s)", nValue.first, nValue.second, HexStr(scriptPubKey));
 }
 
 CMutableTransaction::CMutableTransaction() : nVersion(CTransaction::CURRENT_VERSION), nLockTime(0) {}
@@ -89,47 +89,21 @@ CTransaction& CTransaction::operator=(const CTransaction &tx) {
 
 CAmount CTransaction::GetValueOut() const
 {
-    CAmount nValueOut = 0;
+    CAmount nValueOut;
     for (std::vector<CTxOut>::const_iterator it(vout.begin()); it != vout.end(); ++it)
     {
-        nValueOut += it->nValue;
+        nValueOut[it->nValue.first] += it->nValue.second;
         if (!MoneyRange(it->nValue) || !MoneyRange(nValueOut))
             throw std::runtime_error("CTransaction::GetValueOut(): value out of range");
     }
     return nValueOut;
 }
 
-double CTransaction::ComputePriority(double dPriorityInputs, unsigned int nTxSize) const
-{
-    nTxSize = CalculateModifiedSize(nTxSize);
-    if (nTxSize == 0) return 0.0;
-
-    return dPriorityInputs / nTxSize;
-}
-
-unsigned int CTransaction::CalculateModifiedSize(unsigned int nTxSize) const
-{
-    // In order to avoid disincentivizing cleaning up the UTXO set we don't count
-    // the constant overhead for each txin and up to 110 bytes of scriptSig (which
-    // is enough to cover a compressed pubkey p2sh redemption) for priority.
-    // Providing any more cleanup incentive than making additional inputs free would
-    // risk encouraging people to create junk outputs to redeem later.
-    if (nTxSize == 0)
-        nTxSize = ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);
-    for (std::vector<CTxIn>::const_iterator it(vin.begin()); it != vin.end(); ++it)
-    {
-        unsigned int offset = 41U + std::min(110U, (unsigned int)it->scriptSig.size());
-        if (nTxSize > offset)
-            nTxSize -= offset;
-    }
-    return nTxSize;
-}
-
 std::string CTransaction::ToString() const
 {
     std::string str;
     str += strprintf("CTransaction(hash=%s, ver=%d, vin.size=%u, vout.size=%u, nLockTime=%u)\n",
-        GetHash().ToString().substr(0,10),
+        GetHash().ToString(),
         nVersion,
         vin.size(),
         vout.size(),
diff --git a/src/primitives/transaction.h b/src/primitives/transaction.h
index 9f7d6f394..a1722ecc5 100644
--- a/src/primitives/transaction.h
+++ b/src/primitives/transaction.h
@@ -126,7 +126,7 @@ public:
 class CTxOut
 {
 public:
-    CAmount nValue;
+    CValue nValue;
     CScript scriptPubKey;
 
     CTxOut()
@@ -134,51 +134,41 @@ public:
         SetNull();
     }
 
-    CTxOut(const CAmount& nValueIn, CScript scriptPubKeyIn);
+    CTxOut(const CValue& nValueIn, CScript scriptPubKeyIn);
 
     ADD_SERIALIZE_METHODS;
 
     template <typename Stream, typename Operation>
     inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {
-        READWRITE(nValue);
+        uint32_t asset_id;
+        int64_t shares;
+        if (!ser_action.ForRead()) {
+            asset_id = nValue.first;
+            shares = nValue.second;
+        }
+        READWRITE(asset_id);
+        READWRITE(shares);
         READWRITE(*(CScriptBase*)(&scriptPubKey));
+        if (ser_action.ForRead()) {
+            nValue.first = asset_id;
+            nValue.second = shares;
+        }
     }
 
     void SetNull()
     {
-        nValue = -1;
+        nValue.first = ABC_ID;
+        nValue.second = -1;
         scriptPubKey.clear();
     }
 
     bool IsNull() const
     {
-        return (nValue == -1);
+        return nValue.second == -1;
     }
 
     uint256 GetHash() const;
 
-    CAmount GetDustThreshold(const CFeeRate &minRelayTxFee) const
-    {
-        // "Dust" is defined in terms of CTransaction::minRelayTxFee,
-        // which has units satoshis-per-kilobyte.
-        // If you'd pay more than 1/3 in fees
-        // to spend something, then we consider it dust.
-        // A typical spendable txout is 34 bytes big, and will
-        // need a CTxIn of at least 148 bytes to spend:
-        // so dust is a spendable txout less than
-        // 546*minRelayTxFee/1000 (in satoshis)
-        if (scriptPubKey.IsUnspendable())
-            return 0;
-
-        size_t nSize = GetSerializeSize(SER_DISK,0)+148u;
-        return 3*minRelayTxFee.GetFee(nSize);
-    }
-
-    bool IsDust(const CFeeRate &minRelayTxFee) const
-    {
-        return (nValue < GetDustThreshold(minRelayTxFee));
-    }
-
     friend bool operator==(const CTxOut& a, const CTxOut& b)
     {
         return (a.nValue       == b.nValue &&
@@ -259,15 +249,20 @@ public:
     // GetValueIn() is a method on CCoinsViewCache, because
     // inputs must be known to compute value in.
 
-    // Compute priority, given priority of inputs and (optionally) tx size
-    double ComputePriority(double dPriorityInputs, unsigned int nTxSize=0) const;
-
-    // Compute modified tx size for priority calculation (optionally given tx size)
-    unsigned int CalculateModifiedSize(unsigned int nTxSize=0) const;
-
+    // Root transaction has one null input with signature script signed by current root key id and one NULL DATA output containing authorization information
+    // Issue transaction has one null input with signature script signed by current operator key id and one DATA output containing the corresponding asset
+    // Todo: rename IsCoinBase to IsIssue
     bool IsCoinBase() const
     {
-        return (vin.size() == 1 && vin[0].prevout.IsNull());
+        return (vin.size() == 1 && vin[0].prevout.IsNull() && \
+                vin[0].scriptSig.IsPushOnly() && \
+                ((vout.size() == 1 && vout[0].nValue.second == 0 && \
+                vout[0].scriptPubKey.size() >= 1 && vout[0].scriptPubKey[0] == OP_RETURN && \
+                vout[0].scriptPubKey.IsPushOnly(vout[0].scriptPubKey.begin()+1)) || \
+                (vout.size() == 2 && vout[0].nValue.second > 0 && \
+                vout[1].nValue.first == 0 && vout[1].nValue.second == 0 && \
+                vout[1].scriptPubKey.size() >= 1 && vout[1].scriptPubKey[0] == OP_RETURN && \
+                vout[1].scriptPubKey.IsPushOnly(vout[1].scriptPubKey.begin()+1))));
     }
 
     friend bool operator==(const CTransaction& a, const CTransaction& b)
@@ -310,5 +305,29 @@ struct CMutableTransaction
      */
     uint256 GetHash() const;
 };
+# if 0
+struct IssueCert {
+    int32_t nVersion;
+    uint160 keyid;
+    uint32_t asset_id;
+    int64_t shares;
+    std::vector<char> asset_name;
+    std::vector<char> asset_description;
+
+    ADD_SERIALIZE_METHODS;
+
+    template <typename Stream, typename Operation>
+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {
+        READWRITE(this->nVersion);
+        nVersion = this->nVersion;
+        READWRITE(keyid);
+        READWRITE(asset_id);
+        READWRITE(shares);
+        READWRITE(asset_name);
+        READWRITE(asset_description);
+    }
+
+};
+#endif
 
 #endif // BITCOIN_PRIMITIVES_TRANSACTION_H
diff --git a/src/rpcblockchain.cpp b/src/rpcblockchain.cpp
index f0bcafafe..ad4a7747c 100644
--- a/src/rpcblockchain.cpp
+++ b/src/rpcblockchain.cpp
@@ -28,6 +28,7 @@ using namespace std;
 extern void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry);
 void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);
 
+#if 0
 double GetDifficulty(const CBlockIndex* blockindex)
 {
     // Floating point number that is a multiple of the minimum difficulty,
@@ -58,6 +59,7 @@ double GetDifficulty(const CBlockIndex* blockindex)
 
     return dDiff;
 }
+#endif
 
 UniValue blockheaderToJSON(const CBlockIndex* blockindex)
 {
@@ -70,13 +72,12 @@ UniValue blockheaderToJSON(const CBlockIndex* blockindex)
     result.push_back(Pair("confirmations", confirmations));
     result.push_back(Pair("height", blockindex->nHeight));
     result.push_back(Pair("version", blockindex->nVersion));
+    result.push_back(Pair("rootheight", blockindex->nRootHeight));
+    result.push_back(Pair("operatorheight", blockindex->nOperatorHeight));
+    result.push_back(Pair("chainstakeseconds", blockindex->nChainStakeSeconds));
     result.push_back(Pair("merkleroot", blockindex->hashMerkleRoot.GetHex()));
     result.push_back(Pair("time", (int64_t)blockindex->nTime));
     result.push_back(Pair("mediantime", (int64_t)blockindex->GetMedianTimePast()));
-    result.push_back(Pair("nonce", (uint64_t)blockindex->nNonce));
-    result.push_back(Pair("bits", strprintf("%08x", blockindex->nBits)));
-    result.push_back(Pair("difficulty", GetDifficulty(blockindex)));
-    result.push_back(Pair("chainwork", blockindex->nChainWork.GetHex()));
 
     if (blockindex->pprev)
         result.push_back(Pair("previousblockhash", blockindex->pprev->GetBlockHash().GetHex()));
@@ -98,6 +99,9 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool tx
     result.push_back(Pair("size", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION)));
     result.push_back(Pair("height", blockindex->nHeight));
     result.push_back(Pair("version", block.nVersion));
+    result.push_back(Pair("rootheight", block.nRootHeight));
+    result.push_back(Pair("operatorheight", block.nOperatorHeight));
+    result.push_back(Pair("chainstakeseconds", block.nChainStakeSeconds));
     result.push_back(Pair("merkleroot", block.hashMerkleRoot.GetHex()));
     UniValue txs(UniValue::VARR);
     BOOST_FOREACH(const CTransaction&tx, block.vtx)
@@ -114,10 +118,10 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool tx
     result.push_back(Pair("tx", txs));
     result.push_back(Pair("time", block.GetBlockTime()));
     result.push_back(Pair("mediantime", (int64_t)blockindex->GetMedianTimePast()));
-    result.push_back(Pair("nonce", (uint64_t)block.nNonce));
-    result.push_back(Pair("bits", strprintf("%08x", block.nBits)));
-    result.push_back(Pair("difficulty", GetDifficulty(blockindex)));
-    result.push_back(Pair("chainwork", blockindex->nChainWork.GetHex()));
+    //result.push_back(Pair("nonce", (uint64_t)block.nNonce));
+    //result.push_back(Pair("bits", strprintf("%08x", block.nBits)));
+    //result.push_back(Pair("difficulty", GetDifficulty(blockindex)));
+    //result.push_back(Pair("chainwork", blockindex->nChainWork.GetHex()));
 
     if (blockindex->pprev)
         result.push_back(Pair("previousblockhash", blockindex->pprev->GetBlockHash().GetHex()));
@@ -161,6 +165,7 @@ UniValue getbestblockhash(const UniValue& params, bool fHelp)
     return chainActive.Tip()->GetBlockHash().GetHex();
 }
 
+#if 0
 UniValue getdifficulty(const UniValue& params, bool fHelp)
 {
     if (fHelp || params.size() != 0)
@@ -177,6 +182,7 @@ UniValue getdifficulty(const UniValue& params, bool fHelp)
     LOCK(cs_main);
     return GetDifficulty();
 }
+#endif
 
 UniValue mempoolToJSON(bool fVerbose = false)
 {
@@ -189,15 +195,10 @@ UniValue mempoolToJSON(bool fVerbose = false)
             const uint256& hash = e.GetTx().GetHash();
             UniValue info(UniValue::VOBJ);
             info.push_back(Pair("size", (int)e.GetTxSize()));
-            info.push_back(Pair("fee", ValueFromAmount(e.GetFee())));
-            info.push_back(Pair("modifiedfee", ValueFromAmount(e.GetModifiedFee())));
             info.push_back(Pair("time", e.GetTime()));
             info.push_back(Pair("height", (int)e.GetHeight()));
-            info.push_back(Pair("startingpriority", e.GetPriority(e.GetHeight())));
-            info.push_back(Pair("currentpriority", e.GetPriority(chainActive.Height())));
             info.push_back(Pair("descendantcount", e.GetCountWithDescendants()));
             info.push_back(Pair("descendantsize", e.GetSizeWithDescendants()));
-            info.push_back(Pair("descendantfees", e.GetModFeesWithDescendants()));
             const CTransaction& tx = e.GetTx();
             set<string> setDepends;
             BOOST_FOREACH(const CTxIn& txin, tx.vin)
@@ -247,15 +248,10 @@ UniValue getrawmempool(const UniValue& params, bool fHelp)
             "{                           (json object)\n"
             "  \"transactionid\" : {       (json object)\n"
             "    \"size\" : n,             (numeric) transaction size in bytes\n"
-            "    \"fee\" : n,              (numeric) transaction fee in " + CURRENCY_UNIT + "\n"
-            "    \"modifiedfee\" : n,      (numeric) transaction fee with fee deltas used for mining priority\n"
             "    \"time\" : n,             (numeric) local time transaction entered pool in seconds since 1 Jan 1970 GMT\n"
             "    \"height\" : n,           (numeric) block height when transaction entered pool\n"
-            "    \"startingpriority\" : n, (numeric) priority when transaction entered pool\n"
-            "    \"currentpriority\" : n,  (numeric) transaction priority now\n"
             "    \"descendantcount\" : n,  (numeric) number of in-mempool descendant transactions (including this one)\n"
             "    \"descendantsize\" : n,   (numeric) size of in-mempool descendants (including this one)\n"
-            "    \"descendantfees\" : n,   (numeric) modified fees (see above) of in-mempool descendants (including this one)\n"
             "    \"depends\" : [           (array) unconfirmed transactions used as inputs for this transaction\n"
             "        \"transactionid\",    (string) parent transaction id\n"
             "       ... ]\n"
@@ -316,15 +312,14 @@ UniValue getblockheader(const UniValue& params, bool fHelp)
             "  \"confirmations\" : n,   (numeric) The number of confirmations, or -1 if the block is not on the main chain\n"
             "  \"height\" : n,          (numeric) The block height or index\n"
             "  \"version\" : n,         (numeric) The block version\n"
+            "  \"rootheight\" : n,      (numeric) The root block height on this chain\n"
+            "  \"operatorheight\" : n,  (numeric) The operator block height on this chain\n"
+            "  \"chainstakeseconds\" : n, (numeric) The total POS stake seconds of this chain\n"
             "  \"merkleroot\" : \"xxxx\", (string) The merkle root\n"
             "  \"time\" : ttt,          (numeric) The block time in seconds since epoch (Jan 1 1970 GMT)\n"
             "  \"mediantime\" : ttt,    (numeric) The median block time in seconds since epoch (Jan 1 1970 GMT)\n"
-            "  \"nonce\" : n,           (numeric) The nonce\n"
-            "  \"bits\" : \"1d00ffff\", (string) The bits\n"
-            "  \"difficulty\" : x.xxx,  (numeric) The difficulty\n"
             "  \"previousblockhash\" : \"hash\",  (string) The hash of the previous block\n"
-            "  \"nextblockhash\" : \"hash\",      (string) The hash of the next block\n"
-            "  \"chainwork\" : \"0000...1f3\"     (string) Expected number of hashes required to produce the current chain (in hex)\n"
+            "  \"nextblockhash\" : \"hash\"       (string) The hash of the next block\n"
             "}\n"
             "\nResult (for verbose=false):\n"
             "\"data\"             (string) A string that is serialized, hex-encoded data for block 'hash'.\n"
@@ -375,6 +370,9 @@ UniValue getblock(const UniValue& params, bool fHelp)
             "  \"size\" : n,            (numeric) The block size\n"
             "  \"height\" : n,          (numeric) The block height or index\n"
             "  \"version\" : n,         (numeric) The block version\n"
+            "  \"rootheight\" : n,      (numeric) The root block height on this chain\n"
+            "  \"operatorheight\" : n,  (numeric) The operator block height on this chain\n"
+            "  \"chainstakeseconds\" : n, (numeric) The total POS stake seconds of this chain\n"
             "  \"merkleroot\" : \"xxxx\", (string) The merkle root\n"
             "  \"tx\" : [               (array of string) The transaction ids\n"
             "     \"transactionid\"     (string) The transaction id\n"
@@ -382,10 +380,6 @@ UniValue getblock(const UniValue& params, bool fHelp)
             "  ],\n"
             "  \"time\" : ttt,          (numeric) The block time in seconds since epoch (Jan 1 1970 GMT)\n"
             "  \"mediantime\" : ttt,    (numeric) The median block time in seconds since epoch (Jan 1 1970 GMT)\n"
-            "  \"nonce\" : n,           (numeric) The nonce\n"
-            "  \"bits\" : \"1d00ffff\", (string) The bits\n"
-            "  \"difficulty\" : x.xxx,  (numeric) The difficulty\n"
-            "  \"chainwork\" : \"xxxx\",  (string) Expected number of hashes required to produce the chain up to this block (in hex)\n"
             "  \"previousblockhash\" : \"hash\",  (string) The hash of the previous block\n"
             "  \"nextblockhash\" : \"hash\"       (string) The hash of the next block\n"
             "}\n"
@@ -425,7 +419,7 @@ UniValue getblock(const UniValue& params, bool fHelp)
         return strHex;
     }
 
-    return blockToJSON(block, pblockindex);
+    return blockToJSON(block, pblockindex, true);
 }
 
 UniValue gettxoutsetinfo(const UniValue& params, bool fHelp)
@@ -480,7 +474,7 @@ UniValue gettxout(const UniValue& params, bool fHelp)
             "{\n"
             "  \"bestblock\" : \"hash\",    (string) the block hash\n"
             "  \"confirmations\" : n,       (numeric) The number of confirmations\n"
-            "  \"value\" : x.xxx,           (numeric) The transaction value in " + CURRENCY_UNIT + "\n"
+            "  \"value\" : xxxx,           (numeric) The transaction value in \n"
             "  \"scriptPubKey\" : {         (json object)\n"
             "     \"asm\" : \"code\",       (string) \n"
             "     \"hex\" : \"hex\",        (string) \n"
@@ -668,10 +662,10 @@ UniValue getblockchaininfo(const UniValue& params, bool fHelp)
     obj.push_back(Pair("blocks",                (int)chainActive.Height()));
     obj.push_back(Pair("headers",               pindexBestHeader ? pindexBestHeader->nHeight : -1));
     obj.push_back(Pair("bestblockhash",         chainActive.Tip()->GetBlockHash().GetHex()));
-    obj.push_back(Pair("difficulty",            (double)GetDifficulty()));
+    //obj.push_back(Pair("difficulty",            (double)GetDifficulty()));
     obj.push_back(Pair("mediantime",            (int64_t)chainActive.Tip()->GetMedianTimePast()));
     obj.push_back(Pair("verificationprogress",  Checkpoints::GuessVerificationProgress(Params().Checkpoints(), chainActive.Tip())));
-    obj.push_back(Pair("chainwork",             chainActive.Tip()->nChainWork.GetHex()));
+    //obj.push_back(Pair("chainwork",             chainActive.Tip()->nChainWork.GetHex()));
     obj.push_back(Pair("pruned",                fPruneMode));
 
     const Consensus::Params& consensusParams = Params().GetConsensus();
@@ -809,7 +803,6 @@ UniValue mempoolInfoToJSON()
     ret.push_back(Pair("usage", (int64_t) mempool.DynamicMemoryUsage()));
     size_t maxmempool = GetArg("-maxmempool", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;
     ret.push_back(Pair("maxmempool", (int64_t) maxmempool));
-    ret.push_back(Pair("mempoolminfee", ValueFromAmount(mempool.GetMinFee(maxmempool).GetFeePerK())));
 
     return ret;
 }
@@ -826,7 +819,6 @@ UniValue getmempoolinfo(const UniValue& params, bool fHelp)
             "  \"bytes\": xxxxx,              (numeric) Sum of all tx sizes\n"
             "  \"usage\": xxxxx,              (numeric) Total memory usage for the mempool\n"
             "  \"maxmempool\": xxxxx,         (numeric) Maximum memory usage for the mempool\n"
-            "  \"mempoolminfee\": xxxxx       (numeric) Minimum fee for tx to be accepted\n"
             "}\n"
             "\nExamples:\n"
             + HelpExampleCli("getmempoolinfo", "")
diff --git a/src/rpcbooking.cpp b/src/rpcbooking.cpp
new file mode 100644
index 000000000..aceb93283
--- /dev/null
+++ b/src/rpcbooking.cpp
@@ -0,0 +1,1178 @@
+// Copyright (c) 2010 Satoshi Nakamoto
+// Copyright (c) 2009-2015 The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include "amount.h"
+#include "chain.h"
+#include "chainparams.h"
+#include "consensus/consensus.h"
+#include "consensus/validation.h"
+#include "core_io.h"
+#include "init.h"
+#include "main.h"
+#include "booker.h"
+#include "net.h"
+#include "rpcserver.h"
+#include "txmempool.h"
+#include "util.h"
+#include "utilstrencodings.h"
+#include "validationinterface.h"
+
+#include <stdint.h>
+#include <stdio.h>
+#include <base58.h>
+#include "consensus/merkle.h"
+
+#include <boost/assign/list_of.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include <univalue.h>
+
+using namespace std;
+
+UniValue getgenerate(const UniValue& params, bool fHelp)
+{
+    if (fHelp || params.size() != 0)
+        throw runtime_error(
+            "getgenerate\n"
+            "\nReturn if the server is set to generate coins or not. The default is false.\n"
+            "It is set with the command line argument -gen (or " + std::string(BITCOIN_CONF_FILENAME) + " setting gen)\n"
+            "It can also be set with the setgenerate call.\n"
+            "\nResult\n"
+            "true|false      (boolean) If the server is set to generate coins or not\n"
+            "\nExamples:\n"
+            + HelpExampleCli("getgenerate", "")
+            + HelpExampleRpc("getgenerate", "")
+        );
+
+    LOCK(cs_main);
+    return GetBoolArg("-gen", DEFAULT_GENERATE);
+}
+
+UniValue setgenerate(const UniValue& params, bool fHelp)
+{
+    if (fHelp || params.size() < 1 || params.size() > 2)
+        throw runtime_error(
+            "setgenerate generate ( genproclimit )\n"
+            "\nSet 'generate' true or false to turn generation on or off.\n"
+            "Generation is limited to 'genproclimit' processors, -1 is unlimited.\n"
+            "See the getgenerate call for the current setting.\n"
+            "\nArguments:\n"
+            "1. generate         (boolean, required) Set to true to turn on generation, off to turn off.\n"
+            "2. genproclimit     (numeric, optional) Set the processor limit for when generation is on. Can be -1 for unlimited.\n"
+            "\nExamples:\n"
+            "\nSet the generation on with a limit of one processor\n"
+            + HelpExampleCli("setgenerate", "true 1") +
+            "\nCheck the setting\n"
+            + HelpExampleCli("getgenerate", "") +
+            "\nTurn off generation\n"
+            + HelpExampleCli("setgenerate", "false") +
+            "\nUsing json rpc\n"
+            + HelpExampleRpc("setgenerate", "true, 1")
+        );
+
+    if (Params().MineBlocksOnDemand())
+        throw JSONRPCError(RPC_METHOD_NOT_FOUND, "Use the generate method instead of setgenerate on this network");
+
+    bool fGenerate = true;
+    if (params.size() > 0)
+        fGenerate = params[0].get_bool();
+
+    int nGenProcLimit = GetArg("-genproclimit", DEFAULT_GENERATE_THREADS);
+    if (params.size() > 1)
+    {
+        nGenProcLimit = params[1].get_int();
+        if (nGenProcLimit == 0)
+            fGenerate = false;
+    }
+
+    mapArgs["-gen"] = (fGenerate ? "1" : "0");
+    mapArgs ["-genproclimit"] = itostr(nGenProcLimit);
+    GenerateBitcoins(fGenerate, nGenProcLimit, Params());
+
+    return NullUniValue;
+}
+
+UniValue getmininginfo(const UniValue& params, bool fHelp)
+{
+    if (fHelp || params.size() != 0)
+        throw runtime_error(
+            "getmininginfo\n"
+            "\nReturns a json object containing mining-related information."
+            "\nResult:\n"
+            "{\n"
+            "  \"blocks\": nnn,             (numeric) The current block\n"
+            "  \"currentblocksize\": nnn,   (numeric) The last block size\n"
+            "  \"currentblocktx\": nnn,     (numeric) The last block transaction\n"
+            "  \"difficulty\": xxx.xxxxx    (numeric) The current difficulty\n"
+            "  \"errors\": \"...\"          (string) Current errors\n"
+            "  \"generate\": true|false     (boolean) If the generation is on or off (see getgenerate or setgenerate calls)\n"
+            "  \"genproclimit\": n          (numeric) The processor limit for generation. -1 if no generation. (see getgenerate or setgenerate calls)\n"
+            "  \"pooledtx\": n              (numeric) The size of the mem pool\n"
+            "  \"testnet\": true|false      (boolean) If using testnet or not\n"
+            "  \"chain\": \"xxxx\",         (string) current network name as defined in BIP70 (main, test, regtest)\n"
+            "}\n"
+            "\nExamples:\n"
+            + HelpExampleCli("getmininginfo", "")
+            + HelpExampleRpc("getmininginfo", "")
+        );
+
+
+    LOCK(cs_main);
+
+    UniValue obj(UniValue::VOBJ);
+    obj.push_back(Pair("blocks",           (int)chainActive.Height()));
+    obj.push_back(Pair("currentblocksize", (uint64_t)nLastBlockSize));
+    obj.push_back(Pair("currentblocktx",   (uint64_t)nLastBlockTx));
+    //obj.push_back(Pair("difficulty",       (double)GetDifficulty()));
+    obj.push_back(Pair("errors",           GetWarnings("statusbar")));
+    obj.push_back(Pair("genproclimit",     (int)GetArg("-genproclimit", DEFAULT_GENERATE_THREADS)));
+    // obj.push_back(Pair("networkhashps",    getnetworkhashps(params, false)));
+    obj.push_back(Pair("pooledtx",         (uint64_t)mempool.size()));
+    obj.push_back(Pair("testnet",          Params().TestnetToBeDeprecatedFieldRPC()));
+    obj.push_back(Pair("chain",            Params().NetworkIDString()));
+    obj.push_back(Pair("generate",         getgenerate(params, false)));
+    return obj;
+}
+
+
+// NOTE: Assumes a conclusive result; if result is inconclusive, it must be handled by caller
+static UniValue BIP22ValidationResult(const CValidationState& state)
+{
+    if (state.IsValid())
+        return NullUniValue;
+
+    std::string strRejectReason = state.GetRejectReason();
+    if (state.IsError())
+        throw JSONRPCError(RPC_VERIFY_ERROR, strRejectReason);
+    if (state.IsInvalid())
+    {
+        if (strRejectReason.empty())
+            return "rejected";
+        return strRejectReason;
+    }
+    // Should be impossible
+    return "valid?";
+}
+
+namespace {
+string ExecProgram(const string& exec)
+{
+
+#define BUFFER_SIZE 1000
+    FILE *in;
+    char buff[BUFFER_SIZE];
+
+    string sRet;
+ 
+    if(!(in = popen(exec.c_str(), "r"))){
+        return sRet;
+    }
+ 
+    size_t readlen;
+    
+    while((readlen = fread((void*)buff, 1, BUFFER_SIZE, in)) != 0) {
+        sRet.append(buff, readlen);
+    }
+
+    pclose(in);
+
+    return sRet;
+}
+
+vector<unsigned char> OperatorGetNextID(const string& exe) { 
+    vector<unsigned char> vRet;
+
+    string exec = exe;
+    exec.append(" --getnextid");
+
+    // The signing program will return the next operator public key hash id encoded by base58 with checksum
+    string sBinary = ExecProgram(exec);
+
+    DecodeBase58Check(sBinary, vRet);
+    
+    return vRet;
+}
+
+bool OperatorSignHash(const string& exe, const uint160& idOperator, const uint256& hash, vector<unsigned char>& vSignature) {
+    string exec = exe;
+
+    exec.append(" --hash=");
+    exec.append(EncodeBase58Check(vector<unsigned char>(hash.begin(), hash.end())));
+
+    exec.append(" --operatorid=");
+    exec.append(EncodeBase58Check(vector<unsigned char>(idOperator.begin(), idOperator.end())));
+
+    // The signing program will return the public key of current operator id and the hash signature, joined by delimiter "<-PUBKEY.HASH->"
+    string sBinary = ExecProgram(exec);
+
+    if (!DecodeBase58Check(sBinary, vSignature)) return false;
+
+    return true;
+}
+
+// The signing program will return the script binary corresponding to id
+vector<unsigned char> OperatorGetScript(const string& exe, const uint160 id) { 
+    vector<unsigned char> vRet;
+
+    string exec = exe;
+    exec.append(" --operatorid=");
+    exec.append(EncodeBase58Check(vector<unsigned char>(id.begin(), id.end())));
+
+    string sBinary = ExecProgram(exec);
+
+    if (DecodeBase58Check(sBinary, vRet)) {
+        // Check binary returned matches id
+        if (id != Hash160(vRet.begin(), vRet.end()))
+            vRet.clear();
+    }
+    
+    return vRet;
+}
+
+}
+
+// Operator action does authorization of user ids, changing pos time weighting curve, at the same time refreshes the operator public key id
+UniValue operatoraction(const UniValue& params, bool fHelp) {
+
+    if (fHelp || params.size() != 1 )
+        throw runtime_error(
+
+            "operatoraction {\"signprogram\":\"path_to_signing_program\",\"auth\":[\"id0\", ...], \"revoke\":[\"id0\", ...],\"posdecay\":[\"point0\", \"weight0\", ...] }" 
+            "\nTry to do an operational action to the block chain.\n"
+            "Returns the hash of the new priviledged block.\n"
+            "\nArgument:\n"
+            "\"operation\"        A json object\n"
+            "   {\n"
+            "       \"signprogram\":\"path_to_signing_program\", (string required) the external program for signing transaction and block\n"
+            "       \"auth\":[\"id0\", ...], (array of address, optional) addresses to authorize\n"
+            "       \"revoke\":[\"id0\", ...], (array of address, optional) addresses to revoke\n"
+            "       \"posdecay\":[\"point0\", \"weight0\"...], (array of integers, optional) set time weighting curve for POS\n"
+            "   }\n" 
+            "\nResult:\n"
+            "\"block hash\"            (string) hex string of the new block hash\n"
+
+            "\nExamples\n"
+            + HelpExampleCli("operatoraction", "\"{\\\"signprogram\\\":\\\"path_to_signing_program\\\"}\"")
+        );
+
+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VOBJ), false);
+    // RPCTypeCheck(params, boost::assign::list_of(UniValue::VNUM)(UniValue::VNUM), false);
+
+    // ostringstream stringStream;
+
+    // stringStream << "first num: " << params[0].get_int() << "second num: " << params[1].get_int();
+    // stringStream << "first num: " << params[0].get_str() << " second num: " << params[1].get_str();
+    
+    // throw JSONRPCError(RPC_INVALID_PARAMETER, stringStream.str());
+
+    UniValue operation = params[0].get_obj();
+    UniValue obj = find_value(operation, "signprogram");
+
+    if (!obj.isStr())
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, missing signprogram key");
+    string signProgram = obj.get_str();
+
+    set<suint160> sIdAuthorized;
+    set<suint160> sIdRevoked;
+    vector<uint32_t> vPosDecay;
+
+    obj = find_value(operation, "auth");
+    if (obj.isArray()) {
+        for (unsigned int idx = 0; idx < obj.size(); idx++) {
+            if(!obj[idx].isStr()) continue;
+
+            CBitcoinAddress address(obj[idx].get_str());
+            if (!address.IsValid()) continue;
+
+            sIdAuthorized.insert(make_pair(address.IsScript(), address.GetID()));
+        }
+    }
+    else if (!obj.isNull()) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, authorized ids is not an array");
+    }
+
+    obj = find_value(operation, "revoke");
+    if (obj.isArray()) {
+        for (unsigned int idx = 0; idx < obj.size(); idx++) {
+            if(!obj[idx].isStr()) continue;
+
+            CBitcoinAddress address(obj[idx].get_str());
+            if (!address.IsValid()) continue;
+
+            sIdRevoked.insert(make_pair(address.IsScript(), address.GetID()));
+        }
+    }
+    else if (!obj.isNull()) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, de-authorized ids is not an array");
+    }
+
+    obj = find_value(operation, "posdecay");
+    if (obj.isArray()) {
+        for (unsigned int idx = 0; idx < obj.size(); idx++) {
+            if(!obj[idx].isNum()) continue;
+
+            vPosDecay.push_back((uint32_t)obj[idx].get_int());
+        }
+    }
+    else if (!obj.isNull()) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, posdecay is not an array");
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////////////
+    LOCK(cs_main);
+
+    // Update block
+    CBlockIndex* tip = chainActive.Tip();
+
+    auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlock(Params(), true));
+
+    if (!pblocktemplate.get())
+        throw JSONRPCError(RPC_OUT_OF_MEMORY, "Out of memory");
+
+    CBlock* pblock = &pblocktemplate->block; // pointer for convenience
+
+    pblock->nRootHeight = tip->nRootHeight;
+    pblock->nOperatorHeight = tip->nHeight + 1;
+    pblock->nChainStakeSeconds = tip->nChainStakeSeconds;
+
+    // Create priviledged transaction
+    CMutableTransaction txNew;
+
+    txNew.nLockTime = chainActive.Height();
+
+    txNew.vin.resize(1);
+    txNew.vout.clear();
+
+    txNew.vin[0].prevout.SetNull();
+
+    int nOperatorHeight = tip->nOperatorHeight;
+    int nRootHeight = tip->nRootHeight;
+
+    while (nRootHeight > nOperatorHeight) {
+        if (chainActive[nRootHeight]->WithData(BLOCK_OPERATOR)) {
+            nOperatorHeight = nRootHeight;
+            break;
+        }
+        nRootHeight = chainActive[nRootHeight]->pprev->nRootHeight;
+    }
+
+    const uint160 *idNextOperator = chainActive[nOperatorHeight]->idNextOperatorPubKey;
+
+    vector<unsigned char> vBinary;
+
+    // The signing program will return the next operator id
+    vBinary = OperatorGetNextID(signProgram);
+
+    if (vBinary.size() != 20)
+        throw JSONRPCError(RPC_OUT_OF_MEMORY, "Sign program: failed to get next operater id");
+
+    CScript scriptAuth = CScript() << OP_RETURN << vBinary;
+
+    if (!sIdAuthorized.empty()) {
+        vBinary.clear();
+        vBinary.push_back((unsigned char)OP_AUTH_TRANS_IDS);
+
+        BOOST_FOREACH(const suint160& id, sIdAuthorized) {
+            vBinary.push_back(id.first ? '\x05' : '\x00');
+            vBinary.insert(vBinary.end(), id.second.begin(), id.second.end());
+        }
+
+        scriptAuth << vBinary;
+    }
+
+    if (!sIdRevoked.empty()) {
+        vBinary.clear();
+        vBinary.push_back((unsigned char)OP_DEAUTH_TRANS_IDS);
+
+        BOOST_FOREACH(const suint160& id, sIdRevoked) {
+            vBinary.push_back(id.first);
+            vBinary.insert(vBinary.end(), id.second.begin(), id.second.end());
+        }
+
+        scriptAuth << vBinary;
+    }
+
+
+    if (!vPosDecay.empty()) {
+        vBinary.clear();
+        vBinary.push_back((unsigned char)OP_CURVE_DECAYING);
+
+        BOOST_FOREACH(uint32_t& num, vPosDecay) {
+            for (int i = 0; i < 4; num>>=8, i++)
+                vBinary.push_back((unsigned char)num&0xff);
+        }
+
+        scriptAuth << vBinary;
+    }
+
+    txNew.vout.push_back(CTxOut(make_pair(0, 0), scriptAuth));
+
+    const CTransaction tx(txNew);
+
+    const CScript operatorRedeemScript = GetScriptForDestination(CKeyID(*idNextOperator));
+
+    uint256 hash = SignatureHash(operatorRedeemScript, tx, 0, SIGHASH_ALL);
+
+    vector<unsigned char> vSignature;
+
+    if (!OperatorSignHash(signProgram, *idNextOperator, hash, vSignature)) goto signerror;
+
+    txNew.vin[0].scriptSig = CScript(vSignature.begin(), vSignature.end());
+    
+    goto signblock;
+
+signerror:
+    throw JSONRPCError(RPC_OUT_OF_MEMORY, "Sign program: failed to sign priviledged transaction");
+
+signblock:
+    
+    pblock->vtx[0] = CTransaction(txNew);
+    pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);
+
+
+    txNew.vout[0].scriptPubKey = CScript() << OP_RETURN << ToByteVector(pblock->GetHash());
+
+    CTransaction ctx(txNew);
+
+    hash = SignatureHash(operatorRedeemScript, ctx, 0, SIGHASH_ALL);
+
+    if (!OperatorSignHash(signProgram, *idNextOperator, hash, vSignature))
+        throw JSONRPCError(RPC_OUT_OF_MEMORY, "Sign program: failed to sign priviledged block");
+
+    pblock->vchBlockSig = CScript(vSignature.begin(), vSignature.end());
+
+    // Dump last element to trash box to avoid redundance
+    pblock->vchBlockSig >> vSignature;
+
+    CValidationState state;
+    if (!TestBlockValidity(state, Params(), *pblock, tip)) {
+        throw std::runtime_error(strprintf("%s: TestBlockValidity failed: %s", __func__, FormatStateMessage(state)));
+    }
+
+    if (!ProcessNewBlock(state, Params(), NULL, pblock, true, NULL)) {
+        throw JSONRPCError(RPC_OUT_OF_MEMORY, "Failed to add priviledged block to chain");
+    }
+
+    return UniValue(UniValue::VSTR, pblock->GetHash().ToString());
+
+}
+
+// Root action assigns a new operator id, or issue an asset , at the same time refresh the root script id
+UniValue rootaction(const UniValue& params, bool fHelp) {
+
+    if (fHelp || params.size() != 1 )
+        throw runtime_error(
+            "rootaction {\"signprogram\":\"path_to_signing_program\", \"operatorid\":\"base58_checked_operator_id\",\"issue\":{\"id\":\"asset_id\", \"shares\":\"shares_issued\"},\"wizardid\":\"base58_checked_wizard_id\"}" 
+
+            "\nTry to do a root action to the block chain.\n"
+            "Returns the hash of the new priviledged block.\n"
+            "\nArgument:\n"
+            "\"operation\"        A json object\n"
+            "   {\n"
+            "       \"signprogram\":\"path_to_signing_program\", (string, required) the external program for signing transaction and block\n"
+            "       \"operatorid\":\"base58_checked_operator_id\", (string, required) new operator public key id\n"
+            "       \"wizardid\":\"base58_checked_wizard_id\", (string, required) new wizard script id\n"
+            "       \"issue\":{\"id\":\"asset_id\", \"shares\":\"shares_issued\", \"address\":\"issuer_address\", \"sigs\":[\"sig0\", ...]}, ((int, int, address, sigatures(optional))json object optional) the id, shares, issuer address and base58 checked signatures of credit providers of a new asset to issue\n"
+            "   }\n" 
+            "\nResult:\n"
+            "\"block hash\"            (string) hex string of the new block hash\n"
+
+            "\nExamples\n"
+            + HelpExampleCli("rootaction", "\"{\\\"signprogram\\\":\\\"path_to_signing_program\\\"}\"")
+        );
+
+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VOBJ), false);
+
+    UniValue operation = params[0].get_obj();
+
+    UniValue obj = find_value(operation, "signprogram");
+    if (!obj.isStr())
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, missing signprogram key");
+    string signProgram = obj.get_str();
+
+    vector<unsigned char> vNewOperator;
+    CTxDestination destIssuer;
+    uint32_t asset_id = 0;
+    int64_t shares = -1;
+    vector<vector<unsigned char> > vCreditorSignature;
+    vector<unsigned char> vNewWizard;
+
+    obj = find_value(operation, "operatorid");
+
+    if (obj.isStr()) {
+        string sNewOperator = obj.get_str();
+        if (!DecodeBase58Check(sNewOperator, vNewOperator) || vNewOperator.size() != 20) {
+            vNewOperator.clear();
+        }
+    }
+
+    obj = find_value(operation, "issue");
+
+    if (obj.isObject()) {
+        try {
+            asset_id = (uint32_t)obj["id"].get_int();
+        }
+        catch(...) {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, no 32-bit asset id is provided.");
+        }
+
+        try {
+            shares = obj["shares"].get_int64();
+        }
+        catch(...) {
+            shares = -1;
+        }
+
+        if (shares > 0) {
+            try {
+                CBitcoinAddress address(obj["address"].get_str());
+                if (!address.IsValid())
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, no valid issuer address is provided.");
+                destIssuer = address.Get();
+            }
+            catch(...) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, no valid issuer address is provided.");
+            }
+        }
+
+        obj = find_value(obj, "sigs");
+        if (obj.isArray()) {
+            for (unsigned int idx = 0; idx < obj.size(); idx++) {
+                if(!obj[idx].isStr()) continue;
+
+                vector<unsigned char> vSig;
+
+                if (DecodeBase58Check(obj[idx].get_str(), vSig)) {
+                    vCreditorSignature.push_back(vSig);
+                }
+                else
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, invalid base58 checked signature");
+            }
+        }
+    }
+    else if (!obj.isNull())
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, issue info is not an object");
+
+    obj = find_value(operation, "wizardid");
+
+    if (obj.isStr()) {
+        string sNewWizard = obj.get_str();
+
+        if (!DecodeBase58Check(sNewWizard, vNewWizard) || vNewWizard.size() != 20)
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, missing valid new wizard id");
+    }
+    else if (!obj.isNull()) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, new wizard id is not a string");
+    }
+
+    //////////////////////////////////////////////////////////////////////////////////////////////
+    LOCK(cs_main);
+
+    // Update block
+    CBlockIndex* tip = chainActive.Tip();
+
+    auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlock(Params(), true));
+
+    if (!pblocktemplate.get())
+        throw JSONRPCError(RPC_OUT_OF_MEMORY, "Out of memory");
+
+    CBlock* pblock = &pblocktemplate->block; // pointer for convenience
+
+    pblock->nRootHeight = tip->nHeight + 1;
+    pblock->nOperatorHeight = tip->nOperatorHeight;
+    pblock->nChainStakeSeconds = tip->nChainStakeSeconds;
+
+    // Create priviledged transaction
+    CMutableTransaction txNew;
+
+    txNew.nLockTime = chainActive.Height();
+
+    txNew.vin.resize(1);
+    txNew.vout.clear();
+
+    txNew.vin[0].prevout.SetNull();
+
+    if (shares > 0) {
+        txNew.vout.push_back(CTxOut(make_pair(asset_id, shares), GetScriptForDestination(destIssuer)));
+    }
+
+    const uint160* idRoot = chainActive[tip->nRootHeight]->idNextRootScript;
+
+    vector<unsigned char> vNextRootID;
+
+    // The signing program will return the next root id
+    vNextRootID = OperatorGetNextID(signProgram);
+
+    // The signing program will return the script of the current root id
+    vector<unsigned char> vRootScript = OperatorGetScript(signProgram, *idRoot);
+
+    if (vRootScript.size() == 0)
+        throw JSONRPCError(RPC_OUT_OF_MEMORY, "Sign program: failed to root redeem script");
+
+    vector<unsigned char> vBinary;
+
+    CScript scriptAuth = CScript() << OP_RETURN << vNextRootID;
+
+    if (!vNewOperator.empty()) {
+        vBinary.clear();
+        vBinary.push_back((unsigned char)ROOT_ASSIGN_OPERATOR);
+
+        vBinary.insert(vBinary.end(), vNewOperator.begin(), vNewOperator.end());
+
+        scriptAuth << vBinary;
+    }
+
+    if (!vCreditorSignature.empty()) {
+        vBinary.clear();
+        vBinary.push_back((unsigned char)ROOT_CREDITING);
+
+        BOOST_FOREACH(vector<unsigned char>& vSig, vCreditorSignature) {
+            if (vSig.size() > 255)
+                throw JSONRPCError(RPC_INVALID_PARAMETER, "Signature too long");
+            vBinary.push_back((unsigned char)vSig.size());
+            vBinary.insert(vBinary.end(), vSig.begin(), vSig.end());
+        }
+
+        scriptAuth << vBinary;
+    }
+
+    if (vNewWizard.size() == 20) {
+        vBinary.clear();
+        vBinary.push_back((unsigned char)ROOT_ASSIGN_WIZARD);
+
+        vBinary.insert(vBinary.end(), vNewWizard.begin(), vNewWizard.end());
+
+        scriptAuth << vBinary;
+    }
+
+    txNew.vout.push_back(CTxOut(make_pair(shares <= 0 ? asset_id : 0, 0), scriptAuth));
+
+    const CTransaction tx(txNew);
+
+    const CScript rootRedeemScript(vRootScript.begin(), vRootScript.end());
+
+    uint256 hash = SignatureHash(rootRedeemScript, tx, 0, SIGHASH_ALL);
+
+    vector<unsigned char> vSignature;
+
+    if (!OperatorSignHash(signProgram, *idRoot, hash, vSignature)) goto signerror;
+
+    txNew.vin[0].scriptSig = CScript(vSignature.begin(), vSignature.end());
+    
+    goto signblock;
+
+signerror:
+    throw JSONRPCError(RPC_OUT_OF_MEMORY, "Sign program: failed to sign priviledged transaction");
+
+signblock:
+    
+    pblock->vtx[0] = CTransaction(txNew);
+    pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);
+
+
+    txNew.vout[0].scriptPubKey = CScript() << OP_RETURN << ToByteVector(pblock->GetHash());
+
+    CTransaction ctx(txNew);
+
+    hash = SignatureHash(rootRedeemScript, ctx, 0, SIGHASH_ALL);
+
+    if (!OperatorSignHash(signProgram, *idRoot, hash, vSignature))
+        throw JSONRPCError(RPC_OUT_OF_MEMORY, "Sign program: failed to sign priviledged block");
+
+    pblock->vchBlockSig = CScript(vSignature.begin(), vSignature.end());
+    // Dump last element to trash box to avoid redundance
+    pblock->vchBlockSig >> vSignature;
+
+    CValidationState state;
+    if (!TestBlockValidity(state, Params(), *pblock, tip)) {
+        throw std::runtime_error(strprintf("%s: TestBlockValidity failed: %s", __func__, FormatStateMessage(state)));
+    }
+
+    if (!ProcessNewBlock(state, Params(), NULL, pblock, true, NULL)) {
+        throw JSONRPCError(RPC_OUT_OF_MEMORY, "Failed to add priviledged block to chain");
+    }
+
+    return UniValue(UniValue::VSTR, pblock->GetHash().ToString());
+
+}
+
+// wizardtransfer "{\"wizardprogram\":\"path_to_wizard_program\", \"unspentlist\":[\"txid-vout\", \"txid-vout\", ...], \"target\":\"target_address\"}"
+UniValue wizardtransfer(const UniValue& params, bool fHelp)
+{
+
+    if (fHelp || params.size() != 1 )
+        throw runtime_error(
+
+            "wizardtransfer {\"wizardprogram\":\"path_to_wizard_program\", \"unspentlist\":[\"txid-vout\", \"txid-vout\", ...], \"target\":\"target_address\"}" 
+            "\nTry to transfer unspent list of an inactive(revoked) account to an active account.\n"
+            "Returns the hash of the new transaction.\n"
+            "\nArgument:\n"
+            "\"operation\"        A json object\n"
+            "   {\n"
+            "       \"wizardprogram\":\"path_to_wizard_program\", (string required) the external wizard program for signing transaction\n"
+            "       \"unspentlist\":[\"txid-vout\", \"txid-vout\"...], (array of txid and vout, required) list of unspent outputs to transfer\n"
+            "       \"target\":\"target_address\", (string, required) target address to transfer unspent amounts to\n"
+            "   }\n"
+            "\nResult:\n"
+            "\"Transaction hash\"            (string) hex string of the new transaction hash\n"
+
+            "\nExamples\n"
+            + HelpExampleCli("wizardtransfer", "\"{\\\"wizardprogram\\\":\\\"path_to_wizard_program\\\", ... ...}\"")
+        );
+
+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VOBJ), false);
+
+    UniValue operation = params[0].get_obj();
+    UniValue obj = find_value(operation, "wizardprogram");
+
+    if (!obj.isStr())
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, missing wizardprogram key");
+
+    string signProgram = obj.get_str();
+
+    CMutableTransaction txNew;
+    txNew.nLockTime = chainActive.Height();
+
+    if (GetRandInt(10) == 0)
+        txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100));
+
+    assert(txNew.nLockTime <= (unsigned int)chainActive.Height());
+    assert(txNew.nLockTime < LOCKTIME_THRESHOLD);
+
+    LOCK(cs_main);
+
+    CAmount am;
+    const CCoins* coins;
+
+    obj = find_value(operation, "unspentlist");
+    if (obj.isArray()) {
+        for (unsigned int idx = 0; idx < obj.size(); idx++) {
+            if(!obj[idx].isStr()) continue;
+
+            string sout = obj[idx].get_str();
+            // uint256 txid = uint256(ParseHex(sout.substr(0, 64)));
+            uint256 txid = uint256S(sout.substr(0, 64));
+            uint32_t i = atoi(sout.substr(65).c_str());
+
+            coins = pcoinsTip->AccessCoins(txid);
+            if (coins == NULL || coins->vout.size() <= i || coins->vout[i].nValue.second <= 0)
+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("unspent output %s not found.", sout));
+
+            am += coins->vout[i].nValue;
+
+            txNew.vin.push_back(CTxIn(txid, i, CScript(), std::numeric_limits<unsigned int>::max()-1));
+
+        }
+    }
+    else
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "No unspentlist supplied.");
+
+    obj = find_value(operation, "target");
+
+    if (obj.isStr()) {
+        CBitcoinAddress address(obj.get_str());
+        if (!address.IsValid())
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Target address invalid.");
+
+        BOOST_FOREACH(const CValue tgtval, am) {
+            if (tgtval.second > 0)
+                txNew.vout.push_back(CTxOut(tgtval, GetScriptForDestination(address.Get())));
+        }
+    }
+    else
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "No target address supplied.");
+
+    // Update block
+    const CTransaction tx(txNew);
+    CBlockIndex *bi = chainActive.Tip();
+    const uint160* pIdWizard = NULL;
+
+    // Iterate back through active chain for wizard id. Wizard transaction is rare, and thus no serious performance penalty.
+    while (bi) {
+        if (bi->nStatus & BLOCK_WIZARD) {
+            pIdWizard = bi->idNextWizardScript;
+            break;
+        }
+        bi = bi->pprev;
+    }
+
+    if (pIdWizard == NULL)
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "No wizard id on active chain.");
+
+    // The signing program will return the script of the current root id
+    vector<unsigned char> vWizardRedeemScript = OperatorGetScript(signProgram, *pIdWizard);
+
+    if (vWizardRedeemScript.size() == 0)
+        throw JSONRPCError(RPC_OUT_OF_MEMORY, "Sign program: failed to return wizard redeem script");
+
+    const CScript wizardRedeemScript(vWizardRedeemScript.begin(), vWizardRedeemScript.end());
+
+    for (size_t i = 0; i < tx.vin.size(); i++) {
+        uint256 hash = SignatureHash(wizardRedeemScript, tx, i, SIGHASH_ALL);
+
+        vector<unsigned char> vSignature;
+
+        if (!OperatorSignHash(signProgram, *pIdWizard, hash, vSignature))
+            throw JSONRPCError(RPC_OUT_OF_MEMORY, "Sign program: failed to sign signatures");
+
+        txNew.vin[i].scriptSig = CScript(vSignature.begin(), vSignature.end());
+    }
+    CTransaction ctx(txNew);
+
+    CValidationState state;
+
+    if (!::AcceptToMemoryPool(mempool, state, ctx, NULL, false))
+        throw JSONRPCError(RPC_OUT_OF_MEMORY, "Failed to add wizard transaction to memory pool.");
+
+    RelayTransaction(ctx);
+
+    return UniValue(UniValue::VSTR, ctx.GetHash().ToString());
+}
+
+UniValue getblocktemplate(const UniValue& params, bool fHelp)
+{
+    if (fHelp || params.size() > 1)
+        throw runtime_error(
+            "getblocktemplate ( \"jsonrequestobject\" )\n"
+            "\nIf the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.\n"
+            "It returns data needed to construct a block to work on.\n"
+            "See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\n"
+
+            "\nArguments:\n"
+            "1. \"jsonrequestobject\"       (string, optional) A json object in the following spec\n"
+            "     {\n"
+            "       \"mode\":\"template\"    (string, optional) This must be set to \"template\" or omitted\n"
+            "       \"capabilities\":[       (array, optional) A list of strings\n"
+            "           \"support\"           (string) client side supported feature, 'longpoll', 'coinbasetxn', 'coinbasevalue', 'proposal', 'serverlist', 'workid'\n"
+            "           ,...\n"
+            "         ]\n"
+            "     }\n"
+            "\n"
+
+            "\nResult:\n"
+            "{\n"
+            "  \"version\" : n,                    (numeric) The block version\n"
+            "  \"previousblockhash\" : \"xxxx\",    (string) The hash of current highest block\n"
+            "  \"transactions\" : [                (array) contents of non-coinbase transactions that should be included in the next block\n"
+            "      {\n"
+            "         \"data\" : \"xxxx\",          (string) transaction data encoded in hexadecimal (byte-for-byte)\n"
+            "         \"hash\" : \"xxxx\",          (string) hash/id encoded in little-endian hexadecimal\n"
+            "         \"depends\" : [              (array) array of numbers \n"
+            "             n                        (numeric) transactions before this one (by 1-based index in 'transactions' list) that must be present in the final block if this one is\n"
+            "             ,...\n"
+            "         ],\n"
+            "         \"sigops\" : n,               (numeric) total number of SigOps, as counted for purposes of block limits; if key is not present, sigop count is unknown and clients MUST NOT assume there aren't any\n"
+            "         \"required\" : true|false     (boolean) if provided and true, this transaction must be in the final block\n"
+            "      }\n"
+            "      ,...\n"
+            "  ],\n"
+            "  \"coinbaseaux\" : {                  (json object) data that should be included in the coinbase's scriptSig content\n"
+            "      \"flags\" : \"flags\"            (string) \n"
+            "  },\n"
+            "  \"coinbasevalue\" : n,               (numeric) maximum allowable input to coinbase transaction, including the generation award and transaction fees (in Satoshis)\n"
+            "  \"coinbasetxn\" : { ... },           (json object) information for coinbase transaction\n"
+            "  \"target\" : \"xxxx\",               (string) The hash target\n"
+            "  \"mintime\" : xxx,                   (numeric) The minimum timestamp appropriate for next block time in seconds since epoch (Jan 1 1970 GMT)\n"
+            "  \"mutable\" : [                      (array of string) list of ways the block template may be changed \n"
+            "     \"value\"                         (string) A way the block template may be changed, e.g. 'time', 'transactions', 'prevblock'\n"
+            "     ,...\n"
+            "  ],\n"
+            "  \"noncerange\" : \"00000000ffffffff\",   (string) A range of valid nonces\n"
+            "  \"sigoplimit\" : n,                 (numeric) limit of sigops in blocks\n"
+            "  \"sizelimit\" : n,                  (numeric) limit of block size\n"
+            "  \"curtime\" : ttt,                  (numeric) current timestamp in seconds since epoch (Jan 1 1970 GMT)\n"
+            "  \"bits\" : \"xxx\",                 (string) compressed target of next block\n"
+            "  \"height\" : n                      (numeric) The height of the next block\n"
+            "}\n"
+
+            "\nExamples:\n"
+            + HelpExampleCli("getblocktemplate", "")
+            + HelpExampleRpc("getblocktemplate", "")
+         );
+
+    LOCK(cs_main);
+
+    std::string strMode = "template";
+    UniValue lpval = NullUniValue;
+    if (params.size() > 0)
+    {
+        const UniValue& oparam = params[0].get_obj();
+        const UniValue& modeval = find_value(oparam, "mode");
+        if (modeval.isStr())
+            strMode = modeval.get_str();
+        else if (modeval.isNull())
+        {
+            /* Do nothing */
+        }
+        else
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid mode");
+        lpval = find_value(oparam, "longpollid");
+
+        if (strMode == "proposal")
+        {
+            const UniValue& dataval = find_value(oparam, "data");
+            if (!dataval.isStr())
+                throw JSONRPCError(RPC_TYPE_ERROR, "Missing data String key for proposal");
+
+            CBlock block;
+            if (!DecodeHexBlk(block, dataval.get_str()))
+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Block decode failed");
+
+            uint256 hash = block.GetHash();
+            BlockMap::iterator mi = mapBlockIndex.find(hash);
+            if (mi != mapBlockIndex.end()) {
+                CBlockIndex *pindex = mi->second;
+                if (pindex->IsValid(BLOCK_VALID_SCRIPTS))
+                    return "duplicate";
+                if (pindex->nStatus & BLOCK_FAILED_MASK)
+                    return "duplicate-invalid";
+                return "duplicate-inconclusive";
+            }
+
+            CBlockIndex* const pindexPrev = chainActive.Tip();
+            // TestBlockValidity only supports blocks built on the current Tip
+            if (block.hashPrevBlock != pindexPrev->GetBlockHash())
+                return "inconclusive-not-best-prevblk";
+            CValidationState state;
+            TestBlockValidity(state, Params(), block, pindexPrev, true);
+            return BIP22ValidationResult(state);
+        }
+    }
+
+    if (strMode != "template")
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid mode");
+
+    if (vNodes.empty())
+        throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, "Bitcoin is not connected!");
+
+    if (IsInitialBlockDownload())
+        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, "Bitcoin is downloading blocks...");
+
+    static unsigned int nTransactionsUpdatedLast;
+
+    if (!lpval.isNull())
+    {
+        // Wait to respond until either the best block changes, OR a minute has passed and there are more transactions
+        uint256 hashWatchedChain;
+        boost::system_time checktxtime;
+        unsigned int nTransactionsUpdatedLastLP;
+
+        if (lpval.isStr())
+        {
+            // Format: <hashBestChain><nTransactionsUpdatedLast>
+            std::string lpstr = lpval.get_str();
+
+            hashWatchedChain.SetHex(lpstr.substr(0, 64));
+            nTransactionsUpdatedLastLP = atoi64(lpstr.substr(64));
+        }
+        else
+        {
+            // NOTE: Spec does not specify behaviour for non-string longpollid, but this makes testing easier
+            hashWatchedChain = chainActive.Tip()->GetBlockHash();
+            nTransactionsUpdatedLastLP = nTransactionsUpdatedLast;
+        }
+
+        // Release the wallet and main lock while waiting
+        LEAVE_CRITICAL_SECTION(cs_main);
+        {
+            checktxtime = boost::get_system_time() + boost::posix_time::minutes(1);
+
+            boost::unique_lock<boost::mutex> lock(csBestBlock);
+            while (chainActive.Tip()->GetBlockHash() == hashWatchedChain && IsRPCRunning())
+            {
+                if (!cvBlockChange.timed_wait(lock, checktxtime))
+                {
+                    // Timeout: Check transactions for update
+                    if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLastLP)
+                        break;
+                    checktxtime += boost::posix_time::seconds(10);
+                }
+            }
+        }
+        ENTER_CRITICAL_SECTION(cs_main);
+
+        if (!IsRPCRunning())
+            throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, "Shutting down");
+        // TODO: Maybe recheck connections/IBD and (if something wrong) send an expires-immediately template to stop miners?
+    }
+
+    // Update block
+    static CBlockIndex* pindexPrev;
+    static int64_t nStart;
+    static CBlockTemplate* pblocktemplate;
+    if (pindexPrev != chainActive.Tip() ||
+        (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5))
+    {
+        // Clear pindexPrev so future calls make a new block, despite any failures from here on
+        pindexPrev = NULL;
+
+        // Store the pindexBest used before CreateNewBlock, to avoid races
+        nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();
+        CBlockIndex* pindexPrevNew = chainActive.Tip();
+        nStart = GetTime();
+
+        // Create new block
+        if(pblocktemplate)
+        {
+            delete pblocktemplate;
+            pblocktemplate = NULL;
+        }
+        pblocktemplate = CreateNewBlock(Params());
+        if (!pblocktemplate)
+            throw JSONRPCError(RPC_OUT_OF_MEMORY, "Out of memory");
+
+        // Need to update only after we know CreateNewBlock succeeded
+        pindexPrev = pindexPrevNew;
+    }
+    CBlock* pblock = &pblocktemplate->block; // pointer for convenience
+
+    // Update nTime
+    UpdateTime(pblock, Params().GetConsensus(), pindexPrev);
+    // pblock->nNonce = 0;
+
+    UniValue aCaps(UniValue::VARR); aCaps.push_back("proposal");
+
+    UniValue transactions(UniValue::VARR);
+    map<uint256, int64_t> setTxIndex;
+    int i = 0;
+    BOOST_FOREACH (const CTransaction& tx, pblock->vtx) {
+        uint256 txHash = tx.GetHash();
+        setTxIndex[txHash] = i++;
+
+        if (tx.IsCoinBase())
+            continue;
+
+        UniValue entry(UniValue::VOBJ);
+
+        entry.push_back(Pair("data", EncodeHexTx(tx)));
+
+        entry.push_back(Pair("hash", txHash.GetHex()));
+
+        UniValue deps(UniValue::VARR);
+        BOOST_FOREACH (const CTxIn &in, tx.vin)
+        {
+            if (setTxIndex.count(in.prevout.hash))
+                deps.push_back(setTxIndex[in.prevout.hash]);
+        }
+        entry.push_back(Pair("depends", deps));
+
+        int index_in_template = i - 1;
+        entry.push_back(Pair("sigops", pblocktemplate->vTxSigOps[index_in_template]));
+
+        transactions.push_back(entry);
+    }
+
+    UniValue aux(UniValue::VOBJ);
+    aux.push_back(Pair("flags", HexStr(COINBASE_FLAGS.begin(), COINBASE_FLAGS.end())));
+
+    // arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);
+
+    static UniValue aMutable(UniValue::VARR);
+    if (aMutable.empty())
+    {
+        aMutable.push_back("time");
+        aMutable.push_back("transactions");
+        aMutable.push_back("prevblock");
+    }
+
+    UniValue result(UniValue::VOBJ);
+    result.push_back(Pair("capabilities", aCaps));
+    result.push_back(Pair("version", pblock->nVersion));
+    result.push_back(Pair("previousblockhash", pblock->hashPrevBlock.GetHex()));
+    result.push_back(Pair("transactions", transactions));
+    result.push_back(Pair("coinbaseaux", aux));
+    result.push_back(Pair("coinbasevalue", (int64_t)pblock->vtx[0].vout[0].nValue.second));
+    result.push_back(Pair("longpollid", chainActive.Tip()->GetBlockHash().GetHex() + i64tostr(nTransactionsUpdatedLast)));
+    // result.push_back(Pair("target", hashTarget.GetHex()));
+    result.push_back(Pair("mintime", (int64_t)pindexPrev->GetMedianTimePast()+1));
+    result.push_back(Pair("mutable", aMutable));
+    // result.push_back(Pair("noncerange", "00000000ffffffff"));
+    result.push_back(Pair("sigoplimit", (int64_t)MAX_BLOCK_SIGOPS));
+    result.push_back(Pair("sizelimit", (int64_t)MAX_BLOCK_SIZE));
+    result.push_back(Pair("curtime", pblock->GetBlockTime()));
+    // result.push_back(Pair("bits", strprintf("%08x", pblock->nBits)));
+    result.push_back(Pair("height", (int64_t)(pindexPrev->nHeight+1)));
+
+    return result;
+}
+
+class submitblock_StateCatcher : public CValidationInterface
+{
+public:
+    uint256 hash;
+    bool found;
+    CValidationState state;
+
+    submitblock_StateCatcher(const uint256 &hashIn) : hash(hashIn), found(false), state() {};
+
+protected:
+    virtual void BlockChecked(const CBlock& block, const CValidationState& stateIn) {
+        if (block.GetHash() != hash)
+            return;
+        found = true;
+        state = stateIn;
+    };
+};
+
+UniValue submitblock(const UniValue& params, bool fHelp)
+{
+    if (fHelp || params.size() < 1 || params.size() > 2)
+        throw runtime_error(
+            "submitblock \"hexdata\" ( \"jsonparametersobject\" )\n"
+            "\nAttempts to submit new block to network.\n"
+            "The 'jsonparametersobject' parameter is currently ignored.\n"
+            "See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\n"
+
+            "\nArguments\n"
+            "1. \"hexdata\"    (string, required) the hex-encoded block data to submit\n"
+            "2. \"jsonparametersobject\"     (string, optional) object of optional parameters\n"
+            "    {\n"
+            "      \"workid\" : \"id\"    (string, optional) if the server provided a workid, it MUST be included with submissions\n"
+            "    }\n"
+            "\nResult:\n"
+            "\nExamples:\n"
+            + HelpExampleCli("submitblock", "\"mydata\"")
+            + HelpExampleRpc("submitblock", "\"mydata\"")
+        );
+
+    CBlock block;
+    if (!DecodeHexBlk(block, params[0].get_str()))
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Block decode failed");
+
+    uint256 hash = block.GetHash();
+    bool fBlockPresent = false;
+    {
+        LOCK(cs_main);
+        BlockMap::iterator mi = mapBlockIndex.find(hash);
+        if (mi != mapBlockIndex.end()) {
+            CBlockIndex *pindex = mi->second;
+            if (pindex->IsValid(BLOCK_VALID_SCRIPTS))
+                return "duplicate";
+            if (pindex->nStatus & BLOCK_FAILED_MASK)
+                return "duplicate-invalid";
+            // Otherwise, we might only have the header - process the block before returning
+            fBlockPresent = true;
+        }
+    }
+
+    CValidationState state;
+    submitblock_StateCatcher sc(block.GetHash());
+    RegisterValidationInterface(&sc);
+    bool fAccepted = ProcessNewBlock(state, Params(), NULL, &block, true, NULL);
+    UnregisterValidationInterface(&sc);
+    if (fBlockPresent)
+    {
+        if (fAccepted && !sc.found)
+            return "duplicate-inconclusive";
+        return "duplicate";
+    }
+    if (fAccepted)
+    {
+        if (!sc.found)
+            return "inconclusive";
+        state = sc.state;
+    }
+    return BIP22ValidationResult(state);
+}
diff --git a/src/rpcclient.cpp b/src/rpcclient.cpp
index 047158023..621014491 100644
--- a/src/rpcclient.cpp
+++ b/src/rpcclient.cpp
@@ -35,7 +35,6 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "getnetworkhashps", 1 },
     { "sendtoaddress", 1 },
     { "sendtoaddress", 4 },
-    { "settxfee", 0 },
     { "getreceivedbyaddress", 1 },
     { "getreceivedbyaccount", 1 },
     { "listreceivedbyaddress", 0 },
@@ -56,6 +55,9 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "listtransactions", 3 },
     { "listaccounts", 0 },
     { "listaccounts", 1 },
+    { "operatoraction", 0 },
+    { "wizardtransfer", 0 },
+    { "rootaction", 0 },
     { "walletpassphrase", 1 },
     { "getblocktemplate", 0 },
     { "listsinceblock", 1 },
@@ -94,12 +96,6 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "verifychain", 1 },
     { "keypoolrefill", 0 },
     { "getrawmempool", 0 },
-    { "estimatefee", 0 },
-    { "estimatepriority", 0 },
-    { "estimatesmartfee", 0 },
-    { "estimatesmartpriority", 0 },
-    { "prioritisetransaction", 1 },
-    { "prioritisetransaction", 2 },
     { "setban", 2 },
     { "setban", 3 },
 };
diff --git a/src/rpcmining.cpp b/src/rpcmining.cpp
deleted file mode 100644
index 1048344e0..000000000
--- a/src/rpcmining.cpp
+++ /dev/null
@@ -1,800 +0,0 @@
-// Copyright (c) 2010 Satoshi Nakamoto
-// Copyright (c) 2009-2015 The Bitcoin Core developers
-// Distributed under the MIT software license, see the accompanying
-// file COPYING or http://www.opensource.org/licenses/mit-license.php.
-
-#include "amount.h"
-#include "chain.h"
-#include "chainparams.h"
-#include "consensus/consensus.h"
-#include "consensus/validation.h"
-#include "core_io.h"
-#include "init.h"
-#include "main.h"
-#include "miner.h"
-#include "net.h"
-#include "pow.h"
-#include "rpcserver.h"
-#include "txmempool.h"
-#include "util.h"
-#include "utilstrencodings.h"
-#include "validationinterface.h"
-
-#include <stdint.h>
-
-#include <boost/assign/list_of.hpp>
-#include <boost/shared_ptr.hpp>
-
-#include <univalue.h>
-
-using namespace std;
-
-/**
- * Return average network hashes per second based on the last 'lookup' blocks,
- * or from the last difficulty change if 'lookup' is nonpositive.
- * If 'height' is nonnegative, compute the estimate at the time when a given block was found.
- */
-UniValue GetNetworkHashPS(int lookup, int height) {
-    CBlockIndex *pb = chainActive.Tip();
-
-    if (height >= 0 && height < chainActive.Height())
-        pb = chainActive[height];
-
-    if (pb == NULL || !pb->nHeight)
-        return 0;
-
-    // If lookup is -1, then use blocks since last difficulty change.
-    if (lookup <= 0)
-        lookup = pb->nHeight % Params().GetConsensus().DifficultyAdjustmentInterval() + 1;
-
-    // If lookup is larger than chain, then set it to chain length.
-    if (lookup > pb->nHeight)
-        lookup = pb->nHeight;
-
-    CBlockIndex *pb0 = pb;
-    int64_t minTime = pb0->GetBlockTime();
-    int64_t maxTime = minTime;
-    for (int i = 0; i < lookup; i++) {
-        pb0 = pb0->pprev;
-        int64_t time = pb0->GetBlockTime();
-        minTime = std::min(time, minTime);
-        maxTime = std::max(time, maxTime);
-    }
-
-    // In case there's a situation where minTime == maxTime, we don't want a divide by zero exception.
-    if (minTime == maxTime)
-        return 0;
-
-    arith_uint256 workDiff = pb->nChainWork - pb0->nChainWork;
-    int64_t timeDiff = maxTime - minTime;
-
-    return workDiff.getdouble() / timeDiff;
-}
-
-UniValue getnetworkhashps(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() > 2)
-        throw runtime_error(
-            "getnetworkhashps ( blocks height )\n"
-            "\nReturns the estimated network hashes per second based on the last n blocks.\n"
-            "Pass in [blocks] to override # of blocks, -1 specifies since last difficulty change.\n"
-            "Pass in [height] to estimate the network speed at the time when a certain block was found.\n"
-            "\nArguments:\n"
-            "1. blocks     (numeric, optional, default=120) The number of blocks, or -1 for blocks since last difficulty change.\n"
-            "2. height     (numeric, optional, default=-1) To estimate at the time of the given height.\n"
-            "\nResult:\n"
-            "x             (numeric) Hashes per second estimated\n"
-            "\nExamples:\n"
-            + HelpExampleCli("getnetworkhashps", "")
-            + HelpExampleRpc("getnetworkhashps", "")
-       );
-
-    LOCK(cs_main);
-    return GetNetworkHashPS(params.size() > 0 ? params[0].get_int() : 120, params.size() > 1 ? params[1].get_int() : -1);
-}
-
-UniValue getgenerate(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() != 0)
-        throw runtime_error(
-            "getgenerate\n"
-            "\nReturn if the server is set to generate coins or not. The default is false.\n"
-            "It is set with the command line argument -gen (or " + std::string(BITCOIN_CONF_FILENAME) + " setting gen)\n"
-            "It can also be set with the setgenerate call.\n"
-            "\nResult\n"
-            "true|false      (boolean) If the server is set to generate coins or not\n"
-            "\nExamples:\n"
-            + HelpExampleCli("getgenerate", "")
-            + HelpExampleRpc("getgenerate", "")
-        );
-
-    LOCK(cs_main);
-    return GetBoolArg("-gen", DEFAULT_GENERATE);
-}
-
-UniValue generate(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() < 1 || params.size() > 1)
-        throw runtime_error(
-            "generate numblocks\n"
-            "\nMine blocks immediately (before the RPC call returns)\n"
-            "\nNote: this function can only be used on the regtest network\n"
-            "\nArguments:\n"
-            "1. numblocks    (numeric, required) How many blocks are generated immediately.\n"
-            "\nResult\n"
-            "[ blockhashes ]     (array) hashes of blocks generated\n"
-            "\nExamples:\n"
-            "\nGenerate 11 blocks\n"
-            + HelpExampleCli("generate", "11")
-        );
-
-    if (!Params().MineBlocksOnDemand())
-        throw JSONRPCError(RPC_METHOD_NOT_FOUND, "This method can only be used on regtest");
-
-    int nHeightStart = 0;
-    int nHeightEnd = 0;
-    int nHeight = 0;
-    int nGenerate = params[0].get_int();
-
-    boost::shared_ptr<CReserveScript> coinbaseScript;
-    GetMainSignals().ScriptForMining(coinbaseScript);
-
-    // If the keypool is exhausted, no script is returned at all.  Catch this.
-    if (!coinbaseScript)
-        throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, "Error: Keypool ran out, please call keypoolrefill first");
-
-    //throw an error if no script was provided
-    if (coinbaseScript->reserveScript.empty())
-        throw JSONRPCError(RPC_INTERNAL_ERROR, "No coinbase script available (mining requires a wallet)");
-
-    {   // Don't keep cs_main locked
-        LOCK(cs_main);
-        nHeightStart = chainActive.Height();
-        nHeight = nHeightStart;
-        nHeightEnd = nHeightStart+nGenerate;
-    }
-    unsigned int nExtraNonce = 0;
-    UniValue blockHashes(UniValue::VARR);
-    while (nHeight < nHeightEnd)
-    {
-        auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlock(Params(), coinbaseScript->reserveScript));
-        if (!pblocktemplate.get())
-            throw JSONRPCError(RPC_INTERNAL_ERROR, "Couldn't create new block");
-        CBlock *pblock = &pblocktemplate->block;
-        {
-            LOCK(cs_main);
-            IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);
-        }
-        while (!CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus())) {
-            // Yes, there is a chance every nonce could fail to satisfy the -regtest
-            // target -- 1 in 2^(2^32). That ain't gonna happen.
-            ++pblock->nNonce;
-        }
-        CValidationState state;
-        if (!ProcessNewBlock(state, Params(), NULL, pblock, true, NULL))
-            throw JSONRPCError(RPC_INTERNAL_ERROR, "ProcessNewBlock, block not accepted");
-        ++nHeight;
-        blockHashes.push_back(pblock->GetHash().GetHex());
-
-        //mark script as important because it was used at least for one coinbase output
-        coinbaseScript->KeepScript();
-    }
-    return blockHashes;
-}
-
-UniValue setgenerate(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() < 1 || params.size() > 2)
-        throw runtime_error(
-            "setgenerate generate ( genproclimit )\n"
-            "\nSet 'generate' true or false to turn generation on or off.\n"
-            "Generation is limited to 'genproclimit' processors, -1 is unlimited.\n"
-            "See the getgenerate call for the current setting.\n"
-            "\nArguments:\n"
-            "1. generate         (boolean, required) Set to true to turn on generation, off to turn off.\n"
-            "2. genproclimit     (numeric, optional) Set the processor limit for when generation is on. Can be -1 for unlimited.\n"
-            "\nExamples:\n"
-            "\nSet the generation on with a limit of one processor\n"
-            + HelpExampleCli("setgenerate", "true 1") +
-            "\nCheck the setting\n"
-            + HelpExampleCli("getgenerate", "") +
-            "\nTurn off generation\n"
-            + HelpExampleCli("setgenerate", "false") +
-            "\nUsing json rpc\n"
-            + HelpExampleRpc("setgenerate", "true, 1")
-        );
-
-    if (Params().MineBlocksOnDemand())
-        throw JSONRPCError(RPC_METHOD_NOT_FOUND, "Use the generate method instead of setgenerate on this network");
-
-    bool fGenerate = true;
-    if (params.size() > 0)
-        fGenerate = params[0].get_bool();
-
-    int nGenProcLimit = GetArg("-genproclimit", DEFAULT_GENERATE_THREADS);
-    if (params.size() > 1)
-    {
-        nGenProcLimit = params[1].get_int();
-        if (nGenProcLimit == 0)
-            fGenerate = false;
-    }
-
-    mapArgs["-gen"] = (fGenerate ? "1" : "0");
-    mapArgs ["-genproclimit"] = itostr(nGenProcLimit);
-    GenerateBitcoins(fGenerate, nGenProcLimit, Params());
-
-    return NullUniValue;
-}
-
-UniValue getmininginfo(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() != 0)
-        throw runtime_error(
-            "getmininginfo\n"
-            "\nReturns a json object containing mining-related information."
-            "\nResult:\n"
-            "{\n"
-            "  \"blocks\": nnn,             (numeric) The current block\n"
-            "  \"currentblocksize\": nnn,   (numeric) The last block size\n"
-            "  \"currentblocktx\": nnn,     (numeric) The last block transaction\n"
-            "  \"difficulty\": xxx.xxxxx    (numeric) The current difficulty\n"
-            "  \"errors\": \"...\"          (string) Current errors\n"
-            "  \"generate\": true|false     (boolean) If the generation is on or off (see getgenerate or setgenerate calls)\n"
-            "  \"genproclimit\": n          (numeric) The processor limit for generation. -1 if no generation. (see getgenerate or setgenerate calls)\n"
-            "  \"pooledtx\": n              (numeric) The size of the mem pool\n"
-            "  \"testnet\": true|false      (boolean) If using testnet or not\n"
-            "  \"chain\": \"xxxx\",         (string) current network name as defined in BIP70 (main, test, regtest)\n"
-            "}\n"
-            "\nExamples:\n"
-            + HelpExampleCli("getmininginfo", "")
-            + HelpExampleRpc("getmininginfo", "")
-        );
-
-
-    LOCK(cs_main);
-
-    UniValue obj(UniValue::VOBJ);
-    obj.push_back(Pair("blocks",           (int)chainActive.Height()));
-    obj.push_back(Pair("currentblocksize", (uint64_t)nLastBlockSize));
-    obj.push_back(Pair("currentblocktx",   (uint64_t)nLastBlockTx));
-    obj.push_back(Pair("difficulty",       (double)GetDifficulty()));
-    obj.push_back(Pair("errors",           GetWarnings("statusbar")));
-    obj.push_back(Pair("genproclimit",     (int)GetArg("-genproclimit", DEFAULT_GENERATE_THREADS)));
-    obj.push_back(Pair("networkhashps",    getnetworkhashps(params, false)));
-    obj.push_back(Pair("pooledtx",         (uint64_t)mempool.size()));
-    obj.push_back(Pair("testnet",          Params().TestnetToBeDeprecatedFieldRPC()));
-    obj.push_back(Pair("chain",            Params().NetworkIDString()));
-    obj.push_back(Pair("generate",         getgenerate(params, false)));
-    return obj;
-}
-
-
-// NOTE: Unlike wallet RPC (which use BTC values), mining RPCs follow GBT (BIP 22) in using satoshi amounts
-UniValue prioritisetransaction(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() != 3)
-        throw runtime_error(
-            "prioritisetransaction <txid> <priority delta> <fee delta>\n"
-            "Accepts the transaction into mined blocks at a higher (or lower) priority\n"
-            "\nArguments:\n"
-            "1. \"txid\"       (string, required) The transaction id.\n"
-            "2. priority delta (numeric, required) The priority to add or subtract.\n"
-            "                  The transaction selection algorithm considers the tx as it would have a higher priority.\n"
-            "                  (priority of a transaction is calculated: coinage * value_in_satoshis / txsize) \n"
-            "3. fee delta      (numeric, required) The fee value (in satoshis) to add (or subtract, if negative).\n"
-            "                  The fee is not actually paid, only the algorithm for selecting transactions into a block\n"
-            "                  considers the transaction as it would have paid a higher (or lower) fee.\n"
-            "\nResult\n"
-            "true              (boolean) Returns true\n"
-            "\nExamples:\n"
-            + HelpExampleCli("prioritisetransaction", "\"txid\" 0.0 10000")
-            + HelpExampleRpc("prioritisetransaction", "\"txid\", 0.0, 10000")
-        );
-
-    LOCK(cs_main);
-
-    uint256 hash = ParseHashStr(params[0].get_str(), "txid");
-    CAmount nAmount = params[2].get_int64();
-
-    mempool.PrioritiseTransaction(hash, params[0].get_str(), params[1].get_real(), nAmount);
-    return true;
-}
-
-
-// NOTE: Assumes a conclusive result; if result is inconclusive, it must be handled by caller
-static UniValue BIP22ValidationResult(const CValidationState& state)
-{
-    if (state.IsValid())
-        return NullUniValue;
-
-    std::string strRejectReason = state.GetRejectReason();
-    if (state.IsError())
-        throw JSONRPCError(RPC_VERIFY_ERROR, strRejectReason);
-    if (state.IsInvalid())
-    {
-        if (strRejectReason.empty())
-            return "rejected";
-        return strRejectReason;
-    }
-    // Should be impossible
-    return "valid?";
-}
-
-UniValue getblocktemplate(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() > 1)
-        throw runtime_error(
-            "getblocktemplate ( \"jsonrequestobject\" )\n"
-            "\nIf the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.\n"
-            "It returns data needed to construct a block to work on.\n"
-            "See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\n"
-
-            "\nArguments:\n"
-            "1. \"jsonrequestobject\"       (string, optional) A json object in the following spec\n"
-            "     {\n"
-            "       \"mode\":\"template\"    (string, optional) This must be set to \"template\" or omitted\n"
-            "       \"capabilities\":[       (array, optional) A list of strings\n"
-            "           \"support\"           (string) client side supported feature, 'longpoll', 'coinbasetxn', 'coinbasevalue', 'proposal', 'serverlist', 'workid'\n"
-            "           ,...\n"
-            "         ]\n"
-            "     }\n"
-            "\n"
-
-            "\nResult:\n"
-            "{\n"
-            "  \"version\" : n,                    (numeric) The block version\n"
-            "  \"previousblockhash\" : \"xxxx\",    (string) The hash of current highest block\n"
-            "  \"transactions\" : [                (array) contents of non-coinbase transactions that should be included in the next block\n"
-            "      {\n"
-            "         \"data\" : \"xxxx\",          (string) transaction data encoded in hexadecimal (byte-for-byte)\n"
-            "         \"hash\" : \"xxxx\",          (string) hash/id encoded in little-endian hexadecimal\n"
-            "         \"depends\" : [              (array) array of numbers \n"
-            "             n                        (numeric) transactions before this one (by 1-based index in 'transactions' list) that must be present in the final block if this one is\n"
-            "             ,...\n"
-            "         ],\n"
-            "         \"fee\": n,                   (numeric) difference in value between transaction inputs and outputs (in Satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one\n"
-            "         \"sigops\" : n,               (numeric) total number of SigOps, as counted for purposes of block limits; if key is not present, sigop count is unknown and clients MUST NOT assume there aren't any\n"
-            "         \"required\" : true|false     (boolean) if provided and true, this transaction must be in the final block\n"
-            "      }\n"
-            "      ,...\n"
-            "  ],\n"
-            "  \"coinbaseaux\" : {                  (json object) data that should be included in the coinbase's scriptSig content\n"
-            "      \"flags\" : \"flags\"            (string) \n"
-            "  },\n"
-            "  \"coinbasevalue\" : n,               (numeric) maximum allowable input to coinbase transaction, including the generation award and transaction fees (in Satoshis)\n"
-            "  \"coinbasetxn\" : { ... },           (json object) information for coinbase transaction\n"
-            "  \"target\" : \"xxxx\",               (string) The hash target\n"
-            "  \"mintime\" : xxx,                   (numeric) The minimum timestamp appropriate for next block time in seconds since epoch (Jan 1 1970 GMT)\n"
-            "  \"mutable\" : [                      (array of string) list of ways the block template may be changed \n"
-            "     \"value\"                         (string) A way the block template may be changed, e.g. 'time', 'transactions', 'prevblock'\n"
-            "     ,...\n"
-            "  ],\n"
-            "  \"noncerange\" : \"00000000ffffffff\",   (string) A range of valid nonces\n"
-            "  \"sigoplimit\" : n,                 (numeric) limit of sigops in blocks\n"
-            "  \"sizelimit\" : n,                  (numeric) limit of block size\n"
-            "  \"curtime\" : ttt,                  (numeric) current timestamp in seconds since epoch (Jan 1 1970 GMT)\n"
-            "  \"bits\" : \"xxx\",                 (string) compressed target of next block\n"
-            "  \"height\" : n                      (numeric) The height of the next block\n"
-            "}\n"
-
-            "\nExamples:\n"
-            + HelpExampleCli("getblocktemplate", "")
-            + HelpExampleRpc("getblocktemplate", "")
-         );
-
-    LOCK(cs_main);
-
-    std::string strMode = "template";
-    UniValue lpval = NullUniValue;
-    if (params.size() > 0)
-    {
-        const UniValue& oparam = params[0].get_obj();
-        const UniValue& modeval = find_value(oparam, "mode");
-        if (modeval.isStr())
-            strMode = modeval.get_str();
-        else if (modeval.isNull())
-        {
-            /* Do nothing */
-        }
-        else
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid mode");
-        lpval = find_value(oparam, "longpollid");
-
-        if (strMode == "proposal")
-        {
-            const UniValue& dataval = find_value(oparam, "data");
-            if (!dataval.isStr())
-                throw JSONRPCError(RPC_TYPE_ERROR, "Missing data String key for proposal");
-
-            CBlock block;
-            if (!DecodeHexBlk(block, dataval.get_str()))
-                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Block decode failed");
-
-            uint256 hash = block.GetHash();
-            BlockMap::iterator mi = mapBlockIndex.find(hash);
-            if (mi != mapBlockIndex.end()) {
-                CBlockIndex *pindex = mi->second;
-                if (pindex->IsValid(BLOCK_VALID_SCRIPTS))
-                    return "duplicate";
-                if (pindex->nStatus & BLOCK_FAILED_MASK)
-                    return "duplicate-invalid";
-                return "duplicate-inconclusive";
-            }
-
-            CBlockIndex* const pindexPrev = chainActive.Tip();
-            // TestBlockValidity only supports blocks built on the current Tip
-            if (block.hashPrevBlock != pindexPrev->GetBlockHash())
-                return "inconclusive-not-best-prevblk";
-            CValidationState state;
-            TestBlockValidity(state, Params(), block, pindexPrev, false, true);
-            return BIP22ValidationResult(state);
-        }
-    }
-
-    if (strMode != "template")
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid mode");
-
-    if (vNodes.empty())
-        throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, "Bitcoin is not connected!");
-
-    if (IsInitialBlockDownload())
-        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, "Bitcoin is downloading blocks...");
-
-    static unsigned int nTransactionsUpdatedLast;
-
-    if (!lpval.isNull())
-    {
-        // Wait to respond until either the best block changes, OR a minute has passed and there are more transactions
-        uint256 hashWatchedChain;
-        boost::system_time checktxtime;
-        unsigned int nTransactionsUpdatedLastLP;
-
-        if (lpval.isStr())
-        {
-            // Format: <hashBestChain><nTransactionsUpdatedLast>
-            std::string lpstr = lpval.get_str();
-
-            hashWatchedChain.SetHex(lpstr.substr(0, 64));
-            nTransactionsUpdatedLastLP = atoi64(lpstr.substr(64));
-        }
-        else
-        {
-            // NOTE: Spec does not specify behaviour for non-string longpollid, but this makes testing easier
-            hashWatchedChain = chainActive.Tip()->GetBlockHash();
-            nTransactionsUpdatedLastLP = nTransactionsUpdatedLast;
-        }
-
-        // Release the wallet and main lock while waiting
-        LEAVE_CRITICAL_SECTION(cs_main);
-        {
-            checktxtime = boost::get_system_time() + boost::posix_time::minutes(1);
-
-            boost::unique_lock<boost::mutex> lock(csBestBlock);
-            while (chainActive.Tip()->GetBlockHash() == hashWatchedChain && IsRPCRunning())
-            {
-                if (!cvBlockChange.timed_wait(lock, checktxtime))
-                {
-                    // Timeout: Check transactions for update
-                    if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLastLP)
-                        break;
-                    checktxtime += boost::posix_time::seconds(10);
-                }
-            }
-        }
-        ENTER_CRITICAL_SECTION(cs_main);
-
-        if (!IsRPCRunning())
-            throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, "Shutting down");
-        // TODO: Maybe recheck connections/IBD and (if something wrong) send an expires-immediately template to stop miners?
-    }
-
-    // Update block
-    static CBlockIndex* pindexPrev;
-    static int64_t nStart;
-    static CBlockTemplate* pblocktemplate;
-    if (pindexPrev != chainActive.Tip() ||
-        (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5))
-    {
-        // Clear pindexPrev so future calls make a new block, despite any failures from here on
-        pindexPrev = NULL;
-
-        // Store the pindexBest used before CreateNewBlock, to avoid races
-        nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();
-        CBlockIndex* pindexPrevNew = chainActive.Tip();
-        nStart = GetTime();
-
-        // Create new block
-        if(pblocktemplate)
-        {
-            delete pblocktemplate;
-            pblocktemplate = NULL;
-        }
-        CScript scriptDummy = CScript() << OP_TRUE;
-        pblocktemplate = CreateNewBlock(Params(), scriptDummy);
-        if (!pblocktemplate)
-            throw JSONRPCError(RPC_OUT_OF_MEMORY, "Out of memory");
-
-        // Need to update only after we know CreateNewBlock succeeded
-        pindexPrev = pindexPrevNew;
-    }
-    CBlock* pblock = &pblocktemplate->block; // pointer for convenience
-
-    // Update nTime
-    UpdateTime(pblock, Params().GetConsensus(), pindexPrev);
-    pblock->nNonce = 0;
-
-    UniValue aCaps(UniValue::VARR); aCaps.push_back("proposal");
-
-    UniValue transactions(UniValue::VARR);
-    map<uint256, int64_t> setTxIndex;
-    int i = 0;
-    BOOST_FOREACH (const CTransaction& tx, pblock->vtx) {
-        uint256 txHash = tx.GetHash();
-        setTxIndex[txHash] = i++;
-
-        if (tx.IsCoinBase())
-            continue;
-
-        UniValue entry(UniValue::VOBJ);
-
-        entry.push_back(Pair("data", EncodeHexTx(tx)));
-
-        entry.push_back(Pair("hash", txHash.GetHex()));
-
-        UniValue deps(UniValue::VARR);
-        BOOST_FOREACH (const CTxIn &in, tx.vin)
-        {
-            if (setTxIndex.count(in.prevout.hash))
-                deps.push_back(setTxIndex[in.prevout.hash]);
-        }
-        entry.push_back(Pair("depends", deps));
-
-        int index_in_template = i - 1;
-        entry.push_back(Pair("fee", pblocktemplate->vTxFees[index_in_template]));
-        entry.push_back(Pair("sigops", pblocktemplate->vTxSigOps[index_in_template]));
-
-        transactions.push_back(entry);
-    }
-
-    UniValue aux(UniValue::VOBJ);
-    aux.push_back(Pair("flags", HexStr(COINBASE_FLAGS.begin(), COINBASE_FLAGS.end())));
-
-    arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);
-
-    static UniValue aMutable(UniValue::VARR);
-    if (aMutable.empty())
-    {
-        aMutable.push_back("time");
-        aMutable.push_back("transactions");
-        aMutable.push_back("prevblock");
-    }
-
-    UniValue result(UniValue::VOBJ);
-    result.push_back(Pair("capabilities", aCaps));
-    result.push_back(Pair("version", pblock->nVersion));
-    result.push_back(Pair("previousblockhash", pblock->hashPrevBlock.GetHex()));
-    result.push_back(Pair("transactions", transactions));
-    result.push_back(Pair("coinbaseaux", aux));
-    result.push_back(Pair("coinbasevalue", (int64_t)pblock->vtx[0].vout[0].nValue));
-    result.push_back(Pair("longpollid", chainActive.Tip()->GetBlockHash().GetHex() + i64tostr(nTransactionsUpdatedLast)));
-    result.push_back(Pair("target", hashTarget.GetHex()));
-    result.push_back(Pair("mintime", (int64_t)pindexPrev->GetMedianTimePast()+1));
-    result.push_back(Pair("mutable", aMutable));
-    result.push_back(Pair("noncerange", "00000000ffffffff"));
-    result.push_back(Pair("sigoplimit", (int64_t)MAX_BLOCK_SIGOPS));
-    result.push_back(Pair("sizelimit", (int64_t)MAX_BLOCK_SIZE));
-    result.push_back(Pair("curtime", pblock->GetBlockTime()));
-    result.push_back(Pair("bits", strprintf("%08x", pblock->nBits)));
-    result.push_back(Pair("height", (int64_t)(pindexPrev->nHeight+1)));
-
-    return result;
-}
-
-class submitblock_StateCatcher : public CValidationInterface
-{
-public:
-    uint256 hash;
-    bool found;
-    CValidationState state;
-
-    submitblock_StateCatcher(const uint256 &hashIn) : hash(hashIn), found(false), state() {};
-
-protected:
-    virtual void BlockChecked(const CBlock& block, const CValidationState& stateIn) {
-        if (block.GetHash() != hash)
-            return;
-        found = true;
-        state = stateIn;
-    };
-};
-
-UniValue submitblock(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() < 1 || params.size() > 2)
-        throw runtime_error(
-            "submitblock \"hexdata\" ( \"jsonparametersobject\" )\n"
-            "\nAttempts to submit new block to network.\n"
-            "The 'jsonparametersobject' parameter is currently ignored.\n"
-            "See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\n"
-
-            "\nArguments\n"
-            "1. \"hexdata\"    (string, required) the hex-encoded block data to submit\n"
-            "2. \"jsonparametersobject\"     (string, optional) object of optional parameters\n"
-            "    {\n"
-            "      \"workid\" : \"id\"    (string, optional) if the server provided a workid, it MUST be included with submissions\n"
-            "    }\n"
-            "\nResult:\n"
-            "\nExamples:\n"
-            + HelpExampleCli("submitblock", "\"mydata\"")
-            + HelpExampleRpc("submitblock", "\"mydata\"")
-        );
-
-    CBlock block;
-    if (!DecodeHexBlk(block, params[0].get_str()))
-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Block decode failed");
-
-    uint256 hash = block.GetHash();
-    bool fBlockPresent = false;
-    {
-        LOCK(cs_main);
-        BlockMap::iterator mi = mapBlockIndex.find(hash);
-        if (mi != mapBlockIndex.end()) {
-            CBlockIndex *pindex = mi->second;
-            if (pindex->IsValid(BLOCK_VALID_SCRIPTS))
-                return "duplicate";
-            if (pindex->nStatus & BLOCK_FAILED_MASK)
-                return "duplicate-invalid";
-            // Otherwise, we might only have the header - process the block before returning
-            fBlockPresent = true;
-        }
-    }
-
-    CValidationState state;
-    submitblock_StateCatcher sc(block.GetHash());
-    RegisterValidationInterface(&sc);
-    bool fAccepted = ProcessNewBlock(state, Params(), NULL, &block, true, NULL);
-    UnregisterValidationInterface(&sc);
-    if (fBlockPresent)
-    {
-        if (fAccepted && !sc.found)
-            return "duplicate-inconclusive";
-        return "duplicate";
-    }
-    if (fAccepted)
-    {
-        if (!sc.found)
-            return "inconclusive";
-        state = sc.state;
-    }
-    return BIP22ValidationResult(state);
-}
-
-UniValue estimatefee(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() != 1)
-        throw runtime_error(
-            "estimatefee nblocks\n"
-            "\nEstimates the approximate fee per kilobyte needed for a transaction to begin\n"
-            "confirmation within nblocks blocks.\n"
-            "\nArguments:\n"
-            "1. nblocks     (numeric)\n"
-            "\nResult:\n"
-            "n              (numeric) estimated fee-per-kilobyte\n"
-            "\n"
-            "A negative value is returned if not enough transactions and blocks\n"
-            "have been observed to make an estimate.\n"
-            "\nExample:\n"
-            + HelpExampleCli("estimatefee", "6")
-            );
-
-    RPCTypeCheck(params, boost::assign::list_of(UniValue::VNUM));
-
-    int nBlocks = params[0].get_int();
-    if (nBlocks < 1)
-        nBlocks = 1;
-
-    CFeeRate feeRate = mempool.estimateFee(nBlocks);
-    if (feeRate == CFeeRate(0))
-        return -1.0;
-
-    return ValueFromAmount(feeRate.GetFeePerK());
-}
-
-UniValue estimatepriority(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() != 1)
-        throw runtime_error(
-            "estimatepriority nblocks\n"
-            "\nEstimates the approximate priority a zero-fee transaction needs to begin\n"
-            "confirmation within nblocks blocks.\n"
-            "\nArguments:\n"
-            "1. nblocks     (numeric)\n"
-            "\nResult:\n"
-            "n              (numeric) estimated priority\n"
-            "\n"
-            "A negative value is returned if not enough transactions and blocks\n"
-            "have been observed to make an estimate.\n"
-            "\nExample:\n"
-            + HelpExampleCli("estimatepriority", "6")
-            );
-
-    RPCTypeCheck(params, boost::assign::list_of(UniValue::VNUM));
-
-    int nBlocks = params[0].get_int();
-    if (nBlocks < 1)
-        nBlocks = 1;
-
-    return mempool.estimatePriority(nBlocks);
-}
-
-UniValue estimatesmartfee(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() != 1)
-        throw runtime_error(
-            "estimatesmartfee nblocks\n"
-            "\nWARNING: This interface is unstable and may disappear or change!\n"
-            "\nEstimates the approximate fee per kilobyte needed for a transaction to begin\n"
-            "confirmation within nblocks blocks if possible and return the number of blocks\n"
-            "for which the estimate is valid.\n"
-            "\nArguments:\n"
-            "1. nblocks     (numeric)\n"
-            "\nResult:\n"
-            "{\n"
-            "  \"feerate\" : x.x,     (numeric) estimate fee-per-kilobyte (in BTC)\n"
-            "  \"blocks\" : n         (numeric) block number where estimate was found\n"
-            "}\n"
-            "\n"
-            "A negative value is returned if not enough transactions and blocks\n"
-            "have been observed to make an estimate for any number of blocks.\n"
-            "However it will not return a value below the mempool reject fee.\n"
-            "\nExample:\n"
-            + HelpExampleCli("estimatesmartfee", "6")
-            );
-
-    RPCTypeCheck(params, boost::assign::list_of(UniValue::VNUM));
-
-    int nBlocks = params[0].get_int();
-
-    UniValue result(UniValue::VOBJ);
-    int answerFound;
-    CFeeRate feeRate = mempool.estimateSmartFee(nBlocks, &answerFound);
-    result.push_back(Pair("feerate", feeRate == CFeeRate(0) ? -1.0 : ValueFromAmount(feeRate.GetFeePerK())));
-    result.push_back(Pair("blocks", answerFound));
-    return result;
-}
-
-UniValue estimatesmartpriority(const UniValue& params, bool fHelp)
-{
-    if (fHelp || params.size() != 1)
-        throw runtime_error(
-            "estimatesmartpriority nblocks\n"
-            "\nWARNING: This interface is unstable and may disappear or change!\n"
-            "\nEstimates the approximate priority a zero-fee transaction needs to begin\n"
-            "confirmation within nblocks blocks if possible and return the number of blocks\n"
-            "for which the estimate is valid.\n"
-            "\nArguments:\n"
-            "1. nblocks     (numeric)\n"
-            "\nResult:\n"
-            "{\n"
-            "  \"priority\" : x.x,    (numeric) estimated priority\n"
-            "  \"blocks\" : n         (numeric) block number where estimate was found\n"
-            "}\n"
-            "\n"
-            "A negative value is returned if not enough transactions and blocks\n"
-            "have been observed to make an estimate for any number of blocks.\n"
-            "However if the mempool reject fee is set it will return 1e9 * MAX_MONEY.\n"
-            "\nExample:\n"
-            + HelpExampleCli("estimatesmartpriority", "6")
-            );
-
-    RPCTypeCheck(params, boost::assign::list_of(UniValue::VNUM));
-
-    int nBlocks = params[0].get_int();
-
-    UniValue result(UniValue::VOBJ);
-    int answerFound;
-    double priority = mempool.estimateSmartPriority(nBlocks, &answerFound);
-    result.push_back(Pair("priority", priority));
-    result.push_back(Pair("blocks", answerFound));
-    return result;
-}
diff --git a/src/rpcmisc.cpp b/src/rpcmisc.cpp
index 9871c3fcc..31745c2af 100644
--- a/src/rpcmisc.cpp
+++ b/src/rpcmisc.cpp
@@ -60,8 +60,6 @@ UniValue getinfo(const UniValue& params, bool fHelp)
             "  \"keypoololdest\": xxxxxx,    (numeric) the timestamp (seconds since GMT epoch) of the oldest pre-generated key in the key pool\n"
             "  \"keypoolsize\": xxxx,        (numeric) how many new keys are pre-generated\n"
             "  \"unlocked_until\": ttt,      (numeric) the timestamp in seconds since epoch (midnight Jan 1 1970 GMT) that the wallet is unlocked for transfers, or 0 if the wallet is locked\n"
-            "  \"paytxfee\": x.xxxx,         (numeric) the transaction fee set in " + CURRENCY_UNIT + "/kB\n"
-            "  \"relayfee\": x.xxxx,         (numeric) minimum relay fee for non-free transactions in " + CURRENCY_UNIT + "/kB\n"
             "  \"errors\": \"...\"           (string) any error messages\n"
             "}\n"
             "\nExamples:\n"
@@ -91,7 +89,7 @@ UniValue getinfo(const UniValue& params, bool fHelp)
     obj.push_back(Pair("timeoffset",    GetTimeOffset()));
     obj.push_back(Pair("connections",   (int)vNodes.size()));
     obj.push_back(Pair("proxy",         (proxy.IsValid() ? proxy.proxy.ToStringIPPort() : string())));
-    obj.push_back(Pair("difficulty",    (double)GetDifficulty()));
+    //obj.push_back(Pair("difficulty",    (double)GetDifficulty()));
     obj.push_back(Pair("testnet",       Params().TestnetToBeDeprecatedFieldRPC()));
 #ifdef ENABLE_WALLET
     if (pwalletMain) {
@@ -100,9 +98,7 @@ UniValue getinfo(const UniValue& params, bool fHelp)
     }
     if (pwalletMain && pwalletMain->IsCrypted())
         obj.push_back(Pair("unlocked_until", nWalletUnlockTime));
-    obj.push_back(Pair("paytxfee",      ValueFromAmount(payTxFee.GetFeePerK())));
 #endif
-    obj.push_back(Pair("relayfee",      ValueFromAmount(::minRelayTxFee.GetFeePerK())));
     obj.push_back(Pair("errors",        GetWarnings("statusbar")));
     return obj;
 }
diff --git a/src/rpcnet.cpp b/src/rpcnet.cpp
index 779e7fbc6..bb5c64eec 100644
--- a/src/rpcnet.cpp
+++ b/src/rpcnet.cpp
@@ -446,7 +446,6 @@ UniValue getnetworkinfo(const UniValue& params, bool fHelp)
             "  }\n"
             "  ,...\n"
             "  ],\n"
-            "  \"relayfee\": x.xxxxxxxx,                (numeric) minimum relay fee for non-free transactions in " + CURRENCY_UNIT + "/kB\n"
             "  \"localaddresses\": [                    (array) list of local addresses\n"
             "  {\n"
             "    \"address\": \"xxxx\",                 (string) network address\n"
@@ -472,7 +471,6 @@ UniValue getnetworkinfo(const UniValue& params, bool fHelp)
     obj.push_back(Pair("timeoffset",    GetTimeOffset()));
     obj.push_back(Pair("connections",   (int)vNodes.size()));
     obj.push_back(Pair("networks",      GetNetworksInfo()));
-    obj.push_back(Pair("relayfee",      ValueFromAmount(::minRelayTxFee.GetFeePerK())));
     UniValue localAddresses(UniValue::VARR);
     {
         LOCK(cs_mapLocalHost);
diff --git a/src/rpcrawtransaction.cpp b/src/rpcrawtransaction.cpp
index bd51aa0ab..f1dc1c0e7 100644
--- a/src/rpcrawtransaction.cpp
+++ b/src/rpcrawtransaction.cpp
@@ -151,7 +151,7 @@ UniValue getrawtransaction(const UniValue& params, bool fHelp)
             "  ],\n"
             "  \"vout\" : [              (array of json objects)\n"
             "     {\n"
-            "       \"value\" : x.xxx,            (numeric) The value in " + CURRENCY_UNIT + "\n"
+            "       \"value\" : xxxxx,            (numeric) The value\n"
             "       \"n\" : n,                    (numeric) index\n"
             "       \"scriptPubKey\" : {          (json object)\n"
             "         \"asm\" : \"asm\",          (string) the asm\n"
@@ -338,7 +338,7 @@ UniValue createrawtransaction(const UniValue& params, bool fHelp)
             "     ]\n"
             "2. \"outputs\"             (string, required) a json object with outputs\n"
             "    {\n"
-            "      \"address\": x.xxx   (numeric or string, required) The key is the bitcoin address, the numeric value (can be string) is the " + CURRENCY_UNIT + " amount\n"
+            "      \"address\": xxxxx   (numeric or string, required) The key is the bitcoin address, the numeric value (can be string) is the amount\n"
             "      \"data\": \"hex\",     (string, required) The key is \"data\", the value is hex encoded data\n"
             "      ...\n"
             "    }\n"
@@ -347,10 +347,10 @@ UniValue createrawtransaction(const UniValue& params, bool fHelp)
             "\"transaction\"            (string) hex string of the transaction\n"
 
             "\nExamples\n"
-            + HelpExampleCli("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"{\\\"address\\\":0.01}\"")
-            + HelpExampleCli("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"{\\\"data\\\":\\\"00010203\\\"}\"")
-            + HelpExampleRpc("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\", \"{\\\"address\\\":0.01}\"")
-            + HelpExampleRpc("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\", \"{\\\"data\\\":\\\"00010203\\\"}\"")
+            + HelpExampleCli("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":[\\\"0:100\\\"]}]\" \"{\\\"address\\\":[\\\"0:100\\\"]}\"")
+            + HelpExampleCli("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":[\\\"0:100\\\"]}]\" \"{\\\"data\\\":\\\"00010203\\\"}\"")
+            + HelpExampleRpc("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":[\\\"0:100\\\"]}]\", \"{\\\"address\\\":[\\\"0:100\\\"]}\"")
+            + HelpExampleRpc("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":[\\\"0:100\\\"]}]\", \"{\\\"data\\\":\\\"00010203\\\"}\"")
         );
 
     LOCK(cs_main);
@@ -396,7 +396,7 @@ UniValue createrawtransaction(const UniValue& params, bool fHelp)
         if (name_ == "data") {
             std::vector<unsigned char> data = ParseHexV(sendTo[name_].getValStr(),"Data");
 
-            CTxOut out(0, CScript() << OP_RETURN << data);
+            CTxOut out(std::make_pair(0, 0), CScript() << OP_RETURN << data);
             rawTx.vout.push_back(out);
         } else {
             CBitcoinAddress address(name_);
@@ -408,10 +408,16 @@ UniValue createrawtransaction(const UniValue& params, bool fHelp)
             setAddress.insert(address);
 
             CScript scriptPubKey = GetScriptForDestination(address.Get());
-            CAmount nAmount = AmountFromValue(sendTo[name_]);
+            CAmount nAmount = TAmountFromValue(sendTo[name_]);
+
+            BOOST_FOREACH(const CValue& cval, nAmount) {
+                if (cval.second <= 0)
+                    throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount for send");
+
+                CTxOut out(cval, scriptPubKey);
+                rawTx.vout.push_back(out);
+            }
 
-            CTxOut out(nAmount, scriptPubKey);
-            rawTx.vout.push_back(out);
         }
     }
 
@@ -448,7 +454,7 @@ UniValue decoderawtransaction(const UniValue& params, bool fHelp)
             "  ],\n"
             "  \"vout\" : [             (array of json objects)\n"
             "     {\n"
-            "       \"value\" : x.xxx,            (numeric) The value in " + CURRENCY_UNIT + "\n"
+            "       \"value\" : xxxxx,            (numeric) The value\n"
             "       \"n\" : n,                    (numeric) index\n"
             "       \"scriptPubKey\" : {          (json object)\n"
             "         \"asm\" : \"asm\",          (string) the asm\n"
@@ -697,7 +703,7 @@ UniValue signrawtransaction(const UniValue& params, bool fHelp)
                 if ((unsigned int)nOut >= coins->vout.size())
                     coins->vout.resize(nOut+1);
                 coins->vout[nOut].scriptPubKey = scriptPubKey;
-                coins->vout[nOut].nValue = 0; // we don't know the actual output value
+                coins->vout[nOut].nValue = std::make_pair(0, 0); // we don't know the actual output value
             }
 
             // if redeemScript given and not using the local wallet (private keys
@@ -783,12 +789,11 @@ UniValue sendrawtransaction(const UniValue& params, bool fHelp)
 {
     if (fHelp || params.size() < 1 || params.size() > 2)
         throw runtime_error(
-            "sendrawtransaction \"hexstring\" ( allowhighfees )\n"
+            "sendrawtransaction \"hexstring\"\n"
             "\nSubmits raw transaction (serialized, hex-encoded) to local node and network.\n"
             "\nAlso see createrawtransaction and signrawtransaction calls.\n"
             "\nArguments:\n"
             "1. \"hexstring\"    (string, required) The hex string of the raw transaction)\n"
-            "2. allowhighfees    (boolean, optional, default=false) Allow high fees\n"
             "\nResult:\n"
             "\"hex\"             (string) The transaction hash in hex\n"
             "\nExamples:\n"
@@ -811,10 +816,6 @@ UniValue sendrawtransaction(const UniValue& params, bool fHelp)
         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "TX decode failed");
     uint256 hashTx = tx.GetHash();
 
-    bool fOverrideFees = false;
-    if (params.size() > 1)
-        fOverrideFees = params[1].get_bool();
-
     CCoinsViewCache &view = *pcoinsTip;
     const CCoins* existingCoins = view.AccessCoins(hashTx);
     bool fHaveMempool = mempool.exists(hashTx);
@@ -823,7 +824,7 @@ UniValue sendrawtransaction(const UniValue& params, bool fHelp)
         // push to local node and sync with wallets
         CValidationState state;
         bool fMissingInputs;
-        if (!AcceptToMemoryPool(mempool, state, tx, false, &fMissingInputs, false, !fOverrideFees)) {
+        if (!AcceptToMemoryPool(mempool, state, tx, &fMissingInputs, false)) {
             if (state.IsInvalid()) {
                 throw JSONRPCError(RPC_TRANSACTION_REJECTED, strprintf("%i: %s", state.GetRejectCode(), state.GetRejectReason()));
             } else {
diff --git a/src/rpcserver.cpp b/src/rpcserver.cpp
index b3abeec4a..76fb46960 100644
--- a/src/rpcserver.cpp
+++ b/src/rpcserver.cpp
@@ -106,26 +106,65 @@ void RPCTypeCheckObj(const UniValue& o,
     }
 }
 
-CAmount AmountFromValue(const UniValue& value)
+CValue AmountFromValue(const UniValue& value, uint32_t& nLockTime)
 {
-    if (!value.isNum() && !value.isStr())
-        throw JSONRPCError(RPC_TYPE_ERROR, "Amount is not a number or string");
-    CAmount amount;
-    if (!ParseFixedPoint(value.getValStr(), 8, &amount))
+    if (!value.isStr())
+        throw JSONRPCError(RPC_TYPE_ERROR, "Amount is not a string");
+
+    nLockTime = 0;
+    CValue amount;
+    if (2 > std::sscanf(value.getValStr().c_str(), "%d:%ld:%d", &amount.first, &amount.second, &nLockTime))
         throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount");
     if (!MoneyRange(amount))
         throw JSONRPCError(RPC_TYPE_ERROR, "Amount out of range");
     return amount;
 }
 
+CAmount TAmountFromValue(const UniValue& value) {
+    if (!value.isArray())
+        throw JSONRPCError(RPC_TYPE_ERROR, "Amount is not an array");
+
+    CAmount ret;
+    CValue cval;
+
+    uint32_t nLockTime;
+    for (unsigned int idx = 0; idx < value.size(); idx++) {
+        if(!value[idx].isStr()) throw JSONRPCError(RPC_TYPE_ERROR, "Amount is not a string");
+
+        cval = AmountFromValue(value[idx], nLockTime);
+        ret += cval;
+    }
+
+    return ret;
+}
+
 UniValue ValueFromAmount(const CAmount& amount)
 {
-    bool sign = amount < 0;
-    int64_t n_abs = (sign ? -amount : amount);
-    int64_t quotient = n_abs / COIN;
-    int64_t remainder = n_abs % COIN;
-    return UniValue(UniValue::VNUM,
-            strprintf("%s%d.%08d", sign ? "-" : "", quotient, remainder));
+    UniValue ret(UniValue::VARR);
+    BOOST_FOREACH(const CValue &cval, amount) {
+        if (cval.second == 0) continue;
+        ret.push_back(ValueFromAmount(cval));
+    }
+
+    return ret;
+}
+
+UniValue ValueFromAmount(const CValue& amount)
+{
+    int64_t n_abs = amount.second;
+    bool sign = n_abs < 0;
+    if (sign) n_abs = -n_abs;
+    return UniValue(UniValue::VSTR,
+            strprintf("%d:%s%ld", amount.first, sign ? "-" : "", n_abs));
+}
+
+UniValue ValueFromAmount(const int64_t& amount)
+{
+    int64_t n_abs = amount;
+    bool sign = n_abs < 0;
+    if (sign) n_abs = -n_abs;
+    return UniValue(UniValue::VSTR,
+            strprintf("%s%ld", sign ? "-" : "", n_abs));
 }
 
 uint256 ParseHashV(const UniValue& v, string strName)
@@ -281,7 +320,7 @@ static const CRPCCommand vRPCCommands[] =
     { "blockchain",         "getblockhash",           &getblockhash,           true  },
     { "blockchain",         "getblockheader",         &getblockheader,         true  },
     { "blockchain",         "getchaintips",           &getchaintips,           true  },
-    { "blockchain",         "getdifficulty",          &getdifficulty,          true  },
+    // { "blockchain",         "getdifficulty",          &getdifficulty,          true  },
     { "blockchain",         "getmempoolinfo",         &getmempoolinfo,         true  },
     { "blockchain",         "getrawmempool",          &getrawmempool,          true  },
     { "blockchain",         "gettxout",               &gettxout,               true  },
@@ -290,18 +329,6 @@ static const CRPCCommand vRPCCommands[] =
     { "blockchain",         "gettxoutsetinfo",        &gettxoutsetinfo,        true  },
     { "blockchain",         "verifychain",            &verifychain,            true  },
 
-    /* Mining */
-    { "mining",             "getblocktemplate",       &getblocktemplate,       true  },
-    { "mining",             "getmininginfo",          &getmininginfo,          true  },
-    { "mining",             "getnetworkhashps",       &getnetworkhashps,       true  },
-    { "mining",             "prioritisetransaction",  &prioritisetransaction,  true  },
-    { "mining",             "submitblock",            &submitblock,            true  },
-
-    /* Coin generation */
-    { "generating",         "getgenerate",            &getgenerate,            true  },
-    { "generating",         "setgenerate",            &setgenerate,            true  },
-    { "generating",         "generate",               &generate,               true  },
-
     /* Raw transactions */
     { "rawtransactions",    "createrawtransaction",   &createrawtransaction,   true  },
     { "rawtransactions",    "decoderawtransaction",   &decoderawtransaction,   true  },
@@ -317,11 +344,6 @@ static const CRPCCommand vRPCCommands[] =
     { "util",               "createmultisig",         &createmultisig,         true  },
     { "util",               "validateaddress",        &validateaddress,        true  }, /* uses wallet if enabled */
     { "util",               "verifymessage",          &verifymessage,          true  },
-    { "util",               "estimatefee",            &estimatefee,            true  },
-    { "util",               "estimatepriority",       &estimatepriority,       true  },
-    { "util",               "estimatesmartfee",       &estimatesmartfee,       true  },
-    { "util",               "estimatesmartpriority",  &estimatesmartpriority,  true  },
-
     /* Not shown in help */
     { "hidden",             "invalidateblock",        &invalidateblock,        true  },
     { "hidden",             "reconsiderblock",        &reconsiderblock,        true  },
@@ -336,6 +358,7 @@ static const CRPCCommand vRPCCommands[] =
     { "wallet",             "backupwallet",           &backupwallet,           true  },
     { "wallet",             "dumpprivkey",            &dumpprivkey,            true  },
     { "wallet",             "dumpwallet",             &dumpwallet,             true  },
+    { "wallet",             "getprimeaddr",           &getprimeaddr,           true  },
     { "wallet",             "encryptwallet",          &encryptwallet,          true  },
     { "wallet",             "getaccountaddress",      &getaccountaddress,      true  },
     { "wallet",             "getaccount",             &getaccount,             true  },
@@ -368,7 +391,6 @@ static const CRPCCommand vRPCCommands[] =
     { "wallet",             "sendmany",               &sendmany,               false },
     { "wallet",             "sendtoaddress",          &sendtoaddress,          false },
     { "wallet",             "setaccount",             &setaccount,             true  },
-    { "wallet",             "settxfee",               &settxfee,               true  },
     { "wallet",             "signmessage",            &signmessage,            true  },
     { "wallet",             "walletlock",             &walletlock,             true  },
     { "wallet",             "walletpassphrasechange", &walletpassphrasechange, true  },
diff --git a/src/rpcserver.h b/src/rpcserver.h
index babf7c8d2..78bdfc93e 100644
--- a/src/rpcserver.h
+++ b/src/rpcserver.h
@@ -156,9 +156,12 @@ extern std::vector<unsigned char> ParseHexV(const UniValue& v, std::string strNa
 extern std::vector<unsigned char> ParseHexO(const UniValue& o, std::string strKey);
 
 extern int64_t nWalletUnlockTime;
-extern CAmount AmountFromValue(const UniValue& value);
+extern CValue AmountFromValue(const UniValue& value, uint32_t& nLockTime);
+extern CAmount TAmountFromValue(const UniValue& value);
 extern UniValue ValueFromAmount(const CAmount& amount);
-extern double GetDifficulty(const CBlockIndex* blockindex = NULL);
+extern UniValue ValueFromAmount(const CValue& amount);
+extern UniValue ValueFromAmount(const int64_t& amount);
+// extern double GetDifficulty(const CBlockIndex* blockindex = NULL);
 extern std::string HelpRequiringPassphrase();
 extern std::string HelpExampleCli(const std::string& methodname, const std::string& args);
 extern std::string HelpExampleRpc(const std::string& methodname, const std::string& args);
@@ -181,20 +184,19 @@ extern UniValue importprivkey(const UniValue& params, bool fHelp);
 extern UniValue importaddress(const UniValue& params, bool fHelp);
 extern UniValue importpubkey(const UniValue& params, bool fHelp);
 extern UniValue dumpwallet(const UniValue& params, bool fHelp);
+extern UniValue getprimeaddr(const UniValue& params, bool fHelp);
 extern UniValue importwallet(const UniValue& params, bool fHelp);
 
 extern UniValue getgenerate(const UniValue& params, bool fHelp); // in rpcmining.cpp
 extern UniValue setgenerate(const UniValue& params, bool fHelp);
-extern UniValue generate(const UniValue& params, bool fHelp);
-extern UniValue getnetworkhashps(const UniValue& params, bool fHelp);
+// extern UniValue generate(const UniValue& params, bool fHelp);
+// extern UniValue getnetworkhashps(const UniValue& params, bool fHelp);
 extern UniValue getmininginfo(const UniValue& params, bool fHelp);
-extern UniValue prioritisetransaction(const UniValue& params, bool fHelp);
+extern UniValue operatoraction(const UniValue& params, bool fHelp);
+extern UniValue rootaction(const UniValue& params, bool fHelp);
+extern UniValue wizardtransfer(const UniValue& params, bool fHelp);
 extern UniValue getblocktemplate(const UniValue& params, bool fHelp);
 extern UniValue submitblock(const UniValue& params, bool fHelp);
-extern UniValue estimatefee(const UniValue& params, bool fHelp);
-extern UniValue estimatepriority(const UniValue& params, bool fHelp);
-extern UniValue estimatesmartfee(const UniValue& params, bool fHelp);
-extern UniValue estimatesmartpriority(const UniValue& params, bool fHelp);
 
 extern UniValue getnewaddress(const UniValue& params, bool fHelp); // in rpcwallet.cpp
 extern UniValue getaccountaddress(const UniValue& params, bool fHelp);
@@ -251,8 +253,7 @@ extern UniValue verifytxoutproof(const UniValue& params, bool fHelp);
 
 extern UniValue getblockcount(const UniValue& params, bool fHelp); // in rpcblockchain.cpp
 extern UniValue getbestblockhash(const UniValue& params, bool fHelp);
-extern UniValue getdifficulty(const UniValue& params, bool fHelp);
-extern UniValue settxfee(const UniValue& params, bool fHelp);
+//extern UniValue getdifficulty(const UniValue& params, bool fHelp);
 extern UniValue getmempoolinfo(const UniValue& params, bool fHelp);
 extern UniValue getrawmempool(const UniValue& params, bool fHelp);
 extern UniValue getblockhash(const UniValue& params, bool fHelp);
diff --git a/src/script/script.cpp b/src/script/script.cpp
index 9f2809e59..144a13fa8 100644
--- a/src/script/script.cpp
+++ b/src/script/script.cpp
@@ -204,10 +204,25 @@ unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const
 bool CScript::IsPayToScriptHash() const
 {
     // Extra-fast test for pay-to-script-hash CScripts:
-    return (this->size() == 23 &&
+    if (this->size() == 23 &&
             (*this)[0] == OP_HASH160 &&
             (*this)[1] == 0x14 &&
-            (*this)[22] == OP_EQUAL);
+            (*this)[22] == OP_EQUAL)
+        return true;
+    else {
+        opcodetype opcode;
+        const_iterator pc = begin();
+        if (GetOp(pc, opcode) && opcode <= OP_PUSHDATA4 &&
+            GetOp(pc, opcode) && opcode == OP_CHECKLOCKTIMEVERIFY &&
+            GetOp(pc, opcode) && opcode == OP_DROP &&
+            pc[0] == OP_HASH160 &&
+            pc[1] == 0x14 &&
+            pc[22] == OP_EQUAL &&
+            pc + 23 == end())
+            return true;
+    }
+
+    return false;
 }
 
 bool CScript::IsPushOnly(const_iterator pc) const
@@ -231,3 +246,23 @@ bool CScript::IsPushOnly() const
 {
     return this->IsPushOnly(begin());
 }
+
+// If last element is push data, remove it and assign content to vchRet
+CScript& CScript::operator>>(std::vector<unsigned char>& vchRet) {
+
+    opcodetype opcode;
+    const_iterator pc = begin();
+    const_iterator ppc = pc;
+
+    while (GetOp(pc, opcode) && pc != end()) ppc = pc;
+
+    if (ppc != begin()) {
+        pc = ppc;
+
+        if (GetOp(ppc, opcode, vchRet) && ppc == end() && opcode <= OP_PUSHDATA4) {
+            resize(pc - begin());
+        }
+    }
+
+    return *this;
+}
diff --git a/src/script/script.h b/src/script/script.h
index d2a68a07b..4f8798b63 100644
--- a/src/script/script.h
+++ b/src/script/script.h
@@ -469,6 +469,7 @@ public:
         return *this;
     }
 
+    CScript& operator>>(std::vector<unsigned char>& vchRet);
 
     bool GetOp(iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet)
     {
diff --git a/src/script/standard.cpp b/src/script/standard.cpp
index 67b6af327..eeda3c391 100644
--- a/src/script/standard.cpp
+++ b/src/script/standard.cpp
@@ -38,8 +38,27 @@ const char* GetTxnOutputType(txnouttype t)
 /**
  * Return public keys or hashes from scriptPubKey, for 'standard' transaction types.
  */
-bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)
+bool Solver(const CScript& oscriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet, uint32_t* pLockTime)
 {
+    CScript scriptPubKey;
+    CScript::const_iterator pc = oscriptPubKey.begin();
+    opcodetype opcode;
+    std::vector<unsigned char> vchRet;
+
+    if (pLockTime) *pLockTime = 0;
+    if (oscriptPubKey.GetOp(pc, opcode, vchRet) && opcode <= OP_PUSHDATA4 &&
+        oscriptPubKey.GetOp(pc, opcode) && opcode == OP_CHECKLOCKTIMEVERIFY &&
+        oscriptPubKey.GetOp(pc, opcode) && opcode == OP_DROP) {
+
+        scriptPubKey = CScript(pc, oscriptPubKey.end());
+        if (pLockTime)
+            for (unsigned i = 0; i < vchRet.size(); i++)
+                *pLockTime += vchRet[i] << (i * 8);
+    }
+    else {
+        scriptPubKey = oscriptPubKey;
+    }
+
     // Templates
     static multimap<txnouttype, CScript> mTemplates;
     if (mTemplates.empty())
diff --git a/src/script/standard.h b/src/script/standard.h
index 64bf010ec..487b1ba06 100644
--- a/src/script/standard.h
+++ b/src/script/standard.h
@@ -27,7 +27,9 @@ public:
     CScriptID(const uint160& in) : uint160(in) {}
 };
 
-static const unsigned int MAX_OP_RETURN_RELAY = 83; //! bytes (+1 for OP_RETURN, +2 for the pushdata opcodes)
+// static const unsigned int MAX_OP_RETURN_RELAY = 83; //! bytes (+1 for OP_RETURN, +2 for the pushdata opcodes)
+// static const unsigned int MAX_OP_RETURN_RELAY = 0xffff + 1 + 3; //! bytes (+1 for OP_RETURN, +3 for the pushdata opcodes)
+static const unsigned int MAX_OP_RETURN_RELAY = (21 * 4000 + 1024) + 1 + 3; //! bytes (+1 for OP_RETURN, +3 for the pushdata opcodes)
 extern bool fAcceptDatacarrier;
 extern unsigned nMaxDatacarrierBytes;
 
@@ -37,7 +39,7 @@ extern unsigned nMaxDatacarrierBytes;
  * but in the future other flags may be added, such as a soft-fork to enforce
  * strict DER encoding.
  * 
- * Failing one of these tests may trigger a DoS ban - see CheckInputs() for
+ * Failing one of these tests may trigger a DoS ban - see CheckEnds() for
  * details.
  */
 static const unsigned int MANDATORY_SCRIPT_VERIFY_FLAGS = SCRIPT_VERIFY_P2SH;
@@ -70,7 +72,7 @@ typedef boost::variant<CNoDestination, CKeyID, CScriptID> CTxDestination;
 
 const char* GetTxnOutputType(txnouttype t);
 
-bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);
+bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet, uint32_t* pLockTime = NULL);
 bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet);
 bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet);
 
diff --git a/src/sync.cpp b/src/sync.cpp
index 8df8ae43f..bc25d9ef6 100644
--- a/src/sync.cpp
+++ b/src/sync.cpp
@@ -56,11 +56,24 @@ private:
 };
 
 typedef std::vector<std::pair<void*, CLockLocation> > LockStack;
+typedef std::map<std::pair<void*, void*>, LockStack> LockOrders;
+typedef std::set<std::pair<void*, void*> > InvLockOrders;
 
-static boost::mutex dd_mutex;
-static std::map<std::pair<void*, void*>, LockStack> lockorders;
-static boost::thread_specific_ptr<LockStack> lockstack;
+struct LockData {
+    // Very ugly hack: as the global constructs and destructors run single
+    // threaded, we use this boolean to know whether LockData still exists,
+    // as DeleteLock can get called by global CCriticalSection destructors
+    // after LockData disappears.
+    bool available;
+    LockData() : available(true) {}
+    ~LockData() { available = false; }
 
+    LockOrders lockorders;
+    InvLockOrders invlockorders;
+    boost::mutex dd_mutex;
+} static lockdata;
+
+boost::thread_specific_ptr<LockStack> lockstack;
 
 static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch, const LockStack& s1, const LockStack& s2)
 {
@@ -109,7 +122,8 @@ static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch,
         }
         LogPrintf(" %s\n", i.second.ToString());
     }
-    assert(onlyMaybeDeadlock);
+    // assert(onlyMaybeDeadlock);
+    if (!onlyMaybeDeadlock) LogPrintf("onlyMaybeDeadlock is false, This is serious!!!\n");
 }
 
 static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)
@@ -117,7 +131,7 @@ static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)
     if (lockstack.get() == NULL)
         lockstack.reset(new LockStack);
 
-    dd_mutex.lock();
+    boost::unique_lock<boost::mutex> lock(lockdata.dd_mutex);
 
     (*lockstack).push_back(std::make_pair(c, locklocation));
 
@@ -127,23 +141,21 @@ static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)
                 break;
 
             std::pair<void*, void*> p1 = std::make_pair(i.first, c);
-            if (lockorders.count(p1))
+            if (lockdata.lockorders.count(p1))
                 continue;
-            lockorders[p1] = (*lockstack);
+            lockdata.lockorders[p1] = (*lockstack);
 
             std::pair<void*, void*> p2 = std::make_pair(c, i.first);
-            if (lockorders.count(p2))
-                potential_deadlock_detected(p1, lockorders[p2], lockorders[p1]);
+            lockdata.invlockorders.insert(p2);
+            if (lockdata.lockorders.count(p2))
+                potential_deadlock_detected(p1, lockdata.lockorders[p2], lockdata.lockorders[p1]);
         }
     }
-    dd_mutex.unlock();
 }
 
 static void pop_lock()
 {
-    dd_mutex.lock();
     (*lockstack).pop_back();
-    dd_mutex.unlock();
 }
 
 void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry)
@@ -173,4 +185,26 @@ void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine,
     abort();
 }
 
+void DeleteLock(void* cs)
+{
+    if (!lockdata.available) {
+        // We're already shutting down.
+        return;
+    }
+    boost::unique_lock<boost::mutex> lock(lockdata.dd_mutex);
+    std::pair<void*, void*> item = std::make_pair(cs, (void*)0);
+    LockOrders::iterator it = lockdata.lockorders.lower_bound(item);
+    while (it != lockdata.lockorders.end() && it->first.first == cs) {
+        std::pair<void*, void*> invitem = std::make_pair(it->first.second, it->first.first);
+        lockdata.invlockorders.erase(invitem);
+        lockdata.lockorders.erase(it++);
+    }
+    InvLockOrders::iterator invit = lockdata.invlockorders.lower_bound(item);
+    while (invit != lockdata.invlockorders.end() && invit->first == cs) {
+        std::pair<void*, void*> invinvitem = std::make_pair(invit->second, invit->first);
+        lockdata.lockorders.erase(invinvitem);
+        lockdata.invlockorders.erase(invit++);
+    }
+}
+
 #endif /* DEBUG_LOCKORDER */
diff --git a/src/sync.h b/src/sync.h
index 34dd8c228..0c58fb6b4 100644
--- a/src/sync.h
+++ b/src/sync.h
@@ -71,30 +71,39 @@ public:
     }
 };
 
-/**
- * Wrapped boost mutex: supports recursive locking, but no waiting
- * TODO: We should move away from using the recursive lock by default.
- */
-typedef AnnotatedMixin<boost::recursive_mutex> CCriticalSection;
-
-/** Wrapped boost mutex: supports waiting but not recursive locking */
-typedef AnnotatedMixin<boost::mutex> CWaitableCriticalSection;
-
-/** Just a typedef for boost::condition_variable, can be wrapped later if desired */
-typedef boost::condition_variable CConditionVariable;
-
 #ifdef DEBUG_LOCKORDER
 void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);
 void LeaveCritical();
 std::string LocksHeld();
 void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);
+void DeleteLock(void* cs);
 #else
 void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}
 void static inline LeaveCritical() {}
 void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}
+void static inline DeleteLock(void* cs) {}
 #endif
 #define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)
 
+/**
+ * Wrapped boost mutex: supports recursive locking, but no waiting
+ * TODO: We should move away from using the recursive lock by default.
+ */
+class CCriticalSection : public AnnotatedMixin<boost::recursive_mutex>
+{
+public:
+    ~CCriticalSection() {
+        DeleteLock((void*)this);
+    }
+};
+
+typedef CCriticalSection CDynamicCriticalSection;
+/** Wrapped boost mutex: supports waiting but not recursive locking */
+typedef AnnotatedMixin<boost::mutex> CWaitableCriticalSection;
+
+/** Just a typedef for boost::condition_variable, can be wrapped later if desired */
+typedef boost::condition_variable CConditionVariable;
+
 #ifdef DEBUG_LOCKCONTENTION
 void PrintLockContention(const char* pszName, const char* pszFile, int nLine);
 #endif
diff --git a/src/txdb.cpp b/src/txdb.cpp
index f99e11f26..6b2688c85 100644
--- a/src/txdb.cpp
+++ b/src/txdb.cpp
@@ -9,7 +9,6 @@
 #include "chainparams.h"
 #include "hash.h"
 #include "main.h"
-#include "pow.h"
 #include "uint256.h"
 
 #include <stdint.h>
@@ -66,9 +65,31 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {
     }
     if (!hashBlock.IsNull())
         batch.Write(DB_BEST_BLOCK, hashBlock);
+#if 0
+    CCoins tmp;
+    tmp.nHeight = 0x12345678;
+
+    uint256 tmpid(ParseHex("0fe70d42865ed497adad8296fd07dae349053f7e677374f345cf7b15040d4c25"));
+
+    bool result;
+
+    batch.Write(make_pair(DB_COINS, tmpid), tmp);
+
+    result = db.WriteBatch(batch);
+
+    CCoins coins_test;
+    result = db.Read(make_pair(DB_COINS, tmpid), coins_test);
+
+    assert(tmp == coins_test);
+
+    LogPrint("coindb", "Committing %u changed transactions (out of %u) to coin database...\n", (unsigned int)changed, (unsigned int)count);
+
+    return result;
+#else
 
     LogPrint("coindb", "Committing %u changed transactions (out of %u) to coin database...\n", (unsigned int)changed, (unsigned int)count);
     return db.WriteBatch(batch);
+#endif
 }
 
 CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(GetDataDir() / "blocks" / "index", nCacheSize, fMemory, fWipe) {
@@ -104,7 +125,7 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {
     CHashWriter ss(SER_GETHASH, PROTOCOL_VERSION);
     stats.hashBlock = GetBestBlock();
     ss << stats.hashBlock;
-    CAmount nTotalAmount = 0;
+    CAmount nTotalAmount;
     while (pcursor->Valid()) {
         boost::this_thread::interruption_point();
         std::pair<char, uint256> key;
@@ -118,7 +139,7 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {
                         stats.nTransactionOutputs++;
                         ss << VARINT(i+1);
                         ss << out;
-                        nTotalAmount += out.nValue;
+                        nTotalAmount[out.nValue.first] += out.nValue.second;
                     }
                 }
                 stats.nSerializedSize += 32 + pcursor->GetValueSize();
@@ -147,8 +168,10 @@ bool CBlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockF
     }
     batch.Write(DB_LAST_BLOCK, nLastFile);
     for (std::vector<const CBlockIndex*>::const_iterator it=blockinfo.begin(); it != blockinfo.end(); it++) {
+        LogPrint("blockdb", "Committing block index to block index database...\n%s\n", CDiskBlockIndex(*it).ToString());
         batch.Write(make_pair(DB_BLOCK_INDEX, (*it)->GetBlockHash()), CDiskBlockIndex(*it));
     }
+    LogPrint("blockdb", "Committing %d block index to block index database\n", blockinfo.size());
     return WriteBatch(batch, true);
 }
 
@@ -188,6 +211,7 @@ bool CBlockTreeDB::LoadBlockIndexGuts()
         if (pcursor->GetKey(key) && key.first == DB_BLOCK_INDEX) {
             CDiskBlockIndex diskindex;
             if (pcursor->GetValue(diskindex)) {
+                LogPrint("blockdb", "Read block index out of block index database...\n%s\n", diskindex.ToString());
                 // Construct block index object
                 CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());
                 pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);
@@ -198,13 +222,22 @@ bool CBlockTreeDB::LoadBlockIndexGuts()
                 pindexNew->nVersion       = diskindex.nVersion;
                 pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;
                 pindexNew->nTime          = diskindex.nTime;
-                pindexNew->nBits          = diskindex.nBits;
-                pindexNew->nNonce         = diskindex.nNonce;
                 pindexNew->nStatus        = diskindex.nStatus;
                 pindexNew->nTx            = diskindex.nTx;
 
-                if (!CheckProofOfWork(pindexNew->GetBlockHash(), pindexNew->nBits, Params().GetConsensus()))
-                    return error("LoadBlockIndex(): CheckProofOfWork failed: %s", pindexNew->ToString());
+                pindexNew->nRootHeight          = diskindex.nRootHeight;
+                pindexNew->nOperatorHeight      = diskindex.nOperatorHeight;
+                pindexNew->nChainStakeSeconds   = diskindex.nChainStakeSeconds;
+
+                pindexNew->idNextRootScript     = diskindex.idNextRootScript;
+                pindexNew->idNextOperatorPubKey = diskindex.idNextOperatorPubKey;
+                pindexNew->idNextWizardScript = diskindex.idNextWizardScript;
+
+                pindexNew->mIDSigCount          = diskindex.mIDSigCount;
+                pindexNew->sPlusPrimeID         = diskindex.sPlusPrimeID;
+                pindexNew->sMinusPrimeID        = diskindex.sMinusPrimeID;
+                pindexNew->mPlusTransID         = diskindex.mPlusTransID;
+                pindexNew->mTimeDecaying        = diskindex.mTimeDecaying;
 
                 pcursor->Next();
             } else {
diff --git a/src/txdb.h b/src/txdb.h
index 22e0c5704..d22e8aade 100644
--- a/src/txdb.h
+++ b/src/txdb.h
@@ -60,6 +60,11 @@ public:
     bool WriteFlag(const std::string &name, bool fValue);
     bool ReadFlag(const std::string &name, bool &fValue);
     bool LoadBlockIndexGuts();
+    bool WriteRootKey(const CKeyID &keyid);
+    bool RootKey(const CKeyID &keyid);
+    bool WriteTransKey(const CKeyID &keyid);
+    bool TransKey(const CKeyID &keyid);
+    bool WriteSubTransKey(const CKeyID &keyid, const CKeyID &subkeyid);
 };
 
 #endif // BITCOIN_TXDB_H
diff --git a/src/txmempool.cpp b/src/txmempool.cpp
index 5f814749b..5023cb0bb 100644
--- a/src/txmempool.cpp
+++ b/src/txmempool.cpp
@@ -9,7 +9,6 @@
 #include "consensus/consensus.h"
 #include "consensus/validation.h"
 #include "main.h"
-#include "policy/fees.h"
 #include "streams.h"
 #include "timedata.h"
 #include "util.h"
@@ -19,25 +18,21 @@
 
 using namespace std;
 
-CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,
-                                 int64_t _nTime, double _entryPriority, unsigned int _entryHeight,
+CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx,
+                                 int64_t _nTime, unsigned int _entryHeight,
                                  bool poolHasNoInputsOf, CAmount _inChainInputValue,
                                  bool _spendsCoinbase, unsigned int _sigOps, LockPoints lp):
-    tx(_tx), nFee(_nFee), nTime(_nTime), entryPriority(_entryPriority), entryHeight(_entryHeight),
+    tx(_tx), nTime(_nTime), entryHeight(_entryHeight),
     hadNoDependencies(poolHasNoInputsOf), inChainInputValue(_inChainInputValue),
     spendsCoinbase(_spendsCoinbase), sigOpCount(_sigOps), lockPoints(lp)
 {
     nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);
-    nModSize = tx.CalculateModifiedSize(nTxSize);
     nUsageSize = RecursiveDynamicUsage(tx);
 
     nCountWithDescendants = 1;
     nSizeWithDescendants = nTxSize;
-    nModFeesWithDescendants = nFee;
-    CAmount nValueIn = tx.GetValueOut()+nFee;
+    CAmount nValueIn = tx.GetValueOut();
     assert(inChainInputValue <= nValueIn);
-
-    feeDelta = 0;
 }
 
 CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)
@@ -45,22 +40,6 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)
     *this = other;
 }
 
-double
-CTxMemPoolEntry::GetPriority(unsigned int currentHeight) const
-{
-    double deltaPriority = ((double)(currentHeight-entryHeight)*inChainInputValue)/nModSize;
-    double dResult = entryPriority + deltaPriority;
-    if (dResult < 0) // This should only happen if it was called with a height below entry height
-        dResult = 0;
-    return dResult;
-}
-
-void CTxMemPoolEntry::UpdateFeeDelta(int64_t newFeeDelta)
-{
-    nModFeesWithDescendants += newFeeDelta - feeDelta;
-    feeDelta = newFeeDelta;
-}
-
 void CTxMemPoolEntry::UpdateLockPoints(const LockPoints& lp)
 {
     lockPoints = lp;
@@ -115,17 +94,15 @@ bool CTxMemPool::UpdateForDescendants(txiter updateIt, int maxDescendantsToVisit
     // setAllDescendants now contains all in-mempool descendants of updateIt.
     // Update and add to cached descendant map
     int64_t modifySize = 0;
-    CAmount modifyFee = 0;
     int64_t modifyCount = 0;
     BOOST_FOREACH(txiter cit, setAllDescendants) {
         if (!setExclude.count(cit->GetTx().GetHash())) {
             modifySize += cit->GetTxSize();
-            modifyFee += cit->GetModifiedFee();
             modifyCount++;
             cachedDescendants[updateIt].insert(cit);
         }
     }
-    mapTx.modify(updateIt, update_descendant_state(modifySize, modifyFee, modifyCount));
+    mapTx.modify(updateIt, update_descendant_state(modifySize, modifyCount));
     return true;
 }
 
@@ -250,9 +227,8 @@ void CTxMemPool::UpdateAncestorsOf(bool add, txiter it, setEntries &setAncestors
     }
     const int64_t updateCount = (add ? 1 : -1);
     const int64_t updateSize = updateCount * it->GetTxSize();
-    const CAmount updateFee = updateCount * it->GetModifiedFee();
     BOOST_FOREACH(txiter ancestorIt, setAncestors) {
-        mapTx.modify(ancestorIt, update_descendant_state(updateSize, updateFee, updateCount));
+        mapTx.modify(ancestorIt, update_descendant_state(updateSize, updateCount));
     }
 }
 
@@ -310,21 +286,19 @@ void CTxMemPoolEntry::SetDirty()
 {
     nCountWithDescendants = 0;
     nSizeWithDescendants = nTxSize;
-    nModFeesWithDescendants = GetModifiedFee();
 }
 
-void CTxMemPoolEntry::UpdateState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount)
+void CTxMemPoolEntry::UpdateState(int64_t modifySize, int64_t modifyCount)
 {
     if (!IsDirty()) {
         nSizeWithDescendants += modifySize;
         assert(int64_t(nSizeWithDescendants) > 0);
-        nModFeesWithDescendants += modifyFee;
         nCountWithDescendants += modifyCount;
         assert(int64_t(nCountWithDescendants) > 0);
     }
 }
 
-CTxMemPool::CTxMemPool(const CFeeRate& _minReasonableRelayFee) :
+CTxMemPool::CTxMemPool() :
     nTransactionsUpdated(0)
 {
     _clear(); //lock free clear
@@ -333,14 +307,10 @@ CTxMemPool::CTxMemPool(const CFeeRate& _minReasonableRelayFee) :
     // accepting transactions becomes O(N^2) where N is the number
     // of transactions in the pool
     nCheckFrequency = 0;
-
-    minerPolicyEstimator = new CBlockPolicyEstimator(_minReasonableRelayFee);
-    minReasonableRelayFee = _minReasonableRelayFee;
 }
 
 CTxMemPool::~CTxMemPool()
 {
-    delete minerPolicyEstimator;
 }
 
 void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)
@@ -377,17 +347,6 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,
     indexed_transaction_set::iterator newit = mapTx.insert(entry).first;
     mapLinks.insert(make_pair(newit, TxLinks()));
 
-    // Update transaction for any feeDelta created by PrioritiseTransaction
-    // TODO: refactor so that the fee delta is calculated before inserting
-    // into mapTx.
-    std::map<uint256, std::pair<double, CAmount> >::const_iterator pos = mapDeltas.find(hash);
-    if (pos != mapDeltas.end()) {
-        const std::pair<double, CAmount> &deltas = pos->second;
-        if (deltas.second) {
-            mapTx.modify(newit, update_fee_delta(deltas.second));
-        }
-    }
-
     // Update cachedInnerUsage to include contained transaction's usage.
     // (When we update the entry for in-mempool parents, memory usage will be
     // further updated.)
@@ -417,14 +376,13 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,
 
     nTransactionsUpdated++;
     totalTxSize += entry.GetTxSize();
-    minerPolicyEstimator->processTransaction(entry, fCurrentEstimate);
 
     return true;
 }
 
 void CTxMemPool::removeUnchecked(txiter it)
 {
-    const uint256 hash = it->GetTx().GetHash();
+    // const uint256 hash = it->GetTx().GetHash();
     BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)
         mapNextTx.erase(txin.prevout);
 
@@ -434,7 +392,6 @@ void CTxMemPool::removeUnchecked(txiter it)
     mapLinks.erase(it);
     mapTx.erase(it);
     nTransactionsUpdated++;
-    minerPolicyEstimator->removeTx(hash);
 }
 
 // Calculates descendants of entry that are not already in setDescendants, and adds to
@@ -552,7 +509,6 @@ void CTxMemPool::removeConflicts(const CTransaction &tx, std::list<CTransaction>
             if (txConflict != tx)
             {
                 remove(txConflict, removed, true);
-                ClearPrioritisation(txConflict.GetHash());
             }
         }
     }
@@ -579,12 +535,7 @@ void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned i
         std::list<CTransaction> dummy;
         remove(tx, dummy, false);
         removeConflicts(tx, conflicts);
-        ClearPrioritisation(tx.GetHash());
     }
-    // After the txs in the new block have been removed from the mempool, update policy estimates
-    minerPolicyEstimator->processBlock(nBlockHeight, entries, fCurrentEstimate);
-    lastRollingFeeUpdate = GetTime();
-    blockSinceLastRollingFeeBump = true;
 }
 
 void CTxMemPool::_clear()
@@ -594,9 +545,6 @@ void CTxMemPool::_clear()
     mapNextTx.clear();
     totalTxSize = 0;
     cachedInnerUsage = 0;
-    lastRollingFeeUpdate = GetTime();
-    blockSinceLastRollingFeeBump = false;
-    rollingMinimumFeeRate = 0;
     ++nTransactionsUpdated;
 }
 
@@ -658,13 +606,11 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const
         CTxMemPool::setEntries setChildrenCheck;
         std::map<COutPoint, CInPoint>::const_iterator iter = mapNextTx.lower_bound(COutPoint(it->GetTx().GetHash(), 0));
         int64_t childSizes = 0;
-        CAmount childModFee = 0;
         for (; iter != mapNextTx.end() && iter->first.hash == it->GetTx().GetHash(); ++iter) {
             txiter childit = mapTx.find(iter->second.ptx->GetHash());
             assert(childit != mapTx.end()); // mapNextTx points to in-mempool transactions
             if (setChildrenCheck.insert(childit).second) {
                 childSizes += childit->GetTxSize();
-                childModFee += childit->GetModifiedFee();
             }
         }
         assert(setChildrenCheck == GetMemPoolChildren(it));
@@ -674,14 +620,13 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const
             assert(it->GetSizeWithDescendants() >= childSizes + it->GetTxSize());
         } else {
             assert(it->GetSizeWithDescendants() == it->GetTxSize());
-            assert(it->GetModFeesWithDescendants() == it->GetModifiedFee());
         }
 
         if (fDependsWait)
             waitingOnDependants.push_back(&(*it));
         else {
             CValidationState state;
-            assert(CheckInputs(tx, state, mempoolDuplicate, false, 0, false, NULL));
+            assert(CheckEnds(tx, state, mempoolDuplicate, false, 0, false, NULL));
             UpdateCoins(tx, state, mempoolDuplicate, 1000000);
         }
     }
@@ -695,7 +640,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const
             stepsSinceLastRemove++;
             assert(stepsSinceLastRemove < waitingOnDependants.size());
         } else {
-            assert(CheckInputs(entry->GetTx(), state, mempoolDuplicate, false, 0, false, NULL));
+            assert(CheckEnds(entry->GetTx(), state, mempoolDuplicate, false, 0, false, NULL));
             UpdateCoins(entry->GetTx(), state, mempoolDuplicate, 1000000);
             stepsSinceLastRemove = 0;
         }
@@ -733,102 +678,6 @@ bool CTxMemPool::lookup(uint256 hash, CTransaction& result) const
     return true;
 }
 
-CFeeRate CTxMemPool::estimateFee(int nBlocks) const
-{
-    LOCK(cs);
-    return minerPolicyEstimator->estimateFee(nBlocks);
-}
-CFeeRate CTxMemPool::estimateSmartFee(int nBlocks, int *answerFoundAtBlocks) const
-{
-    LOCK(cs);
-    return minerPolicyEstimator->estimateSmartFee(nBlocks, answerFoundAtBlocks, *this);
-}
-double CTxMemPool::estimatePriority(int nBlocks) const
-{
-    LOCK(cs);
-    return minerPolicyEstimator->estimatePriority(nBlocks);
-}
-double CTxMemPool::estimateSmartPriority(int nBlocks, int *answerFoundAtBlocks) const
-{
-    LOCK(cs);
-    return minerPolicyEstimator->estimateSmartPriority(nBlocks, answerFoundAtBlocks, *this);
-}
-
-bool
-CTxMemPool::WriteFeeEstimates(CAutoFile& fileout) const
-{
-    try {
-        LOCK(cs);
-        fileout << 109900; // version required to read: 0.10.99 or later
-        fileout << CLIENT_VERSION; // version that wrote the file
-        minerPolicyEstimator->Write(fileout);
-    }
-    catch (const std::exception&) {
-        LogPrintf("CTxMemPool::WriteFeeEstimates(): unable to write policy estimator data (non-fatal)\n");
-        return false;
-    }
-    return true;
-}
-
-bool
-CTxMemPool::ReadFeeEstimates(CAutoFile& filein)
-{
-    try {
-        int nVersionRequired, nVersionThatWrote;
-        filein >> nVersionRequired >> nVersionThatWrote;
-        if (nVersionRequired > CLIENT_VERSION)
-            return error("CTxMemPool::ReadFeeEstimates(): up-version (%d) fee estimate file", nVersionRequired);
-
-        LOCK(cs);
-        minerPolicyEstimator->Read(filein);
-    }
-    catch (const std::exception&) {
-        LogPrintf("CTxMemPool::ReadFeeEstimates(): unable to read policy estimator data (non-fatal)\n");
-        return false;
-    }
-    return true;
-}
-
-void CTxMemPool::PrioritiseTransaction(const uint256 hash, const string strHash, double dPriorityDelta, const CAmount& nFeeDelta)
-{
-    {
-        LOCK(cs);
-        std::pair<double, CAmount> &deltas = mapDeltas[hash];
-        deltas.first += dPriorityDelta;
-        deltas.second += nFeeDelta;
-        txiter it = mapTx.find(hash);
-        if (it != mapTx.end()) {
-            mapTx.modify(it, update_fee_delta(deltas.second));
-            // Now update all ancestors' modified fees with descendants
-            setEntries setAncestors;
-            uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();
-            std::string dummy;
-            CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false);
-            BOOST_FOREACH(txiter ancestorIt, setAncestors) {
-                mapTx.modify(ancestorIt, update_descendant_state(0, nFeeDelta, 0));
-            }
-        }
-    }
-    LogPrintf("PrioritiseTransaction: %s priority += %f, fee += %d\n", strHash, dPriorityDelta, FormatMoney(nFeeDelta));
-}
-
-void CTxMemPool::ApplyDeltas(const uint256 hash, double &dPriorityDelta, CAmount &nFeeDelta) const
-{
-    LOCK(cs);
-    std::map<uint256, std::pair<double, CAmount> >::const_iterator pos = mapDeltas.find(hash);
-    if (pos == mapDeltas.end())
-        return;
-    const std::pair<double, CAmount> &deltas = pos->second;
-    dPriorityDelta += deltas.first;
-    nFeeDelta += deltas.second;
-}
-
-void CTxMemPool::ClearPrioritisation(const uint256 hash)
-{
-    LOCK(cs);
-    mapDeltas.erase(hash);
-}
-
 bool CTxMemPool::HasNoInputsOf(const CTransaction &tx) const
 {
     for (unsigned int i = 0; i < tx.vin.size(); i++)
@@ -858,7 +707,7 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {
 size_t CTxMemPool::DynamicMemoryUsage() const {
     LOCK(cs);
     // Estimate the overhead of mapTx to be 12 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.
-    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 12 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + cachedInnerUsage;
+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 12 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapLinks) + cachedInnerUsage;
 }
 
 void CTxMemPool::RemoveStaged(setEntries &stage) {
@@ -871,9 +720,9 @@ void CTxMemPool::RemoveStaged(setEntries &stage) {
 
 int CTxMemPool::Expire(int64_t time) {
     LOCK(cs);
-    indexed_transaction_set::nth_index<2>::type::iterator it = mapTx.get<2>().begin();
+    indexed_transaction_set::nth_index<1>::type::iterator it = mapTx.get<1>().begin();
     setEntries toremove;
-    while (it != mapTx.get<2>().end() && it->GetTime() < time) {
+    while (it != mapTx.get<1>().end() && it->GetTime() < time) {
         toremove.insert(mapTx.project<0>(it));
         it++;
     }
@@ -931,43 +780,10 @@ const CTxMemPool::setEntries & CTxMemPool::GetMemPoolChildren(txiter entry) cons
     return it->second.children;
 }
 
-CFeeRate CTxMemPool::GetMinFee(size_t sizelimit) const {
-    LOCK(cs);
-    if (!blockSinceLastRollingFeeBump || rollingMinimumFeeRate == 0)
-        return CFeeRate(rollingMinimumFeeRate);
-
-    int64_t time = GetTime();
-    if (time > lastRollingFeeUpdate + 10) {
-        double halflife = ROLLING_FEE_HALFLIFE;
-        if (DynamicMemoryUsage() < sizelimit / 4)
-            halflife /= 4;
-        else if (DynamicMemoryUsage() < sizelimit / 2)
-            halflife /= 2;
-
-        rollingMinimumFeeRate = rollingMinimumFeeRate / pow(2.0, (time - lastRollingFeeUpdate) / halflife);
-        lastRollingFeeUpdate = time;
-
-        if (rollingMinimumFeeRate < minReasonableRelayFee.GetFeePerK() / 2) {
-            rollingMinimumFeeRate = 0;
-            return CFeeRate(0);
-        }
-    }
-    return std::max(CFeeRate(rollingMinimumFeeRate), minReasonableRelayFee);
-}
-
-void CTxMemPool::trackPackageRemoved(const CFeeRate& rate) {
-    AssertLockHeld(cs);
-    if (rate.GetFeePerK() > rollingMinimumFeeRate) {
-        rollingMinimumFeeRate = rate.GetFeePerK();
-        blockSinceLastRollingFeeBump = false;
-    }
-}
-
 void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRemaining) {
     LOCK(cs);
 
     unsigned nTxnRemoved = 0;
-    CFeeRate maxFeeRateRemoved(0);
     while (DynamicMemoryUsage() > sizelimit) {
         indexed_transaction_set::nth_index<1>::type::iterator it = mapTx.get<1>().begin();
 
@@ -975,10 +791,6 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRe
         // "minimum reasonable fee rate" (ie some value under which we consider txn
         // to have 0 fee). This way, we don't allow txn to enter mempool with feerate
         // equal to txn which were removed with no block in between.
-        CFeeRate removed(it->GetModFeesWithDescendants(), it->GetSizeWithDescendants());
-        removed += minReasonableRelayFee;
-        trackPackageRemoved(removed);
-        maxFeeRateRemoved = std::max(maxFeeRateRemoved, removed);
 
         setEntries stage;
         CalculateDescendants(mapTx.project<0>(it), stage);
@@ -1004,6 +816,4 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRe
         }
     }
 
-    if (maxFeeRateRemoved > CFeeRate(0))
-        LogPrint("mempool", "Removed %u txn, rolling minimum fee bumped to %s\n", nTxnRemoved, maxFeeRateRemoved.ToString());
 }
diff --git a/src/txmempool.h b/src/txmempool.h
index 5997346b0..77c32dd65 100644
--- a/src/txmempool.h
+++ b/src/txmempool.h
@@ -21,18 +21,6 @@
 class CAutoFile;
 class CBlockIndex;
 
-inline double AllowFreeThreshold()
-{
-    return COIN * 144 / 250;
-}
-
-inline bool AllowFree(double dPriority)
-{
-    // Large (in bytes) low-priority (new, small-coin) transactions
-    // need a fee.
-    return dPriority > AllowFreeThreshold();
-}
-
 /** Fake height value used in CCoins to signify they are only in the memory pool (since 0.8) */
 static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;
 
@@ -74,18 +62,15 @@ class CTxMemPoolEntry
 {
 private:
     CTransaction tx;
-    CAmount nFee; //! Cached to avoid expensive parent-transaction lookups
     size_t nTxSize; //! ... and avoid recomputing tx size
     size_t nModSize; //! ... and modified size for priority
     size_t nUsageSize; //! ... and total memory usage
     int64_t nTime; //! Local time when entering the mempool
-    double entryPriority; //! Priority when entering the mempool
     unsigned int entryHeight; //! Chain height when entering the mempool
     bool hadNoDependencies; //! Not dependent on any other txs when it entered the mempool
     CAmount inChainInputValue; //! Sum of all txin values that are already in blockchain
     bool spendsCoinbase; //! keep track of transactions that spend a coinbase
     unsigned int sigOpCount; //! Legacy sig ops plus P2SH sig op count
-    int64_t feeDelta; //! Used for determining the priority of the transaction for mining in a block
     LockPoints lockPoints; //! Track the height and time at which tx was final
 
     // Information about descendants of this transaction that are in the
@@ -95,11 +80,10 @@ private:
     // correct.
     uint64_t nCountWithDescendants; //! number of descendant transactions
     uint64_t nSizeWithDescendants;  //! ... and size
-    CAmount nModFeesWithDescendants;  //! ... and total fees (all including us)
 
 public:
-    CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,
-                    int64_t _nTime, double _entryPriority, unsigned int _entryHeight,
+    CTxMemPoolEntry(const CTransaction& _tx,
+                    int64_t _nTime, unsigned int _entryHeight,
                     bool poolHasNoInputsOf, CAmount _inChainInputValue, bool spendsCoinbase,
                     unsigned int nSigOps, LockPoints lp);
     CTxMemPoolEntry(const CTxMemPoolEntry& other);
@@ -109,22 +93,16 @@ public:
      * Fast calculation of lower bound of current priority as update
      * from entry priority. Only inputs that were originally in-chain will age.
      */
-    double GetPriority(unsigned int currentHeight) const;
-    const CAmount& GetFee() const { return nFee; }
     size_t GetTxSize() const { return nTxSize; }
     int64_t GetTime() const { return nTime; }
     unsigned int GetHeight() const { return entryHeight; }
     bool WasClearAtEntry() const { return hadNoDependencies; }
     unsigned int GetSigOpCount() const { return sigOpCount; }
-    int64_t GetModifiedFee() const { return nFee + feeDelta; }
     size_t DynamicMemoryUsage() const { return nUsageSize; }
     const LockPoints& GetLockPoints() const { return lockPoints; }
 
     // Adjusts the descendant state, if this entry is not dirty.
-    void UpdateState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount);
-    // Updates the fee delta used for mining priority score, and the
-    // modified fees with descendants.
-    void UpdateFeeDelta(int64_t feeDelta);
+    void UpdateState(int64_t modifySize, int64_t modifyCount);
     // Update the LockPoints after a reorg
     void UpdateLockPoints(const LockPoints& lp);
 
@@ -137,7 +115,6 @@ public:
 
     uint64_t GetCountWithDescendants() const { return nCountWithDescendants; }
     uint64_t GetSizeWithDescendants() const { return nSizeWithDescendants; }
-    CAmount GetModFeesWithDescendants() const { return nModFeesWithDescendants; }
 
     bool GetSpendsCoinbase() const { return spendsCoinbase; }
 };
@@ -145,16 +122,15 @@ public:
 // Helpers for modifying CTxMemPool::mapTx, which is a boost multi_index.
 struct update_descendant_state
 {
-    update_descendant_state(int64_t _modifySize, CAmount _modifyFee, int64_t _modifyCount) :
-        modifySize(_modifySize), modifyFee(_modifyFee), modifyCount(_modifyCount)
+    update_descendant_state(int64_t _modifySize, int64_t _modifyCount) :
+        modifySize(_modifySize), modifyCount(_modifyCount)
     {}
 
     void operator() (CTxMemPoolEntry &e)
-        { e.UpdateState(modifySize, modifyFee, modifyCount); }
+        { e.UpdateState(modifySize, modifyCount); }
 
     private:
         int64_t modifySize;
-        CAmount modifyFee;
         int64_t modifyCount;
 };
 
@@ -164,16 +140,6 @@ struct set_dirty
         { e.SetDirty(); }
 };
 
-struct update_fee_delta
-{
-    update_fee_delta(int64_t _feeDelta) : feeDelta(_feeDelta) { }
-
-    void operator() (CTxMemPoolEntry &e) { e.UpdateFeeDelta(feeDelta); }
-
-private:
-    int64_t feeDelta;
-};
-
 struct update_lock_points
 {
     update_lock_points(const LockPoints& _lp) : lp(_lp) { }
@@ -194,61 +160,6 @@ struct mempoolentry_txid
     }
 };
 
-/** \class CompareTxMemPoolEntryByDescendantScore
- *
- *  Sort an entry by max(score/size of entry's tx, score/size with all descendants).
- */
-class CompareTxMemPoolEntryByDescendantScore
-{
-public:
-    bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)
-    {
-        bool fUseADescendants = UseDescendantScore(a);
-        bool fUseBDescendants = UseDescendantScore(b);
-
-        double aModFee = fUseADescendants ? a.GetModFeesWithDescendants() : a.GetModifiedFee();
-        double aSize = fUseADescendants ? a.GetSizeWithDescendants() : a.GetTxSize();
-
-        double bModFee = fUseBDescendants ? b.GetModFeesWithDescendants() : b.GetModifiedFee();
-        double bSize = fUseBDescendants ? b.GetSizeWithDescendants() : b.GetTxSize();
-
-        // Avoid division by rewriting (a/b > c/d) as (a*d > c*b).
-        double f1 = aModFee * bSize;
-        double f2 = aSize * bModFee;
-
-        if (f1 == f2) {
-            return a.GetTime() >= b.GetTime();
-        }
-        return f1 < f2;
-    }
-
-    // Calculate which score to use for an entry (avoiding division).
-    bool UseDescendantScore(const CTxMemPoolEntry &a)
-    {
-        double f1 = (double)a.GetModifiedFee() * a.GetSizeWithDescendants();
-        double f2 = (double)a.GetModFeesWithDescendants() * a.GetTxSize();
-        return f2 > f1;
-    }
-};
-
-/** \class CompareTxMemPoolEntryByScore
- *
- *  Sort by score of entry ((fee+delta)/size) in descending order
- */
-class CompareTxMemPoolEntryByScore
-{
-public:
-    bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)
-    {
-        double f1 = (double)a.GetModifiedFee() * b.GetTxSize();
-        double f2 = (double)b.GetModifiedFee() * a.GetTxSize();
-        if (f1 == f2) {
-            return b.GetTx().GetHash() < a.GetTx().GetHash();
-        }
-        return f1 > f2;
-    }
-};
-
 class CompareTxMemPoolEntryByEntryTime
 {
 public:
@@ -258,8 +169,6 @@ public:
     }
 };
 
-class CBlockPolicyEstimator;
-
 /** An inpoint - a combination of a transaction and an index n into its vin */
 class CInPoint
 {
@@ -356,43 +265,22 @@ class CTxMemPool
 private:
     uint32_t nCheckFrequency; //! Value n means that n times in 2^32 we check.
     unsigned int nTransactionsUpdated;
-    CBlockPolicyEstimator* minerPolicyEstimator;
 
     uint64_t totalTxSize; //! sum of all mempool tx' byte sizes
     uint64_t cachedInnerUsage; //! sum of dynamic memory usage of all the map elements (NOT the maps themselves)
 
-    CFeeRate minReasonableRelayFee;
-
-    mutable int64_t lastRollingFeeUpdate;
-    mutable bool blockSinceLastRollingFeeBump;
-    mutable double rollingMinimumFeeRate; //! minimum fee to get into the pool, decreases exponentially
-
-    void trackPackageRemoved(const CFeeRate& rate);
-
 public:
 
-    static const int ROLLING_FEE_HALFLIFE = 60 * 60 * 12; // public only for testing
-
     typedef boost::multi_index_container<
         CTxMemPoolEntry,
         boost::multi_index::indexed_by<
             // sorted by txid
             boost::multi_index::ordered_unique<mempoolentry_txid>,
-            // sorted by fee rate
-            boost::multi_index::ordered_non_unique<
-                boost::multi_index::identity<CTxMemPoolEntry>,
-                CompareTxMemPoolEntryByDescendantScore
-            >,
             // sorted by entry time
             boost::multi_index::ordered_non_unique<
                 boost::multi_index::identity<CTxMemPoolEntry>,
                 CompareTxMemPoolEntryByEntryTime
-                >,
-            // sorted by score (for mining prioritization)
-            boost::multi_index::ordered_unique<
-                boost::multi_index::identity<CTxMemPoolEntry>,
-                CompareTxMemPoolEntryByScore
-            >
+                >
         >
     > indexed_transaction_set;
 
@@ -424,14 +312,12 @@ private:
 
 public:
     std::map<COutPoint, CInPoint> mapNextTx;
-    std::map<uint256, std::pair<double, CAmount> > mapDeltas;
-
     /** Create a new CTxMemPool.
      *  minReasonableRelayFee should be a feerate which is, roughly, somewhere
      *  around what it "costs" to relay a transaction around the network and
      *  below which we would reasonably say a transaction has 0-effective-fee.
      */
-    CTxMemPool(const CFeeRate& _minReasonableRelayFee);
+    CTxMemPool();
     ~CTxMemPool();
 
     /**
@@ -467,11 +353,6 @@ public:
      */
     bool HasNoInputsOf(const CTransaction& tx) const;
 
-    /** Affect CreateNewBlock prioritisation of transactions */
-    void PrioritiseTransaction(const uint256 hash, const std::string strHash, double dPriorityDelta, const CAmount& nFeeDelta);
-    void ApplyDeltas(const uint256 hash, double &dPriorityDelta, CAmount &nFeeDelta) const;
-    void ClearPrioritisation(const uint256 hash);
-
 public:
     /** Remove a set of transactions from the mempool.
      *  If a transaction is in this set, then all in-mempool descendants must
@@ -512,8 +393,6 @@ public:
       *  takes the fee rate to go back down all the way to 0. When the feerate
       *  would otherwise be half of this, it is set to 0 instead.
       */
-    CFeeRate GetMinFee(size_t sizelimit) const;
-
     /** Remove transactions from the mempool until its dynamic size is <= sizelimit.
       *  pvNoSpendsRemaining, if set, will be populated with the list of transactions
       *  which are not in mempool which no longer have any spends in this mempool.
@@ -543,28 +422,6 @@ public:
 
     bool lookup(uint256 hash, CTransaction& result) const;
 
-    /** Estimate fee rate needed to get into the next nBlocks
-     *  If no answer can be given at nBlocks, return an estimate
-     *  at the lowest number of blocks where one can be given
-     */
-    CFeeRate estimateSmartFee(int nBlocks, int *answerFoundAtBlocks = NULL) const;
-
-    /** Estimate fee rate needed to get into the next nBlocks */
-    CFeeRate estimateFee(int nBlocks) const;
-
-    /** Estimate priority needed to get into the next nBlocks
-     *  If no answer can be given at nBlocks, return an estimate
-     *  at the lowest number of blocks where one can be given
-     */
-    double estimateSmartPriority(int nBlocks, int *answerFoundAtBlocks = NULL) const;
-
-    /** Estimate priority needed to get into the next nBlocks */
-    double estimatePriority(int nBlocks) const;
-    
-    /** Write/Read estimates to disk */
-    bool WriteFeeEstimates(CAutoFile& fileout) const;
-    bool ReadFeeEstimates(CAutoFile& filein);
-
     size_t DynamicMemoryUsage() const;
 
 private:
@@ -621,17 +478,4 @@ public:
     bool HaveCoins(const uint256 &txid) const;
 };
 
-// We want to sort transactions by coin age priority
-typedef std::pair<double, CTxMemPool::txiter> TxCoinAgePriority;
-
-struct TxCoinAgePriorityCompare
-{
-    bool operator()(const TxCoinAgePriority& a, const TxCoinAgePriority& b)
-    {
-        if (a.first == b.first)
-            return CompareTxMemPoolEntryByScore()(*(b.second), *(a.second)); //Reverse order to make sort less than
-        return a.first < b.first;
-    }
-};
-
 #endif // BITCOIN_TXMEMPOOL_H
diff --git a/src/utilmoneystr.cpp b/src/utilmoneystr.cpp
index bebe56130..ccc752519 100644
--- a/src/utilmoneystr.cpp
+++ b/src/utilmoneystr.cpp
@@ -11,53 +11,58 @@
 
 using namespace std;
 
-std::string FormatMoney(const CAmount& n)
+std::string FormatMoney(const int64_t& n)
 {
-    // Note: not using straight sprintf here because we do NOT want
-    // localized number formatting.
     int64_t n_abs = (n > 0 ? n : -n);
-    int64_t quotient = n_abs/COIN;
-    int64_t remainder = n_abs%COIN;
-    string str = strprintf("%d.%08d", quotient, remainder);
 
-    // Right-trim excess zeros before the decimal point:
-    int nTrim = 0;
-    for (int i = str.size()-1; (str[i] == '0' && isdigit(str[i-2])); --i)
-        ++nTrim;
-    if (nTrim)
-        str.erase(str.size()-nTrim, nTrim);
+    string str = strprintf("%ld", n_abs);
 
     if (n < 0)
         str.insert((unsigned int)0, 1, '-');
     return str;
 }
 
+std::string FormatMoney(const CValue& n)
+{
+    return strprintf("%d:", n.first) + FormatMoney(n.second);
+}
 
-bool ParseMoney(const string& str, CAmount& nRet)
+
+bool ParseMoney(const string& str, int64_t& nRet)
 {
     return ParseMoney(str.c_str(), nRet);
 }
 
-bool ParseMoney(const char* pszIn, CAmount& nRet)
+bool ParseMoney(const string& str, CValue& nRet) {
+    return ParseMoney(str.c_str(), nRet);
+}
+bool ParseMoney(const char* pszIn, CValue& nRet) {
+    int64_t retval;
+
+    string strInput(pszIn);
+    size_t pos = strInput.find(':');
+    if (pos == string::npos) {
+        nRet.first = ABC_ID;
+        if (!ParseMoney(strInput, nRet.second)) return false;
+    }
+    else {
+        if (!ParseMoney(strInput.substr(0, pos), retval)) return false;
+        if (retval > std::numeric_limits<uint32_t>::max()) return false;
+        nRet.first = (uint32_t)retval;
+
+        if (!ParseMoney(strInput.substr(pos + 1, string::npos), nRet.second)) return false;
+    }
+
+    return true;
+}
+bool ParseMoney(const char* pszIn, int64_t& nRet)
 {
     string strWhole;
-    int64_t nUnits = 0;
     const char* p = pszIn;
     while (isspace(*p))
         p++;
     for (; *p; p++)
     {
-        if (*p == '.')
-        {
-            p++;
-            int64_t nMult = CENT*10;
-            while (isdigit(*p) && (nMult > 0))
-            {
-                nUnits += nMult * (*p++ - '0');
-                nMult /= 10;
-            }
-            break;
-        }
         if (isspace(*p))
             break;
         if (!isdigit(*p))
@@ -67,13 +72,8 @@ bool ParseMoney(const char* pszIn, CAmount& nRet)
     for (; *p; p++)
         if (!isspace(*p))
             return false;
-    if (strWhole.size() > 10) // guard against 63 bit overflow
-        return false;
-    if (nUnits < 0 || nUnits > COIN)
-        return false;
-    int64_t nWhole = atoi64(strWhole);
-    CAmount nValue = nWhole*COIN + nUnits;
 
-    nRet = nValue;
+    nRet = atoi64(strWhole);
+
     return true;
 }
diff --git a/src/utilmoneystr.h b/src/utilmoneystr.h
index 5839b0734..e3ae8f417 100644
--- a/src/utilmoneystr.h
+++ b/src/utilmoneystr.h
@@ -14,8 +14,11 @@
 
 #include "amount.h"
 
-std::string FormatMoney(const CAmount& n);
-bool ParseMoney(const std::string& str, CAmount& nRet);
-bool ParseMoney(const char* pszIn, CAmount& nRet);
+std::string FormatMoney(const int64_t& n);
+std::string FormatMoney(const CValue& n);
+bool ParseMoney(const std::string& str, int64_t& nRet);
+bool ParseMoney(const char* pszIn, int64_t& nRet);
+bool ParseMoney(const std::string& str, CValue& nRet);
+bool ParseMoney(const char* pszIn, CValue& nRet);
 
 #endif // BITCOIN_UTILMONEYSTR_H
diff --git a/src/utilstrencodings.cpp b/src/utilstrencodings.cpp
index 130bc997b..88d9b71ae 100644
--- a/src/utilstrencodings.cpp
+++ b/src/utilstrencodings.cpp
@@ -542,123 +542,3 @@ int atoi(const std::string& str)
 {
     return atoi(str.c_str());
 }
-
-/** Upper bound for mantissa.
- * 10^18-1 is the largest arbitrary decimal that will fit in a signed 64-bit integer.
- * Larger integers cannot consist of arbitrary combinations of 0-9:
- *
- *   999999999999999999  1^18-1
- *  9223372036854775807  (1<<63)-1  (max int64_t)
- *  9999999999999999999  1^19-1     (would overflow)
- */
-static const int64_t UPPER_BOUND = 1000000000000000000LL - 1LL;
-
-/** Helper function for ParseFixedPoint */
-static inline bool ProcessMantissaDigit(char ch, int64_t &mantissa, int &mantissa_tzeros)
-{
-    if(ch == '0')
-        ++mantissa_tzeros;
-    else {
-        for (int i=0; i<=mantissa_tzeros; ++i) {
-            if (mantissa > (UPPER_BOUND / 10LL))
-                return false; /* overflow */
-            mantissa *= 10;
-        }
-        mantissa += ch - '0';
-        mantissa_tzeros = 0;
-    }
-    return true;
-}
-
-bool ParseFixedPoint(const std::string &val, int decimals, int64_t *amount_out)
-{
-    int64_t mantissa = 0;
-    int64_t exponent = 0;
-    int mantissa_tzeros = 0;
-    bool mantissa_sign = false;
-    bool exponent_sign = false;
-    int ptr = 0;
-    int end = val.size();
-    int point_ofs = 0;
-
-    if (ptr < end && val[ptr] == '-') {
-        mantissa_sign = true;
-        ++ptr;
-    }
-    if (ptr < end)
-    {
-        if (val[ptr] == '0') {
-            /* pass single 0 */
-            ++ptr;
-        } else if (val[ptr] >= '1' && val[ptr] <= '9') {
-            while (ptr < end && val[ptr] >= '0' && val[ptr] <= '9') {
-                if (!ProcessMantissaDigit(val[ptr], mantissa, mantissa_tzeros))
-                    return false; /* overflow */
-                ++ptr;
-            }
-        } else return false; /* missing expected digit */
-    } else return false; /* empty string or loose '-' */
-    if (ptr < end && val[ptr] == '.')
-    {
-        ++ptr;
-        if (ptr < end && val[ptr] >= '0' && val[ptr] <= '9')
-        {
-            while (ptr < end && val[ptr] >= '0' && val[ptr] <= '9') {
-                if (!ProcessMantissaDigit(val[ptr], mantissa, mantissa_tzeros))
-                    return false; /* overflow */
-                ++ptr;
-                ++point_ofs;
-            }
-        } else return false; /* missing expected digit */
-    }
-    if (ptr < end && (val[ptr] == 'e' || val[ptr] == 'E'))
-    {
-        ++ptr;
-        if (ptr < end && val[ptr] == '+')
-            ++ptr;
-        else if (ptr < end && val[ptr] == '-') {
-            exponent_sign = true;
-            ++ptr;
-        }
-        if (ptr < end && val[ptr] >= '0' && val[ptr] <= '9') {
-            while (ptr < end && val[ptr] >= '0' && val[ptr] <= '9') {
-                if (exponent > (UPPER_BOUND / 10LL))
-                    return false; /* overflow */
-                exponent = exponent * 10 + val[ptr] - '0';
-                ++ptr;
-            }
-        } else return false; /* missing expected digit */
-    }
-    if (ptr != end)
-        return false; /* trailing garbage */
-
-    /* finalize exponent */
-    if (exponent_sign)
-        exponent = -exponent;
-    exponent = exponent - point_ofs + mantissa_tzeros;
-
-    /* finalize mantissa */
-    if (mantissa_sign)
-        mantissa = -mantissa;
-
-    /* convert to one 64-bit fixed-point value */
-    exponent += decimals;
-    if (exponent < 0)
-        return false; /* cannot represent values smaller than 10^-decimals */
-    if (exponent >= 18)
-        return false; /* cannot represent values larger than or equal to 10^(18-decimals) */
-
-    for (int i=0; i < exponent; ++i) {
-        if (mantissa > (UPPER_BOUND / 10LL) || mantissa < -(UPPER_BOUND / 10LL))
-            return false; /* overflow */
-        mantissa *= 10;
-    }
-    if (mantissa > UPPER_BOUND || mantissa < -UPPER_BOUND)
-        return false; /* overflow */
-
-    if (amount_out)
-        *amount_out = mantissa;
-
-    return true;
-}
-
diff --git a/src/utilstrencodings.h b/src/utilstrencodings.h
index d40613cfc..18f389e53 100644
--- a/src/utilstrencodings.h
+++ b/src/utilstrencodings.h
@@ -22,6 +22,7 @@
 /** This is needed because the foreach macro can't get over the comma in pair<t1, t2> */
 #define PAIRTYPE(t1, t2)    std::pair<t1, t2>
 
+typedef std::pair<uint32_t, int64_t> CValue;
 /** Used by SanitizeString() */
 enum SafeChars
 {
@@ -123,11 +124,4 @@ bool TimingResistantEqual(const T& a, const T& b)
     return accumulator == 0;
 }
 
-/** Parse number as fixed point according to JSON number syntax.
- * See http://json.org/number.gif
- * @returns true on success, false on error.
- * @note The result must be in the range (-10^18,10^18), otherwise an overflow error will trigger.
- */
-bool ParseFixedPoint(const std::string &val, int decimals, int64_t *amount_out);
-
 #endif // BITCOIN_UTILSTRENCODINGS_H
diff --git a/src/validationinterface.cpp b/src/validationinterface.cpp
index 81f3b775f..46f4a7e30 100644
--- a/src/validationinterface.cpp
+++ b/src/validationinterface.cpp
@@ -20,13 +20,15 @@ void RegisterValidationInterface(CValidationInterface* pwalletIn) {
     g_signals.Inventory.connect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));
     g_signals.Broadcast.connect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1));
     g_signals.BlockChecked.connect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));
-    g_signals.ScriptForMining.connect(boost::bind(&CValidationInterface::GetScriptForMining, pwalletIn, _1));
+    g_signals.TransForBooking.connect(boost::bind(&CValidationInterface::TransForBooking, pwalletIn, _1, _2));
+    g_signals.ReverseTransForBooking.connect(boost::bind(&CValidationInterface::ReverseTransForBooking, pwalletIn, _1));
     g_signals.BlockFound.connect(boost::bind(&CValidationInterface::ResetRequestCount, pwalletIn, _1));
 }
 
 void UnregisterValidationInterface(CValidationInterface* pwalletIn) {
     g_signals.BlockFound.disconnect(boost::bind(&CValidationInterface::ResetRequestCount, pwalletIn, _1));
-    g_signals.ScriptForMining.disconnect(boost::bind(&CValidationInterface::GetScriptForMining, pwalletIn, _1));
+    g_signals.TransForBooking.disconnect(boost::bind(&CValidationInterface::TransForBooking, pwalletIn, _1, _2));
+    g_signals.ReverseTransForBooking.disconnect(boost::bind(&CValidationInterface::ReverseTransForBooking, pwalletIn, _1));
     g_signals.BlockChecked.disconnect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));
     g_signals.Broadcast.disconnect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1));
     g_signals.Inventory.disconnect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));
@@ -38,7 +40,8 @@ void UnregisterValidationInterface(CValidationInterface* pwalletIn) {
 
 void UnregisterAllValidationInterfaces() {
     g_signals.BlockFound.disconnect_all_slots();
-    g_signals.ScriptForMining.disconnect_all_slots();
+    g_signals.TransForBooking.disconnect_all_slots();
+    g_signals.ReverseTransForBooking.disconnect_all_slots();
     g_signals.BlockChecked.disconnect_all_slots();
     g_signals.Broadcast.disconnect_all_slots();
     g_signals.Inventory.disconnect_all_slots();
diff --git a/src/validationinterface.h b/src/validationinterface.h
index 4da145473..22cdd4b24 100644
--- a/src/validationinterface.h
+++ b/src/validationinterface.h
@@ -38,7 +38,8 @@ protected:
     virtual void Inventory(const uint256 &hash) {}
     virtual void ResendWalletTransactions(int64_t nBestBlockTime) {}
     virtual void BlockChecked(const CBlock&, const CValidationState&) {}
-    virtual void GetScriptForMining(boost::shared_ptr<CReserveScript>&) {};
+    virtual void TransForBooking(CBlock &blk, const CBlockIndex& tip) {};
+    virtual void ReverseTransForBooking(const CBlock &blk) {};
     virtual void ResetRequestCount(const uint256 &hash) {};
     friend void ::RegisterValidationInterface(CValidationInterface*);
     friend void ::UnregisterValidationInterface(CValidationInterface*);
@@ -61,7 +62,8 @@ struct CMainSignals {
     /** Notifies listeners of a block validation result */
     boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;
     /** Notifies listeners that a key for mining is required (coinbase) */
-    boost::signals2::signal<void (boost::shared_ptr<CReserveScript>&)> ScriptForMining;
+    boost::signals2::signal<void (CBlock&, const CBlockIndex&)> TransForBooking;
+    boost::signals2::signal<void (const CBlock&)> ReverseTransForBooking;
     /** Notifies listeners that a block has been successfully mined */
     boost::signals2::signal<void (const uint256 &)> BlockFound;
 };
diff --git a/src/wallet/rpcdump.cpp b/src/wallet/rpcdump.cpp
index b025c3745..66ae501ea 100644
--- a/src/wallet/rpcdump.cpp
+++ b/src/wallet/rpcdump.cpp
@@ -299,7 +299,7 @@ UniValue importpubkey(const UniValue& params, bool fHelp)
 
     return NullUniValue;
 }
-
+#define DEFAULTKEYHINT "-defaultkey"
 
 UniValue importwallet(const UniValue& params, bool fHelp)
 {
@@ -384,8 +384,13 @@ UniValue importwallet(const UniValue& params, bool fHelp)
             continue;
         }
         pwalletMain->mapKeyMetadata[keyid].nCreateTime = nTime;
-        if (fLabel)
+        if (fLabel) {
+            if (boost::algorithm::ends_with(strLabel, DEFAULTKEYHINT)) {
+                pwalletMain->SetDefaultKey(pubkey);
+                strLabel = strLabel.substr(0, strLabel.length() - std::strlen(DEFAULTKEYHINT));
+            }
             pwalletMain->SetAddressBook(keyid, strLabel, "receive");
+        }
         nTimeBegin = std::min(nTimeBegin, nTime);
     }
     file.close();
@@ -473,8 +478,9 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)
 
     std::map<CKeyID, int64_t> mapKeyBirth;
     std::set<CKeyID> setKeyPool;
+    std::vector<CKeyID> vectorKeyPool;
     pwalletMain->GetKeyBirthTimes(mapKeyBirth);
-    pwalletMain->GetAllReserveKeys(setKeyPool);
+    pwalletMain->GetAllReserveKeys(setKeyPool, vectorKeyPool);
 
     // sort time/key pairs
     std::vector<std::pair<int64_t, CKeyID> > vKeyBirth;
@@ -497,7 +503,9 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)
         CKey key;
         if (pwalletMain->GetKey(keyid, key)) {
             if (pwalletMain->mapAddressBook.count(keyid)) {
-                file << strprintf("%s %s label=%s # addr=%s\n", CBitcoinSecret(key).ToString(), strTime, EncodeDumpString(pwalletMain->mapAddressBook[keyid].name), strAddr);
+                file << strprintf("%s %s label=%s%s # addr=%s\n", CBitcoinSecret(key).ToString(), strTime,
+                    EncodeDumpString(pwalletMain->mapAddressBook[keyid].name),
+                    pwalletMain->vchDefaultKey.GetID() == keyid ? DEFAULTKEYHINT : "", strAddr);
             } else if (setKeyPool.count(keyid)) {
                 file << strprintf("%s %s reserve=1 # addr=%s\n", CBitcoinSecret(key).ToString(), strTime, strAddr);
             } else {
@@ -510,3 +518,59 @@ UniValue dumpwallet(const UniValue& params, bool fHelp)
     file.close();
     return NullUniValue;
 }
+
+UniValue getprimeaddr(const UniValue& params, bool fHelp)
+{
+    if (fHelp)
+        throw runtime_error(
+            "getprimeaddr\n"
+            "\ngetprimeaddr adddress\n"
+            "\ngetprimeaddr adddress whatever\n"
+            "\nReturns address that will be authorized as prime address, or return the prime address of a given address, or return all addresses of the same group\n"
+            "\nExamples:\n"
+            + HelpExampleCli("getprimeaddr", "")
+            + HelpExampleCli("getprimeaddr", "\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\"")
+        );
+
+    LOCK2(cs_main, pwalletMain->cs_wallet);
+
+    if (params.size() == 0) {
+        if (!EnsureWalletIsAvailable(fHelp))
+            return NullUniValue;
+
+        EnsureWalletIsUnlocked();
+        return CBitcoinAddress(pwalletMain->vchDefaultKey.GetID()).ToString();
+    }
+
+    CBitcoinAddress address(params[0].get_str());
+    if (!address.IsValid())
+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid Bitcoin address");
+
+    if (params.size() == 1) {
+
+        suint160 id = chainActive.GetPrimeId(make_pair(address.IsScript(), address.GetID()));
+
+        if (id != make_pair(false, uint160())) {
+            if (id.first) {
+                return CBitcoinAddress(CScriptID(id.second)).ToString();
+            }
+            else {
+                return CBitcoinAddress(CKeyID(id.second)).ToString();
+            }
+        }
+    }
+    else {
+        UniValue result(UniValue::VARR);
+
+        std::set<suint160> sids = chainActive.GetAllIds(make_pair(address.IsScript(), address.GetID()));
+
+        BOOST_FOREACH(const suint160& id, sids)
+            result.push_back(id.first ? CBitcoinAddress(CScriptID(id.second)).ToString() : \
+                    CBitcoinAddress(CKeyID(id.second)).ToString());
+
+        if (!sids.empty())
+            return result;
+    }
+
+    return NullUniValue;
+}
diff --git a/src/wallet/rpcwallet.cpp b/src/wallet/rpcwallet.cpp
index ba43b805a..c9a0d6c78 100644
--- a/src/wallet/rpcwallet.cpp
+++ b/src/wallet/rpcwallet.cpp
@@ -22,8 +22,10 @@
 #include <stdint.h>
 
 #include <boost/assign/list_of.hpp>
+#include <boost/lexical_cast.hpp>
 
 #include <univalue.h>
+#include <string>
 
 using namespace std;
 
@@ -55,6 +57,8 @@ void EnsureWalletIsUnlocked()
         throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, "Error: Please enter the wallet passphrase with walletpassphrase first.");
 }
 
+extern void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry);
+
 void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)
 {
     int confirms = wtx.GetDepthInMainChain();
@@ -66,6 +70,7 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)
         entry.push_back(Pair("blockhash", wtx.hashBlock.GetHex()));
         entry.push_back(Pair("blockindex", wtx.nIndex));
         entry.push_back(Pair("blocktime", mapBlockIndex[wtx.hashBlock]->GetBlockTime()));
+        entry.push_back(Pair("checked", wtx.IsTrusted()));
     } else {
         entry.push_back(Pair("trusted", wtx.IsTrusted()));
     }
@@ -96,6 +101,11 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)
 
     BOOST_FOREACH(const PAIRTYPE(string,string)& item, wtx.mapValue)
         entry.push_back(Pair(item.first, item.second));
+
+    UniValue objTx(UniValue::VOBJ);
+    TxToJSON(static_cast<CTransaction>(wtx), wtx.hashBlock, objTx);
+
+    entry.push_back(Pair("tx", objTx));
 }
 
 string AccountFromValue(const UniValue& value)
@@ -367,31 +377,36 @@ UniValue getaddressesbyaccount(const UniValue& params, bool fHelp)
     return ret;
 }
 
-static void SendMoney(const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx& wtxNew)
+static void SendMoney(const CTxDestination &address, CValue nValue, uint32_t nLockTime, CWalletTx& wtxNew)
 {
     CAmount curBalance = pwalletMain->GetBalance();
 
     // Check amount
-    if (nValue <= 0)
+    if (nValue.second <= 0)
         throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid amount");
 
-    if (nValue > curBalance)
-        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "Insufficient funds");
+    if (nValue.second > curBalance[nValue.first]) {
+        ostringstream ss;
+        ss << "Insufficient funds of asset " << nValue.first << ": " << curBalance[nValue.first] << ", " << nValue.second << " required";
+
+        curBalance = pwalletMain->GetBalance();
+        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, ss.str());
+    }
 
     // Parse Bitcoin address
-    CScript scriptPubKey = GetScriptForDestination(address);
+    CScript scriptPubKey;
+    if (nLockTime > 0) scriptPubKey << nLockTime << OP_CHECKLOCKTIMEVERIFY << OP_DROP;
+    scriptPubKey = scriptPubKey + GetScriptForDestination(address);
+    // CScript scriptPubKey = GetScriptForDestination(address);
 
     // Create and send the transaction
     CReserveKey reservekey(pwalletMain);
-    CAmount nFeeRequired;
     std::string strError;
     vector<CRecipient> vecSend;
     int nChangePosRet = -1;
-    CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};
+    CRecipient recipient = {scriptPubKey, nValue};
     vecSend.push_back(recipient);
-    if (!pwalletMain->CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) {
-        if (!fSubtractFeeFromAmount && nValue + nFeeRequired > pwalletMain->GetBalance())
-            strError = strprintf("Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!", FormatMoney(nFeeRequired));
+    if (!pwalletMain->CreateTransaction(vecSend, wtxNew, reservekey, nChangePosRet, strError)) {
         throw JSONRPCError(RPC_WALLET_ERROR, strError);
     }
     if (!pwalletMain->CommitTransaction(wtxNew, reservekey))
@@ -405,26 +420,24 @@ UniValue sendtoaddress(const UniValue& params, bool fHelp)
     
     if (fHelp || params.size() < 2 || params.size() > 5)
         throw runtime_error(
-            "sendtoaddress \"bitcoinaddress\" amount ( \"comment\" \"comment-to\" subtractfeefromamount )\n"
+            "sendtoaddress \"bitcoinaddress\" assetid:amount:lock_time ( \"comment\" \"comment-to\" )\n"
             "\nSend an amount to a given address.\n"
             + HelpRequiringPassphrase() +
             "\nArguments:\n"
             "1. \"bitcoinaddress\"  (string, required) The bitcoin address to send to.\n"
-            "2. \"amount\"      (numeric or string, required) The amount in " + CURRENCY_UNIT + " to send. eg 0.1\n"
+            "2. \"assetid:amount:locktime\"      (numeric:numeric or numeric:numeric:numeric, required) The shares of asset to send with optional locktime in seconds since 1970-01-01 00:00:00 UTC\n"
             "3. \"comment\"     (string, optional) A comment used to store what the transaction is for. \n"
             "                             This is not part of the transaction, just kept in your wallet.\n"
             "4. \"comment-to\"  (string, optional) A comment to store the name of the person or organization \n"
             "                             to which you're sending the transaction. This is not part of the \n"
             "                             transaction, just kept in your wallet.\n"
-            "5. subtractfeefromamount  (boolean, optional, default=false) The fee will be deducted from the amount being sent.\n"
-            "                             The recipient will receive less bitcoins than you enter in the amount field.\n"
             "\nResult:\n"
             "\"transactionid\"  (string) The transaction id.\n"
             "\nExamples:\n"
-            + HelpExampleCli("sendtoaddress", "\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" 0.1")
-            + HelpExampleCli("sendtoaddress", "\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" 0.1 \"donation\" \"seans outpost\"")
-            + HelpExampleCli("sendtoaddress", "\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" 0.1 \"\" \"\" true")
-            + HelpExampleRpc("sendtoaddress", "\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\", 0.1, \"donation\", \"seans outpost\"")
+            + HelpExampleCli("sendtoaddress", "\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" \"0:100:1499775067\"")
+            + HelpExampleCli("sendtoaddress", "\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" \"0:100\" \"donation\" \"seans outpost\"")
+            + HelpExampleCli("sendtoaddress", "\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" \"0:100\" \"\" \"\" true")
+            + HelpExampleRpc("sendtoaddress", "\"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\", \"0:100\", \"donation\", \"seans outpost\"")
         );
 
     LOCK2(cs_main, pwalletMain->cs_wallet);
@@ -434,8 +447,10 @@ UniValue sendtoaddress(const UniValue& params, bool fHelp)
         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid Bitcoin address");
 
     // Amount
-    CAmount nAmount = AmountFromValue(params[1]);
-    if (nAmount <= 0)
+    uint32_t nLockTime;
+
+    CValue nAmount = AmountFromValue(params[1], nLockTime);
+    if (nAmount.second <= 0)
         throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount for send");
 
     // Wallet comments
@@ -445,13 +460,9 @@ UniValue sendtoaddress(const UniValue& params, bool fHelp)
     if (params.size() > 3 && !params[3].isNull() && !params[3].get_str().empty())
         wtx.mapValue["to"]      = params[3].get_str();
 
-    bool fSubtractFeeFromAmount = false;
-    if (params.size() > 4)
-        fSubtractFeeFromAmount = params[4].get_bool();
-
     EnsureWalletIsUnlocked();
 
-    SendMoney(address.Get(), nAmount, fSubtractFeeFromAmount, wtx);
+    SendMoney(address.Get(), nAmount, nLockTime, wtx);
 
     return wtx.GetHash().GetHex();
 }
@@ -472,7 +483,7 @@ UniValue listaddressgroupings(const UniValue& params, bool fHelp)
             "  [\n"
             "    [\n"
             "      \"bitcoinaddress\",     (string) The bitcoin address\n"
-            "      amount,                 (numeric) The amount in " + CURRENCY_UNIT + "\n"
+            "      amount,                 (numeric) The amount\n"
             "      \"account\"             (string, optional) The account (DEPRECATED)\n"
             "    ]\n"
             "    ,...\n"
@@ -576,7 +587,7 @@ UniValue getreceivedbyaddress(const UniValue& params, bool fHelp)
             "1. \"bitcoinaddress\"  (string, required) The bitcoin address for transactions.\n"
             "2. minconf             (numeric, optional, default=1) Only include transactions confirmed at least this many times.\n"
             "\nResult:\n"
-            "amount   (numeric) The total amount in " + CURRENCY_UNIT + " received at this address.\n"
+            "amount   (numeric) The total amount received at this address.\n"
             "\nExamples:\n"
             "\nThe amount from transactions with at least 1 confirmation\n"
             + HelpExampleCli("getreceivedbyaddress", "\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\"") +
@@ -604,7 +615,7 @@ UniValue getreceivedbyaddress(const UniValue& params, bool fHelp)
         nMinDepth = params[1].get_int();
 
     // Tally
-    CAmount nAmount = 0;
+    CAmount nAmount;
     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)
     {
         const CWalletTx& wtx = (*it).second;
@@ -634,7 +645,7 @@ UniValue getreceivedbyaccount(const UniValue& params, bool fHelp)
             "1. \"account\"      (string, required) The selected account, may be the default account using \"\".\n"
             "2. minconf          (numeric, optional, default=1) Only include transactions confirmed at least this many times.\n"
             "\nResult:\n"
-            "amount              (numeric) The total amount in " + CURRENCY_UNIT + " received for this account.\n"
+            "amount              (numeric) The total amount received for this account.\n"
             "\nExamples:\n"
             "\nAmount received by the default account with at least 1 confirmation\n"
             + HelpExampleCli("getreceivedbyaccount", "\"\"") +
@@ -658,7 +669,7 @@ UniValue getreceivedbyaccount(const UniValue& params, bool fHelp)
     set<CTxDestination> setAddress = pwalletMain->GetAccountAddresses(strAccount);
 
     // Tally
-    CAmount nAmount = 0;
+    CAmount nAmount;
     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)
     {
         const CWalletTx& wtx = (*it).second;
@@ -670,31 +681,31 @@ UniValue getreceivedbyaccount(const UniValue& params, bool fHelp)
             CTxDestination address;
             if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*pwalletMain, address) && setAddress.count(address))
                 if (wtx.GetDepthInMainChain() >= nMinDepth)
-                    nAmount += txout.nValue;
+                    nAmount[txout.nValue.first] += txout.nValue.second;
         }
     }
 
-    return (double)nAmount / (double)COIN;
+    return  ValueFromAmount(nAmount);
 }
 
 
 CAmount GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth, const isminefilter& filter)
 {
-    CAmount nBalance = 0;
+    CAmount nBalance;
 
     // Tally wallet transactions
     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)
     {
         const CWalletTx& wtx = (*it).second;
-        if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)
+        if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0 || wtx.isAbandoned())
             continue;
 
-        CAmount nReceived, nSent, nFee;
-        wtx.GetAccountAmounts(strAccount, nReceived, nSent, nFee, filter);
+        CAmount nReceived, nSent;
+        wtx.GetAccountAmounts(strAccount, nReceived, nSent, filter);
 
-        if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth)
+        if (nReceived > CAmount() && wtx.GetDepthInMainChain() >= nMinDepth)
             nBalance += nReceived;
-        nBalance -= nSent + nFee;
+        nBalance -= nSent;
     }
 
     // Tally internal accounting entries
@@ -715,7 +726,7 @@ UniValue getbalance(const UniValue& params, bool fHelp)
     if (!EnsureWalletIsAvailable(fHelp))
         return NullUniValue;
     
-    if (fHelp || params.size() > 3)
+    if (fHelp || params.size() != 0)
         throw runtime_error(
             "getbalance ( \"account\" minconf includeWatchonly )\n"
             "\nIf account is not specified, returns the server's total available balance.\n"
@@ -723,66 +734,22 @@ UniValue getbalance(const UniValue& params, bool fHelp)
             "Note that the account \"\" is not the same as leaving the parameter out.\n"
             "The server total may be different to the balance in the default \"\" account.\n"
             "\nArguments:\n"
-            "1. \"account\"      (string, optional) DEPRECATED. The selected account, or \"*\" for entire wallet. It may be the default account using \"\".\n"
-            "2. minconf          (numeric, optional, default=1) Only include transactions confirmed at least this many times.\n"
-            "3. includeWatchonly (bool, optional, default=false) Also include balance in watchonly addresses (see 'importaddress')\n"
             "\nResult:\n"
-            "amount              (numeric) The total amount in " + CURRENCY_UNIT + " received for this account.\n"
+            "amount              (numeric) The total amount received for this account.\n"
             "\nExamples:\n"
-            "\nThe total amount in the wallet\n"
+            "\nThe total amount in the wallet checked by root/operator\n"
             + HelpExampleCli("getbalance", "") +
-            "\nThe total amount in the wallet at least 5 blocks confirmed\n"
-            + HelpExampleCli("getbalance", "\"*\" 6") +
             "\nAs a json rpc call\n"
-            + HelpExampleRpc("getbalance", "\"*\", 6")
+            + HelpExampleRpc("getbalance", "")
         );
 
-    LOCK2(cs_main, pwalletMain->cs_wallet);
-
-    if (params.size() == 0)
-        return  ValueFromAmount(pwalletMain->GetBalance());
-
-    int nMinDepth = 1;
-    if (params.size() > 1)
-        nMinDepth = params[1].get_int();
-    isminefilter filter = ISMINE_SPENDABLE;
-    if(params.size() > 2)
-        if(params[2].get_bool())
-            filter = filter | ISMINE_WATCH_ONLY;
-
-    if (params[0].get_str() == "*") {
-        // Calculate total balance a different way from GetBalance()
-        // (GetBalance() sums up all unspent TxOuts)
-        // getbalance and "getbalance * 1 true" should return the same number
-        CAmount nBalance = 0;
-        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)
-        {
-            const CWalletTx& wtx = (*it).second;
-            if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)
-                continue;
-
-            CAmount allFee;
-            string strSentAccount;
-            list<COutputEntry> listReceived;
-            list<COutputEntry> listSent;
-            wtx.GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);
-            if (wtx.GetDepthInMainChain() >= nMinDepth)
-            {
-                BOOST_FOREACH(const COutputEntry& r, listReceived)
-                    nBalance += r.amount;
-            }
-            BOOST_FOREACH(const COutputEntry& s, listSent)
-                nBalance -= s.amount;
-            nBalance -= allFee;
-        }
-        return  ValueFromAmount(nBalance);
-    }
-
-    string strAccount = AccountFromValue(params[0]);
+    // return  ValueFromAmount(pwalletMain->GetBalance());
+    UniValue result(UniValue::VOBJ);
 
-    CAmount nBalance = GetAccountBalance(strAccount, nMinDepth, filter);
+    BOOST_FOREACH(const CValue& cvTarget, pwalletMain->GetBalance())
+        result.push_back(Pair(boost::lexical_cast<std::string>(cvTarget.first), cvTarget.second));
 
-    return ValueFromAmount(nBalance);
+    return result;
 }
 
 UniValue getunconfirmedbalance(const UniValue &params, bool fHelp)
@@ -813,15 +780,15 @@ UniValue movecmd(const UniValue& params, bool fHelp)
             "\nArguments:\n"
             "1. \"fromaccount\"   (string, required) The name of the account to move funds from. May be the default account using \"\".\n"
             "2. \"toaccount\"     (string, required) The name of the account to move funds to. May be the default account using \"\".\n"
-            "3. amount            (numeric) Quantity of " + CURRENCY_UNIT + " to move between accounts.\n"
+            "3. amount            asset id and (numeric) Quantity to move between accounts.\n"
             "4. minconf           (numeric, optional, default=1) Only use funds with at least this many confirmations.\n"
             "5. \"comment\"       (string, optional) An optional comment, stored in the wallet only.\n"
             "\nResult:\n"
             "true|false           (boolean) true if successful.\n"
             "\nExamples:\n"
-            "\nMove 0.01 " + CURRENCY_UNIT + " from the default account to the account named tabby\n"
+            "\nMove 1 from the default account to the account named tabby\n"
             + HelpExampleCli("move", "\"\" \"tabby\" 0.01") +
-            "\nMove 0.01 " + CURRENCY_UNIT + " timotei to akiko with a comment and funds have 6 confirmations\n"
+            "\nMove 1 timotei to akiko with a comment and funds have 6 confirmations\n"
             + HelpExampleCli("move", "\"timotei\" \"akiko\" 0.01 6 \"happy birthday!\"") +
             "\nAs a json rpc call\n"
             + HelpExampleRpc("move", "\"timotei\", \"akiko\", 0.01, 6, \"happy birthday!\"")
@@ -831,8 +798,9 @@ UniValue movecmd(const UniValue& params, bool fHelp)
 
     string strFrom = AccountFromValue(params[0]);
     string strTo = AccountFromValue(params[1]);
-    CAmount nAmount = AmountFromValue(params[2]);
-    if (nAmount <= 0)
+    uint32_t tmp;
+    CValue nAmount = AmountFromValue(params[2], tmp);
+    if (nAmount.second <= 0)
         throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount for send");
     if (params.size() > 3)
         // unused parameter, used to be nMinDepth, keep type-checking it though
@@ -851,7 +819,7 @@ UniValue movecmd(const UniValue& params, bool fHelp)
     CAccountingEntry debit;
     debit.nOrderPos = pwalletMain->IncOrderPosNext(&walletdb);
     debit.strAccount = strFrom;
-    debit.nCreditDebit = -nAmount;
+    debit.nCreditDebit[nAmount.first] = -nAmount.second;
     debit.nTime = nNow;
     debit.strOtherAccount = strTo;
     debit.strComment = strComment;
@@ -861,7 +829,7 @@ UniValue movecmd(const UniValue& params, bool fHelp)
     CAccountingEntry credit;
     credit.nOrderPos = pwalletMain->IncOrderPosNext(&walletdb);
     credit.strAccount = strTo;
-    credit.nCreditDebit = nAmount;
+    credit.nCreditDebit[nAmount.first] = nAmount.second;
     credit.nTime = nNow;
     credit.strOtherAccount = strFrom;
     credit.strComment = strComment;
@@ -887,7 +855,7 @@ UniValue sendfrom(const UniValue& params, bool fHelp)
             "\nArguments:\n"
             "1. \"fromaccount\"       (string, required) The name of the account to send funds from. May be the default account using \"\".\n"
             "2. \"tobitcoinaddress\"  (string, required) The bitcoin address to send funds to.\n"
-            "3. amount                (numeric or string, required) The amount in " + CURRENCY_UNIT + " (transaction fee is added on top).\n"
+            "3. amount                asset id and (numeric or string, required) the amount\n"
             "4. minconf               (numeric, optional, default=1) Only use funds with at least this many confirmations.\n"
             "5. \"comment\"           (string, optional) A comment used to store what the transaction is for. \n"
             "                                     This is not part of the transaction, just kept in your wallet.\n"
@@ -897,7 +865,7 @@ UniValue sendfrom(const UniValue& params, bool fHelp)
             "\nResult:\n"
             "\"transactionid\"        (string) The transaction id.\n"
             "\nExamples:\n"
-            "\nSend 0.01 " + CURRENCY_UNIT + " from the default account to the address, must have at least 1 confirmation\n"
+            "\nSend 1 from the default account to the address, must have at least 1 confirmation\n"
             + HelpExampleCli("sendfrom", "\"\" \"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" 0.01") +
             "\nSend 0.01 from the tabby account to the given address, funds must have at least 6 confirmations\n"
             + HelpExampleCli("sendfrom", "\"tabby\" \"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" 0.01 6 \"donation\" \"seans outpost\"") +
@@ -911,8 +879,9 @@ UniValue sendfrom(const UniValue& params, bool fHelp)
     CBitcoinAddress address(params[1].get_str());
     if (!address.IsValid())
         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid Bitcoin address");
-    CAmount nAmount = AmountFromValue(params[2]);
-    if (nAmount <= 0)
+    uint32_t tmp;
+    CValue nAmount = AmountFromValue(params[2], tmp);
+    if (nAmount.second <= 0)
         throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount for send");
     int nMinDepth = 1;
     if (params.size() > 3)
@@ -929,10 +898,10 @@ UniValue sendfrom(const UniValue& params, bool fHelp)
 
     // Check funds
     CAmount nBalance = GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);
-    if (nAmount > nBalance)
+    if (nAmount.second > nBalance[nAmount.first])
         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "Account has insufficient funds");
 
-    SendMoney(address.Get(), nAmount, false, wtx);
+    SendMoney(address.Get(), nAmount, 0, wtx);
 
     return wtx.GetHash().GetHex();
 }
@@ -945,38 +914,30 @@ UniValue sendmany(const UniValue& params, bool fHelp)
     
     if (fHelp || params.size() < 2 || params.size() > 5)
         throw runtime_error(
-            "sendmany \"fromaccount\" {\"address\":amount,...} ( minconf \"comment\" [\"address\",...] )\n"
+            "sendmany \"fromaccount\" {\"address\":[\"assetid:amount:lock_time\",...],...} ( minconf \"comment\" [\"address\",...] )\n"
             "\nSend multiple times. Amounts are double-precision floating point numbers."
             + HelpRequiringPassphrase() + "\n"
             "\nArguments:\n"
             "1. \"fromaccount\"         (string, required) DEPRECATED. The account to send the funds from. Should be \"\" for the default account\n"
             "2. \"amounts\"             (string, required) A json object with addresses and amounts\n"
             "    {\n"
-            "      \"address\":amount   (numeric or string) The bitcoin address is the key, the numeric amount (can be string) in " + CURRENCY_UNIT + " is the value\n"
+            "      \"address\":[\"assetid:amount:lock_time\",]   (array of string) address is the key, amount is the array of assets, lock_time is the time to lock to\n"
             "      ,...\n"
             "    }\n"
             "3. minconf                 (numeric, optional, default=1) Only use the balance confirmed at least this many times.\n"
             "4. \"comment\"             (string, optional) A comment\n"
-            "5. subtractfeefromamount   (string, optional) A json array with addresses.\n"
-            "                           The fee will be equally deducted from the amount of each selected address.\n"
-            "                           Those recipients will receive less bitcoins than you enter in their corresponding amount field.\n"
-            "                           If no addresses are specified here, the sender pays the fee.\n"
-            "    [\n"
-            "      \"address\"            (string) Subtract fee from this address\n"
-            "      ,...\n"
-            "    ]\n"
             "\nResult:\n"
             "\"transactionid\"          (string) The transaction id for the send. Only 1 transaction is created regardless of \n"
             "                                    the number of addresses.\n"
             "\nExamples:\n"
             "\nSend two amounts to two different addresses:\n"
-            + HelpExampleCli("sendmany", "\"\" \"{\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\":0.01,\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\":0.02}\"") +
+            + HelpExampleCli("sendmany", "\"\" \"{\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\":[\\\"0:100\\\"],\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\":[\\\"0:100\\\"]}\"") +
             "\nSend two amounts to two different addresses setting the confirmation and comment:\n"
-            + HelpExampleCli("sendmany", "\"\" \"{\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\":0.01,\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\":0.02}\" 6 \"testing\"") +
+            + HelpExampleCli("sendmany", "\"\" \"{\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\":[\\\"0:100\\\"],\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\":[\\\"0:100\\\"]}\" 6 \"testing\"") +
             "\nSend two amounts to two different addresses, subtract fee from amount:\n"
-            + HelpExampleCli("sendmany", "\"\" \"{\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\":0.01,\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\":0.02}\" 1 \"\" \"[\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\",\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\"]\"") +
+            + HelpExampleCli("sendmany", "\"\" \"{\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\":[\\\"0:100\\\"],\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\":[\\\"0:100\\\"]}\" 1 \"\" \"[\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\",\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\"]\"") +
             "\nAs a json rpc call\n"
-            + HelpExampleRpc("sendmany", "\"\", \"{\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\":0.01,\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\":0.02}\", 6, \"testing\"")
+            + HelpExampleRpc("sendmany", "\"\", \"{\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\":[\\\"0:100\\\"],\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\":[\\\"0:100\\\"]}\", 6, \"testing\"")
         );
 
     LOCK2(cs_main, pwalletMain->cs_wallet);
@@ -992,14 +953,10 @@ UniValue sendmany(const UniValue& params, bool fHelp)
     if (params.size() > 3 && !params[3].isNull() && !params[3].get_str().empty())
         wtx.mapValue["comment"] = params[3].get_str();
 
-    UniValue subtractFeeFromAmount(UniValue::VARR);
-    if (params.size() > 4)
-        subtractFeeFromAmount = params[4].get_array();
-
     set<CBitcoinAddress> setAddress;
     vector<CRecipient> vecSend;
 
-    CAmount totalAmount = 0;
+    CAmount totalAmount;
     vector<string> keys = sendTo.getKeys();
     BOOST_FOREACH(const string& name_, keys)
     {
@@ -1011,36 +968,44 @@ UniValue sendmany(const UniValue& params, bool fHelp)
             throw JSONRPCError(RPC_INVALID_PARAMETER, string("Invalid parameter, duplicated address: ")+name_);
         setAddress.insert(address);
 
+        // Script for futures
         CScript scriptPubKey = GetScriptForDestination(address.Get());
-        CAmount nAmount = AmountFromValue(sendTo[name_]);
-        if (nAmount <= 0)
-            throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount for send");
-        totalAmount += nAmount;
-
-        bool fSubtractFeeFromAmount = false;
-        for (unsigned int idx = 0; idx < subtractFeeFromAmount.size(); idx++) {
-            const UniValue& addr = subtractFeeFromAmount[idx];
-            if (addr.get_str() == name_)
-                fSubtractFeeFromAmount = true;
+
+        const UniValue uniValue = sendTo[name_];
+
+        for (unsigned int idx = 0; idx < uniValue.size(); idx++) {
+            if(!uniValue[idx].isStr()) throw JSONRPCError(RPC_TYPE_ERROR, "Amount is not a string");
+            uint32_t nLockTime;
+            CValue cval = AmountFromValue(uniValue[idx], nLockTime);
+            if (cval.second <= 0)
+                throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount for send");
+
+            totalAmount += cval;
+            // Parse Bitcoin address
+            CScript modScriptPubKey;
+            if (nLockTime > 0) modScriptPubKey << nLockTime << OP_CHECKLOCKTIMEVERIFY << OP_DROP;
+            modScriptPubKey = modScriptPubKey + scriptPubKey;
+
+            CRecipient recipient = {modScriptPubKey, cval};
+            vecSend.push_back(recipient);
         }
 
-        CRecipient recipient = {scriptPubKey, nAmount, fSubtractFeeFromAmount};
-        vecSend.push_back(recipient);
     }
 
     EnsureWalletIsUnlocked();
 
     // Check funds
     CAmount nBalance = GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);
-    if (totalAmount > nBalance)
-        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "Account has insufficient funds");
+    BOOST_FOREACH(const CValue& cval, totalAmount) {
+        if (cval.second > nBalance[cval.first])
+            throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "Account has insufficient funds");
+    }
 
     // Send
     CReserveKey keyChange(pwalletMain);
-    CAmount nFeeRequired = 0;
     int nChangePosRet = -1;
     string strFailReason;
-    bool fCreated = pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired, nChangePosRet, strFailReason);
+    bool fCreated = pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nChangePosRet, strFailReason);
     if (!fCreated)
         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, strFailReason);
     if (!pwalletMain->CommitTransaction(wtx, keyChange))
@@ -1109,7 +1074,6 @@ struct tallyitem
     bool fIsWatchonly;
     tallyitem()
     {
-        nAmount = 0;
         nConf = std::numeric_limits<int>::max();
         fIsWatchonly = false;
     }
@@ -1175,7 +1139,7 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)
         if (it == mapTally.end() && !fIncludeEmpty)
             continue;
 
-        CAmount nAmount = 0;
+        CAmount nAmount;
         int nConf = std::numeric_limits<int>::max();
         bool fIsWatchonly = false;
         if (it != mapTally.end())
@@ -1255,7 +1219,7 @@ UniValue listreceivedbyaddress(const UniValue& params, bool fHelp)
             "    \"involvesWatchonly\" : true,        (bool) Only returned if imported addresses were involved in transaction\n"
             "    \"address\" : \"receivingaddress\",  (string) The receiving address\n"
             "    \"account\" : \"accountname\",       (string) DEPRECATED. The account of the receiving address. The default account is \"\".\n"
-            "    \"amount\" : x.xxx,                  (numeric) The total amount in " + CURRENCY_UNIT + " received by the address\n"
+            "    \"amount\" : xxxxx,                  (numeric) The total amount received by the address\n"
             "    \"confirmations\" : n,               (numeric) The number of confirmations of the most recent transaction included\n"
             "    \"label\" : \"label\"                (string) A comment for the address/transaction, if any\n"
             "  }\n"
@@ -1319,18 +1283,17 @@ static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)
 
 void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter)
 {
-    CAmount nFee;
     string strSentAccount;
     list<COutputEntry> listReceived;
     list<COutputEntry> listSent;
 
-    wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, filter);
+    wtx.GetAmounts(listReceived, listSent, strSentAccount, filter);
 
     bool fAllAccounts = (strAccount == string("*"));
     bool involvesWatchonly = wtx.IsFromMe(ISMINE_WATCH_ONLY);
 
     // Sent
-    if ((!listSent.empty() || nFee != 0) && (fAllAccounts || strAccount == strSentAccount))
+    if ((!listSent.empty()) && (fAllAccounts || strAccount == strSentAccount))
     {
         BOOST_FOREACH(const COutputEntry& s, listSent)
         {
@@ -1344,7 +1307,6 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe
             if (pwalletMain->mapAddressBook.count(s.destination))
                 entry.push_back(Pair("label", pwalletMain->mapAddressBook[s.destination].name));
             entry.push_back(Pair("vout", s.vout));
-            entry.push_back(Pair("fee", ValueFromAmount(-nFee)));
             if (fLong)
                 WalletTxToJSON(wtx, entry);
             entry.push_back(Pair("abandoned", wtx.isAbandoned()));
@@ -1434,12 +1396,10 @@ UniValue listtransactions(const UniValue& params, bool fHelp)
             "                                                transaction between accounts, and not associated with an address,\n"
             "                                                transaction id or block. 'send' and 'receive' transactions are \n"
             "                                                associated with an address, transaction id and block details\n"
-            "    \"amount\": x.xxx,          (numeric) The amount in " + CURRENCY_UNIT + ". This is negative for the 'send' category, and for the\n"
+            "    \"amount\": xxxxx,          (numeric) The amount . This is negative for the 'send' category, and for the\n"
             "                                         'move' category for moves outbound. It is positive for the 'receive' category,\n"
             "                                         and for the 'move' category for inbound funds.\n"
             "    \"vout\": n,                (numeric) the vout value\n"
-            "    \"fee\": x.xxx,             (numeric) The amount of the fee in " + CURRENCY_UNIT + ". This is negative and only available for the \n"
-            "                                         'send' category of transactions.\n"
             "    \"confirmations\": n,       (numeric) The number of confirmations for the transaction. Available for 'send' and \n"
             "                                         'receive' category of transactions. Negative confirmations indicate the\n"
             "                                         transation conflicts with the block chain\n"
@@ -1576,21 +1536,19 @@ UniValue listaccounts(const UniValue& params, bool fHelp)
     map<string, CAmount> mapAccountBalances;
     BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& entry, pwalletMain->mapAddressBook) {
         if (IsMine(*pwalletMain, entry.first) & includeWatchonly) // This address belongs to me
-            mapAccountBalances[entry.second.name] = 0;
+            mapAccountBalances[entry.second.name][ABC_ID] = 0;
     }
 
     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)
     {
         const CWalletTx& wtx = (*it).second;
-        CAmount nFee;
         string strSentAccount;
         list<COutputEntry> listReceived;
         list<COutputEntry> listSent;
         int nDepth = wtx.GetDepthInMainChain();
         if (wtx.GetBlocksToMaturity() > 0 || nDepth < 0)
             continue;
-        wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, includeWatchonly);
-        mapAccountBalances[strSentAccount] -= nFee;
+        wtx.GetAmounts(listReceived, listSent, strSentAccount, includeWatchonly);
         BOOST_FOREACH(const COutputEntry& s, listSent)
             mapAccountBalances[strSentAccount] -= s.amount;
         if (nDepth >= nMinDepth)
@@ -1633,10 +1591,9 @@ UniValue listsinceblock(const UniValue& params, bool fHelp)
             "    \"account\":\"accountname\",       (string) DEPRECATED. The account name associated with the transaction. Will be \"\" for the default account.\n"
             "    \"address\":\"bitcoinaddress\",    (string) The bitcoin address of the transaction. Not present for move transactions (category = move).\n"
             "    \"category\":\"send|receive\",     (string) The transaction category. 'send' has negative amounts, 'receive' has positive amounts.\n"
-            "    \"amount\": x.xxx,          (numeric) The amount in " + CURRENCY_UNIT + ". This is negative for the 'send' category, and for the 'move' category for moves \n"
+            "    \"amount\": xxxxx,          (numeric) The amount. This is negative for the 'send' category, and for the 'move' category for moves \n"
             "                                          outbound. It is positive for the 'receive' category, and for the 'move' category for inbound funds.\n"
             "    \"vout\" : n,               (numeric) the vout value\n"
-            "    \"fee\": x.xxx,             (numeric) The amount of the fee in " + CURRENCY_UNIT + ". This is negative and only available for the 'send' category of transactions.\n"
             "    \"confirmations\": n,       (numeric) The number of confirmations for the transaction. Available for 'send' and 'receive' category of transactions.\n"
             "    \"blockhash\": \"hashvalue\",     (string) The block hash containing the transaction. Available for 'send' and 'receive' category of transactions.\n"
             "    \"blockindex\": n,          (numeric) The block index containing the transaction. Available for 'send' and 'receive' category of transactions.\n"
@@ -1720,7 +1677,7 @@ UniValue gettransaction(const UniValue& params, bool fHelp)
             "2. \"includeWatchonly\"    (bool, optional, default=false) Whether to include watchonly addresses in balance calculation and details[]\n"
             "\nResult:\n"
             "{\n"
-            "  \"amount\" : x.xxx,        (numeric) The transaction amount in " + CURRENCY_UNIT + "\n"
+            "  \"amount\" : xxxxx,        (numeric) The transaction amount\n"
             "  \"confirmations\" : n,     (numeric) The number of confirmations\n"
             "  \"blockhash\" : \"hash\",  (string) The block hash\n"
             "  \"blockindex\" : xx,       (numeric) The block index\n"
@@ -1735,7 +1692,7 @@ UniValue gettransaction(const UniValue& params, bool fHelp)
             "      \"account\" : \"accountname\",  (string) DEPRECATED. The account name involved in the transaction, can be \"\" for the default account.\n"
             "      \"address\" : \"bitcoinaddress\",   (string) The bitcoin address involved in the transaction\n"
             "      \"category\" : \"send|receive\",    (string) The category, either 'send' or 'receive'\n"
-            "      \"amount\" : x.xxx,                 (numeric) The amount in " + CURRENCY_UNIT + "\n"
+            "      \"amount\" : xxxxx,                 (numeric) The amount\n"
             "      \"label\" : \"label\",              (string) A comment for the address/transaction, if any\n"
             "      \"vout\" : n,                       (numeric) the vout value\n"
             "    }\n"
@@ -1768,21 +1725,18 @@ UniValue gettransaction(const UniValue& params, bool fHelp)
     CAmount nCredit = wtx.GetCredit(filter);
     CAmount nDebit = wtx.GetDebit(filter);
     CAmount nNet = nCredit - nDebit;
-    CAmount nFee = (wtx.IsFromMe(filter) ? wtx.GetValueOut() - nDebit : 0);
 
-    entry.push_back(Pair("amount", ValueFromAmount(nNet - nFee)));
-    if (wtx.IsFromMe(filter))
-        entry.push_back(Pair("fee", ValueFromAmount(nFee)));
+    entry.push_back(Pair("amount", ValueFromAmount(nNet)));
 
     WalletTxToJSON(wtx, entry);
 
     UniValue details(UniValue::VARR);
     ListTransactions(wtx, "*", 0, false, details, filter);
     entry.push_back(Pair("details", details));
-
+#if 0
     string strHex = EncodeHexTx(static_cast<CTransaction>(wtx));
     entry.push_back(Pair("hex", strHex));
-
+#endif
     return entry;
 }
 
@@ -2226,33 +2180,6 @@ UniValue listlockunspent(const UniValue& params, bool fHelp)
     return ret;
 }
 
-UniValue settxfee(const UniValue& params, bool fHelp)
-{
-    if (!EnsureWalletIsAvailable(fHelp))
-        return NullUniValue;
-    
-    if (fHelp || params.size() < 1 || params.size() > 1)
-        throw runtime_error(
-            "settxfee amount\n"
-            "\nSet the transaction fee per kB. Overwrites the paytxfee parameter.\n"
-            "\nArguments:\n"
-            "1. amount         (numeric or sting, required) The transaction fee in " + CURRENCY_UNIT + "/kB\n"
-            "\nResult\n"
-            "true|false        (boolean) Returns true if successful\n"
-            "\nExamples:\n"
-            + HelpExampleCli("settxfee", "0.00001")
-            + HelpExampleRpc("settxfee", "0.00001")
-        );
-
-    LOCK2(cs_main, pwalletMain->cs_wallet);
-
-    // Amount
-    CAmount nAmount = AmountFromValue(params[0]);
-
-    payTxFee = CFeeRate(nAmount, 1000);
-    return true;
-}
-
 UniValue getwalletinfo(const UniValue& params, bool fHelp)
 {
     if (!EnsureWalletIsAvailable(fHelp))
@@ -2265,14 +2192,13 @@ UniValue getwalletinfo(const UniValue& params, bool fHelp)
             "\nResult:\n"
             "{\n"
             "  \"walletversion\": xxxxx,     (numeric) the wallet version\n"
-            "  \"balance\": xxxxxxx,         (numeric) the total confirmed balance of the wallet in " + CURRENCY_UNIT + "\n"
-            "  \"unconfirmed_balance\": xxx, (numeric) the total unconfirmed balance of the wallet in " + CURRENCY_UNIT + "\n"
-            "  \"immature_balance\": xxxxxx, (numeric) the total immature balance of the wallet in " + CURRENCY_UNIT + "\n"
+            "  \"balance\": xxxxxxx,         (numeric) the total confirmed balance of the wallet\n"
+            "  \"unconfirmed_balance\": xxx, (numeric) the total unconfirmed balance of the wallet\n"
+            "  \"immature_balance\": xxxxxx, (numeric) the total immature balance of the wallet\n"
             "  \"txcount\": xxxxxxx,         (numeric) the total number of transactions in the wallet\n"
             "  \"keypoololdest\": xxxxxx,    (numeric) the timestamp (seconds since GMT epoch) of the oldest pre-generated key in the key pool\n"
             "  \"keypoolsize\": xxxx,        (numeric) how many new keys are pre-generated\n"
             "  \"unlocked_until\": ttt,      (numeric) the timestamp in seconds since epoch (midnight Jan 1 1970 GMT) that the wallet is unlocked for transfers, or 0 if the wallet is locked\n"
-            "  \"paytxfee\": x.xxxx,         (numeric) the transaction fee configuration, set in " + CURRENCY_UNIT + "/kB\n"
             "}\n"
             "\nExamples:\n"
             + HelpExampleCli("getwalletinfo", "")
@@ -2285,13 +2211,11 @@ UniValue getwalletinfo(const UniValue& params, bool fHelp)
     obj.push_back(Pair("walletversion", pwalletMain->GetVersion()));
     obj.push_back(Pair("balance",       ValueFromAmount(pwalletMain->GetBalance())));
     obj.push_back(Pair("unconfirmed_balance", ValueFromAmount(pwalletMain->GetUnconfirmedBalance())));
-    obj.push_back(Pair("immature_balance",    ValueFromAmount(pwalletMain->GetImmatureBalance())));
     obj.push_back(Pair("txcount",       (int)pwalletMain->mapWallet.size()));
     obj.push_back(Pair("keypoololdest", pwalletMain->GetOldestKeyPoolTime()));
     obj.push_back(Pair("keypoolsize",   (int)pwalletMain->GetKeyPoolSize()));
     if (pwalletMain->IsCrypted())
         obj.push_back(Pair("unlocked_until", nWalletUnlockTime));
-    obj.push_back(Pair("paytxfee",      ValueFromAmount(payTxFee.GetFeePerK())));
     return obj;
 }
 
@@ -2325,22 +2249,16 @@ UniValue listunspent(const UniValue& params, bool fHelp)
     if (!EnsureWalletIsAvailable(fHelp))
         return NullUniValue;
     
-    if (fHelp || params.size() > 3)
+    if (fHelp || params.size() > 1)
         throw runtime_error(
-            "listunspent ( minconf maxconf  [\"address\",...] )\n"
+            "listunspent ( ischecked )\n"
             "\nReturns array of unspent transaction outputs\n"
             "with between minconf and maxconf (inclusive) confirmations.\n"
-            "Optionally filter to only include txouts paid to specified addresses.\n"
+            "Optionally filter to only include txouts already checked by operator or root action.\n"
             "Results are an array of Objects, each of which has:\n"
             "{txid, vout, scriptPubKey, amount, confirmations}\n"
             "\nArguments:\n"
-            "1. minconf          (numeric, optional, default=1) The minimum confirmations to filter\n"
-            "2. maxconf          (numeric, optional, default=9999999) The maximum confirmations to filter\n"
-            "3. \"addresses\"    (string) A json array of bitcoin addresses to filter\n"
-            "    [\n"
-            "      \"address\"   (string) bitcoin address\n"
-            "      ,...\n"
-            "    ]\n"
+            "1. \"ischecked\"    (bool) whether to return checked utxos only\n"
             "\nResult\n"
             "[                   (array of json object)\n"
             "  {\n"
@@ -2349,7 +2267,7 @@ UniValue listunspent(const UniValue& params, bool fHelp)
             "    \"address\" : \"address\",  (string) the bitcoin address\n"
             "    \"account\" : \"account\",  (string) DEPRECATED. The associated account, or \"\" for the default account\n"
             "    \"scriptPubKey\" : \"key\", (string) the script key\n"
-            "    \"amount\" : x.xxx,         (numeric) the transaction amount in " + CURRENCY_UNIT + "\n"
+            "    \"amount\" : xxxxx,         (numeric) the transaction amount\n"
             "    \"confirmations\" : n       (numeric) The number of confirmations\n"
             "  }\n"
             "  ,...\n"
@@ -2361,49 +2279,22 @@ UniValue listunspent(const UniValue& params, bool fHelp)
             + HelpExampleRpc("listunspent", "6, 9999999 \"[\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\",\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\"]\"")
         );
 
-    RPCTypeCheck(params, boost::assign::list_of(UniValue::VNUM)(UniValue::VNUM)(UniValue::VARR));
+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VBOOL));
 
-    int nMinDepth = 1;
-    if (params.size() > 0)
-        nMinDepth = params[0].get_int();
-
-    int nMaxDepth = 9999999;
-    if (params.size() > 1)
-        nMaxDepth = params[1].get_int();
+    bool fOnlyChecked = true;
 
-    set<CBitcoinAddress> setAddress;
-    if (params.size() > 2) {
-        UniValue inputs = params[2].get_array();
-        for (unsigned int idx = 0; idx < inputs.size(); idx++) {
-            const UniValue& input = inputs[idx];
-            CBitcoinAddress address(input.get_str());
-            if (!address.IsValid())
-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string("Invalid Bitcoin address: ")+input.get_str());
-            if (setAddress.count(address))
-                throw JSONRPCError(RPC_INVALID_PARAMETER, string("Invalid parameter, duplicated address: ")+input.get_str());
-           setAddress.insert(address);
-        }
-    }
+    if (params.size() > 0)
+        fOnlyChecked = params[0].get_bool();
 
     UniValue results(UniValue::VARR);
-    vector<COutput> vecOutputs;
+    vector<pair<COutput, uint32_t> > vecOutputs;
     assert(pwalletMain != NULL);
     LOCK2(cs_main, pwalletMain->cs_wallet);
-    pwalletMain->AvailableCoins(vecOutputs, false, NULL, true);
-    BOOST_FOREACH(const COutput& out, vecOutputs) {
-        if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)
-            continue;
-
-        if (setAddress.size()) {
-            CTxDestination address;
-            if (!ExtractDestination(out.tx->vout[out.i].scriptPubKey, address))
-                continue;
-
-            if (!setAddress.count(address))
-                continue;
-        }
+    pwalletMain->AvailableCoins(vecOutputs, false, NULL, true, fOnlyChecked);
+    BOOST_FOREACH(const PAIRTYPE(COutput, uint32_t)& out_locktime, vecOutputs) {
+        COutput out = out_locktime.first;
 
-        CAmount nValue = out.tx->vout[out.i].nValue;
+        CValue nValue = out.tx->vout[out.i].nValue;
         const CScript& pk = out.tx->vout[out.i].scriptPubKey;
         UniValue entry(UniValue::VOBJ);
         entry.push_back(Pair("txid", out.tx->GetHash().GetHex()));
@@ -2427,6 +2318,9 @@ UniValue listunspent(const UniValue& params, bool fHelp)
         entry.push_back(Pair("amount",ValueFromAmount(nValue)));
         entry.push_back(Pair("confirmations",out.nDepth));
         entry.push_back(Pair("spendable", out.fSpendable));
+        entry.push_back(Pair("checked", out.fChecked));
+        if (out_locktime.second != 0)
+            entry.push_back(Pair("locktime", int(out_locktime.second)));
         results.push_back(entry);
     }
 
@@ -2455,7 +2349,6 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)
                             "\nResult:\n"
                             "{\n"
                             "  \"hex\":       \"value\", (string)  The resulting raw transaction (hex-encoded string)\n"
-                            "  \"fee\":       n,         (numeric) Fee the resulting transaction pays\n"
                             "  \"changepos\": n          (numeric) The position of the added change output, or -1\n"
                             "}\n"
                             "\"hex\"             \n"
@@ -2485,16 +2378,14 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)
         includeWatching = params[1].get_bool();
 
     CMutableTransaction tx(origTx);
-    CAmount nFee;
     string strFailReason;
     int nChangePos = -1;
-    if(!pwalletMain->FundTransaction(tx, nFee, nChangePos, strFailReason, includeWatching))
+    if(!pwalletMain->FundTransaction(tx, nChangePos, strFailReason, includeWatching))
         throw JSONRPCError(RPC_INTERNAL_ERROR, strFailReason);
 
     UniValue result(UniValue::VOBJ);
     result.push_back(Pair("hex", EncodeHexTx(tx)));
     result.push_back(Pair("changepos", nChangePos));
-    result.push_back(Pair("fee", ValueFromAmount(nFee)));
 
     return result;
 }
diff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp
index 71f309148..cc7e51a6a 100644
--- a/src/wallet/wallet.cpp
+++ b/src/wallet/wallet.cpp
@@ -24,6 +24,7 @@
 #include "txmempool.h"
 #include "util.h"
 #include "utilmoneystr.h"
+#include "consensus/merkle.h"
 
 #include <assert.h>
 
@@ -33,27 +34,13 @@
 
 using namespace std;
 
-/** Transaction fee set by the user */
-CFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);
-CAmount maxTxFee = DEFAULT_TRANSACTION_MAXFEE;
 unsigned int nTxConfirmTarget = DEFAULT_TX_CONFIRM_TARGET;
 bool bSpendZeroConfChange = DEFAULT_SPEND_ZEROCONF_CHANGE;
-bool fSendFreeTransactions = DEFAULT_SEND_FREE_TRANSACTIONS;
-
-/**
- * Fees smaller than this (in satoshi) are considered zero fee (for transaction creation)
- * Override with -mintxfee
- */
-CFeeRate CWallet::minTxFee = CFeeRate(DEFAULT_TRANSACTION_MINFEE);
-/**
- * If fee estimation does not have enough data to provide estimates, use this fee instead.
- * Has no effect if not using fee estimation
- * Override with -fallbackfee
- */
-CFeeRate CWallet::fallbackFee = CFeeRate(DEFAULT_FALLBACK_FEE);
 
 const uint256 CMerkleTx::ABANDON_HASH(uint256S("0000000000000000000000000000000000000000000000000000000000000001"));
 
+typedef vector<unsigned char> valtype;
+
 /** @defgroup mapWallet
  *
  * @{
@@ -61,8 +48,8 @@ const uint256 CMerkleTx::ABANDON_HASH(uint256S("00000000000000000000000000000000
 
 struct CompareValueOnly
 {
-    bool operator()(const pair<CAmount, pair<const CWalletTx*, unsigned int> >& t1,
-                    const pair<CAmount, pair<const CWalletTx*, unsigned int> >& t2) const
+    bool operator()(const pair<int64_t, pair<const CWalletTx*, unsigned int> >& t1,
+                    const pair<int64_t, pair<const CWalletTx*, unsigned int> >& t2) const
     {
         return t1.first < t2.first;
     }
@@ -463,7 +450,7 @@ bool CWallet::IsSpent(const uint256& hash, unsigned int n) const
         std::map<uint256, CWalletTx>::const_iterator mit = mapWallet.find(wtxid);
         if (mit != mapWallet.end()) {
             int depth = mit->second.GetDepthInMainChain();
-            if (depth > 0  || (depth == 0 && !mit->second.isAbandoned()))
+            if (depth > 0  || (depth == 0 && !mit->second.bFirstTx && !mit->second.isAbandoned()))
                 return true; // Spent
         }
     }
@@ -754,9 +741,10 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pbl
             BOOST_FOREACH(const CTxIn& txin, tx.vin) {
                 std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range = mapTxSpends.equal_range(txin.prevout);
                 while (range.first != range.second) {
-                    if (range.first->second != tx.GetHash()) {
-                        LogPrintf("Transaction %s (in block %s) conflicts with wallet transaction %s (both spend %s:%i)\n", tx.GetHash().ToString(), pblock->GetHash().ToString(), range.first->second.ToString(), range.first->first.hash.ToString(), range.first->first.n);
-                        MarkConflicted(pblock->GetHash(), range.first->second);
+                    uint256 pal = range.first->second;
+                    if (pal != tx.GetHash()) {
+                        // LogPrintf("Transaction %s (in block %s) conflicts with wallet transaction %s (both spend %s:%i)\n", tx.GetHash().ToString(), pblock->GetHash().ToString(), pal.ToString(), range.first->first.hash.ToString(), range.first->first.n);
+                        MarkConflicted(pblock->GetHash(), pal);
                     }
                     range.first++;
                 }
@@ -821,7 +809,8 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)
             wtx.WriteToDisk(&walletdb);
             NotifyTransactionChanged(this, wtx.GetHash(), CT_UPDATED);
             // Iterate over all its outputs, and mark transactions in the wallet that spend them abandoned too
-            TxSpends::const_iterator iter = mapTxSpends.lower_bound(COutPoint(hashTx, 0));
+            // TxSpends::const_iterator iter = mapTxSpends.lower_bound(COutPoint(hashTx, 0));
+            TxSpends::const_iterator iter = mapTxSpends.lower_bound(COutPoint(now, 0));
             while (iter != mapTxSpends.end() && iter->first.hash == now) {
                 if (!done.count(iter->second)) {
                     todo.insert(iter->second);
@@ -873,6 +862,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)
         done.insert(now);
         assert(mapWallet.count(now));
         CWalletTx& wtx = mapWallet[now];
+        if (wtx.isAbandoned()) continue;
         int currentconfirm = wtx.GetDepthInMainChain();
         if (conflictconfirms < currentconfirm) {
             // Block is 'more conflicted' than current confirm; update.
@@ -933,7 +923,7 @@ isminetype CWallet::IsMine(const CTxIn &txin) const
     return ISMINE_NO;
 }
 
-CAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const
+CValue CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const
 {
     {
         LOCK(cs_wallet);
@@ -946,7 +936,7 @@ CAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const
                     return prev.vout[txin.prevout.n].nValue;
         }
     }
-    return 0;
+    return std::make_pair(0, 0);
 }
 
 isminetype CWallet::IsMine(const CTxOut& txout) const
@@ -954,11 +944,11 @@ isminetype CWallet::IsMine(const CTxOut& txout) const
     return ::IsMine(*this, txout.scriptPubKey);
 }
 
-CAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const
+CValue CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const
 {
     if (!MoneyRange(txout.nValue))
         throw std::runtime_error("CWallet::GetCredit(): value out of range");
-    return ((IsMine(txout) & filter) ? txout.nValue : 0);
+    return ((IsMine(txout) & filter) ? txout.nValue : std::make_pair((uint32_t)0,(int64_t)0));
 }
 
 bool CWallet::IsChange(const CTxOut& txout) const
@@ -983,11 +973,11 @@ bool CWallet::IsChange(const CTxOut& txout) const
     return false;
 }
 
-CAmount CWallet::GetChange(const CTxOut& txout) const
+CValue CWallet::GetChange(const CTxOut& txout) const
 {
     if (!MoneyRange(txout.nValue))
         throw std::runtime_error("CWallet::GetChange(): value out of range");
-    return (IsChange(txout) ? txout.nValue : 0);
+    return (IsChange(txout) ? txout.nValue : std::make_pair((uint32_t)0,(int64_t)0));
 }
 
 bool CWallet::IsMine(const CTransaction& tx) const
@@ -1000,15 +990,17 @@ bool CWallet::IsMine(const CTransaction& tx) const
 
 bool CWallet::IsFromMe(const CTransaction& tx) const
 {
-    return (GetDebit(tx, ISMINE_ALL) > 0);
+    return (GetDebit(tx, ISMINE_ALL) > CAmount());
 }
 
 CAmount CWallet::GetDebit(const CTransaction& tx, const isminefilter& filter) const
 {
-    CAmount nDebit = 0;
+    CAmount nDebit;
+    CValue cval;
     BOOST_FOREACH(const CTxIn& txin, tx.vin)
     {
-        nDebit += GetDebit(txin, filter);
+        cval = GetDebit(txin, filter);
+        nDebit[cval.first] += cval.second;
         if (!MoneyRange(nDebit))
             throw std::runtime_error("CWallet::GetDebit(): value out of range");
     }
@@ -1017,7 +1009,8 @@ CAmount CWallet::GetDebit(const CTransaction& tx, const isminefilter& filter) co
 
 CAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) const
 {
-    CAmount nCredit = 0;
+    CAmount nCredit;
+
     BOOST_FOREACH(const CTxOut& txout, tx.vout)
     {
         nCredit += GetCredit(txout, filter);
@@ -1029,10 +1022,12 @@ CAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) c
 
 CAmount CWallet::GetChange(const CTransaction& tx) const
 {
-    CAmount nChange = 0;
+    CAmount nChange;
+    CValue cval;
     BOOST_FOREACH(const CTxOut& txout, tx.vout)
     {
-        nChange += GetChange(txout);
+        cval = GetChange(txout);
+        nChange[cval.first] += cval.second;
         if (!MoneyRange(nChange))
             throw std::runtime_error("CWallet::GetChange(): value out of range");
     }
@@ -1085,33 +1080,31 @@ int CWalletTx::GetRequestCount() const
 }
 
 void CWalletTx::GetAmounts(list<COutputEntry>& listReceived,
-                           list<COutputEntry>& listSent, CAmount& nFee, string& strSentAccount, const isminefilter& filter) const
+                           list<COutputEntry>& listSent, string& strSentAccount, const isminefilter& filter) const
 {
-    nFee = 0;
     listReceived.clear();
     listSent.clear();
     strSentAccount = strFromAccount;
 
     // Compute fee:
     CAmount nDebit = GetDebit(filter);
-    if (nDebit > 0) // debit>0 means we signed/sent this transaction
-    {
-        CAmount nValueOut = GetValueOut();
-        nFee = nDebit - nValueOut;
-    }
-
     // Sent/received.
     for (unsigned int i = 0; i < vout.size(); ++i)
     {
         const CTxOut& txout = vout[i];
+
+        // Don't report NULLDATA output
+        if (txout.nValue.second == 0) continue;
+
         isminetype fIsMine = pwallet->IsMine(txout);
         // Only need to handle txouts if AT LEAST one of these is true:
         //   1) they debit from us (sent)
         //   2) the output is to us (received)
-        if (nDebit > 0)
+        if (nDebit > CAmount())
         {
             // Don't report 'change' txouts
-            if (pwallet->IsChange(txout))
+            // if (pwallet->IsChange(txout))
+            if (fIsMine == ISMINE_SPENDABLE)
                 continue;
         }
         else if (!(fIsMine & filter))
@@ -1130,7 +1123,7 @@ void CWalletTx::GetAmounts(list<COutputEntry>& listReceived,
         COutputEntry output = {address, txout.nValue, (int)i};
 
         // If we are debited by the transaction, add the output as a "sent" entry
-        if (nDebit > 0)
+        if (nDebit > CAmount())
             listSent.push_back(output);
 
         // If we are receiving the output, add it as a "received" entry
@@ -1141,21 +1134,21 @@ void CWalletTx::GetAmounts(list<COutputEntry>& listReceived,
 }
 
 void CWalletTx::GetAccountAmounts(const string& strAccount, CAmount& nReceived,
-                                  CAmount& nSent, CAmount& nFee, const isminefilter& filter) const
+                                  CAmount& nSent, const isminefilter& filter) const
 {
-    nReceived = nSent = nFee = 0;
 
-    CAmount allFee;
+    nReceived.clear();
+    nSent.clear();
+
     string strSentAccount;
     list<COutputEntry> listReceived;
     list<COutputEntry> listSent;
-    GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);
+    GetAmounts(listReceived, listSent, strSentAccount, filter);
 
     if (strAccount == strSentAccount)
     {
         BOOST_FOREACH(const COutputEntry& s, listSent)
-            nSent += s.amount;
-        nFee = allFee;
+            nSent[s.amount.first] += s.amount.second;
     }
     {
         LOCK(pwallet->cs_wallet);
@@ -1165,11 +1158,11 @@ void CWalletTx::GetAccountAmounts(const string& strAccount, CAmount& nReceived,
             {
                 map<CTxDestination, CAddressBookData>::const_iterator mi = pwallet->mapAddressBook.find(r.destination);
                 if (mi != pwallet->mapAddressBook.end() && (*mi).second.name == strAccount)
-                    nReceived += r.amount;
+                    nReceived[r.amount.first] += r.amount.second;
             }
             else if (strAccount.empty())
             {
-                nReceived += r.amount;
+                nReceived[r.amount.first] += r.amount.second;
             }
         }
     }
@@ -1255,14 +1248,14 @@ void CWallet::ReacceptWalletTransactions()
         CWalletTx& wtx = *(item.second);
 
         LOCK(mempool.cs);
-        wtx.AcceptToMemoryPool(false);
+        wtx.AcceptToMemoryPool();
     }
 }
 
 bool CWalletTx::RelayWalletTransaction()
 {
     assert(pwallet->GetBroadcastTransactions());
-    if (!IsCoinBase())
+    if (!IsCoinBase() && !bFirstTx)
     {
         if (GetDepthInMainChain() == 0 && !isAbandoned()) {
             LogPrintf("Relaying wtx %s\n", GetHash().ToString());
@@ -1287,10 +1280,10 @@ set<uint256> CWalletTx::GetConflicts() const
 
 CAmount CWalletTx::GetDebit(const isminefilter& filter) const
 {
+    CAmount debit;
     if (vin.empty())
-        return 0;
+        return debit;
 
-    CAmount debit = 0;
     if(filter & ISMINE_SPENDABLE)
     {
         if (fDebitCached)
@@ -1318,11 +1311,12 @@ CAmount CWalletTx::GetDebit(const isminefilter& filter) const
 
 CAmount CWalletTx::GetCredit(const isminefilter& filter) const
 {
+    CAmount credit;
+
     // Must wait until coinbase is safely deep enough in the chain before valuing it
     if (IsCoinBase() && GetBlocksToMaturity() > 0)
-        return 0;
+        return credit;
 
-    int64_t credit = 0;
     if (filter & ISMINE_SPENDABLE)
     {
         // GetBalance can assume transactions in mapWallet won't change
@@ -1349,33 +1343,20 @@ CAmount CWalletTx::GetCredit(const isminefilter& filter) const
     return credit;
 }
 
-CAmount CWalletTx::GetImmatureCredit(bool fUseCache) const
-{
-    if (IsCoinBase() && GetBlocksToMaturity() > 0 && IsInMainChain())
-    {
-        if (fUseCache && fImmatureCreditCached)
-            return nImmatureCreditCached;
-        nImmatureCreditCached = pwallet->GetCredit(*this, ISMINE_SPENDABLE);
-        fImmatureCreditCached = true;
-        return nImmatureCreditCached;
-    }
-
-    return 0;
-}
-
 CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const
 {
+    CAmount nCredit;
+
     if (pwallet == 0)
-        return 0;
+        return nCredit;
 
     // Must wait until coinbase is safely deep enough in the chain before valuing it
     if (IsCoinBase() && GetBlocksToMaturity() > 0)
-        return 0;
+        return nCredit;
 
     if (fUseCache && fAvailableCreditCached)
         return nAvailableCreditCached;
 
-    CAmount nCredit = 0;
     uint256 hashTx = GetHash();
     for (unsigned int i = 0; i < vout.size(); i++)
     {
@@ -1395,6 +1376,8 @@ CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const
 
 CAmount CWalletTx::GetImmatureWatchOnlyCredit(const bool& fUseCache) const
 {
+    CAmount credit;
+
     if (IsCoinBase() && GetBlocksToMaturity() > 0 && IsInMainChain())
     {
         if (fUseCache && fImmatureWatchCreditCached)
@@ -1404,22 +1387,23 @@ CAmount CWalletTx::GetImmatureWatchOnlyCredit(const bool& fUseCache) const
         return nImmatureWatchCreditCached;
     }
 
-    return 0;
+    return credit;
 }
 
 CAmount CWalletTx::GetAvailableWatchOnlyCredit(const bool& fUseCache) const
 {
+    CAmount nCredit;
+
     if (pwallet == 0)
-        return 0;
+        return nCredit;
 
     // Must wait until coinbase is safely deep enough in the chain before valuing it
     if (IsCoinBase() && GetBlocksToMaturity() > 0)
-        return 0;
+        return nCredit;
 
     if (fUseCache && fAvailableWatchCreditCached)
         return nAvailableWatchCreditCached;
 
-    CAmount nCredit = 0;
     for (unsigned int i = 0; i < vout.size(); i++)
     {
         if (!pwallet->IsSpent(GetHash(), i))
@@ -1459,11 +1443,21 @@ bool CWalletTx::IsTrusted() const
     // Quick answer in most cases
     if (!CheckFinalTx(*this))
         return false;
+
+    int nRootHeight = chainActive.Tip()->nRootHeight;
+    int nOperatorHeight = chainActive.Tip()->nOperatorHeight;
+    int nChainHeight = chainActive.Height();
+
     int nDepth = GetDepthInMainChain();
-    if (nDepth >= 1)
-        return true;
+
+    int nHeight = nChainHeight - nDepth + 1;
+
+    if (nRootHeight >= nHeight || nOperatorHeight >= nHeight) return true;
+
+#if 0
     if (nDepth < 0)
         return false;
+
     if (!bSpendZeroConfChange || !IsFromMe(ISMINE_ALL)) // using wtx's cached debit
         return false;
 
@@ -1483,6 +1477,9 @@ bool CWalletTx::IsTrusted() const
             return false;
     }
     return true;
+#else
+    return false;
+#endif
 }
 
 bool CWalletTx::IsEquivalentTo(const CWalletTx& tx) const
@@ -1507,13 +1504,21 @@ std::vector<uint256> CWallet::ResendWalletTransactionsBefore(int64_t nTime)
         // Don't rebroadcast if newer than nTime:
         if (wtx.nTimeReceived > nTime)
             continue;
+        if (wtx.bFirstTx)
+            continue;
         mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));
     }
     BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)
     {
         CWalletTx& wtx = *item.second;
-        if (wtx.RelayWalletTransaction())
-            result.push_back(wtx.GetHash());
+        if (wtx.RelayWalletTransaction()) {
+            if (!wtx.InMempool()) {
+                if (wtx.AcceptToMemoryPool())
+                    result.push_back(wtx.GetHash());
+                else
+                    AbandonTransaction(wtx.GetHash());
+            }
+        }
     }
     return result;
 }
@@ -1525,7 +1530,8 @@ void CWallet::ResendWalletTransactions(int64_t nBestBlockTime)
     if (GetTime() < nNextResend || !fBroadcastTransactions)
         return;
     bool fFirst = (nNextResend == 0);
-    nNextResend = GetTime() + GetRand(30 * 60);
+    // nNextResend = GetTime() + GetRand(30 * 60);
+    nNextResend = GetTime() + GetRand(10);
     if (fFirst)
         return;
 
@@ -1536,7 +1542,8 @@ void CWallet::ResendWalletTransactions(int64_t nBestBlockTime)
 
     // Rebroadcast unconfirmed txes older than 5 minutes before the last
     // block was found:
-    std::vector<uint256> relayed = ResendWalletTransactionsBefore(nBestBlockTime-5*60);
+    // std::vector<uint256> relayed = ResendWalletTransactionsBefore(nBestBlockTime-5*60);
+    std::vector<uint256> relayed = ResendWalletTransactionsBefore(nBestBlockTime);
     if (!relayed.empty())
         LogPrintf("%s: rebroadcast %u unconfirmed transactions\n", __func__, relayed.size());
 }
@@ -1554,7 +1561,7 @@ void CWallet::ResendWalletTransactions(int64_t nBestBlockTime)
 
 CAmount CWallet::GetBalance() const
 {
-    CAmount nTotal = 0;
+    CAmount nTotal;
     {
         LOCK2(cs_main, cs_wallet);
         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
@@ -1570,36 +1577,22 @@ CAmount CWallet::GetBalance() const
 
 CAmount CWallet::GetUnconfirmedBalance() const
 {
-    CAmount nTotal = 0;
+    CAmount nTotal;
     {
         LOCK2(cs_main, cs_wallet);
         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
         {
             const CWalletTx* pcoin = &(*it).second;
-            if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())
+            if (!pcoin->IsTrusted() && (pcoin->GetDepthInMainChain() > 0 || (pcoin->GetDepthInMainChain() > 0 && pcoin->InMempool())))
                 nTotal += pcoin->GetAvailableCredit();
         }
     }
     return nTotal;
 }
 
-CAmount CWallet::GetImmatureBalance() const
-{
-    CAmount nTotal = 0;
-    {
-        LOCK2(cs_main, cs_wallet);
-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
-        {
-            const CWalletTx* pcoin = &(*it).second;
-            nTotal += pcoin->GetImmatureCredit();
-        }
-    }
-    return nTotal;
-}
-
 CAmount CWallet::GetWatchOnlyBalance() const
 {
-    CAmount nTotal = 0;
+    CAmount nTotal;
     {
         LOCK2(cs_main, cs_wallet);
         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
@@ -1615,39 +1608,30 @@ CAmount CWallet::GetWatchOnlyBalance() const
 
 CAmount CWallet::GetUnconfirmedWatchOnlyBalance() const
 {
-    CAmount nTotal = 0;
+    CAmount nTotal;
     {
         LOCK2(cs_main, cs_wallet);
         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
         {
             const CWalletTx* pcoin = &(*it).second;
-            if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())
+            if (!pcoin->IsTrusted() && (pcoin->GetDepthInMainChain() > 0 || (pcoin->GetDepthInMainChain() > 0 && pcoin->InMempool())))
                 nTotal += pcoin->GetAvailableWatchOnlyCredit();
         }
     }
     return nTotal;
 }
 
-CAmount CWallet::GetImmatureWatchOnlyBalance() const
-{
-    CAmount nTotal = 0;
-    {
-        LOCK2(cs_main, cs_wallet);
-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
-        {
-            const CWalletTx* pcoin = &(*it).second;
-            nTotal += pcoin->GetImmatureWatchOnlyCredit();
-        }
-    }
-    return nTotal;
-}
-
-void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue) const
+void CWallet::AvailableCoins(vector<pair<COutput, uint32_t> >& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue, bool fOnlyChecked) const
 {
     vCoins.clear();
 
     {
         LOCK2(cs_main, cs_wallet);
+
+        int nRootHeight = chainActive.Tip()->nRootHeight;
+        int nOperatorHeight = chainActive.Tip()->nOperatorHeight;
+        int nChainHeight = chainActive.Height();
+
         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
         {
             const uint256& wtxid = it->first;
@@ -1671,21 +1655,41 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const
             if (nDepth == 0 && !pcoin->InMempool())
                 continue;
 
+            int nHeight = nChainHeight - nDepth + 1;
+            bool isChecked = nRootHeight >= nHeight || nOperatorHeight >= nHeight;
+            if (fOnlyChecked && !isChecked) continue;
+
             for (unsigned int i = 0; i < pcoin->vout.size(); i++) {
                 isminetype mine = IsMine(pcoin->vout[i]);
                 if (!(IsSpent(wtxid, i)) && mine != ISMINE_NO &&
-                    !IsLockedCoin((*it).first, i) && (pcoin->vout[i].nValue > 0 || fIncludeZeroValue) &&
-                    (!coinControl || !coinControl->HasSelected() || coinControl->fAllowOtherInputs || coinControl->IsSelected((*it).first, i)))
-                        vCoins.push_back(COutput(pcoin, i, nDepth,
+                    !IsLockedCoin((*it).first, i) && (pcoin->vout[i].nValue.second > 0 || fIncludeZeroValue) &&
+                    (!coinControl || !coinControl->HasSelected() || coinControl->fAllowOtherInputs || coinControl->IsSelected((*it).first, i))) {
+                        uint32_t nCoinLockTime = 0;
+                        CScript oscriptPubKey = pcoin->vout[i].scriptPubKey;
+
+                        CScript::const_iterator pc = oscriptPubKey.begin();
+                        opcodetype opcode;
+                        std::vector<unsigned char> vchRet;
+
+                        if (oscriptPubKey.GetOp(pc, opcode, vchRet) && opcode <= OP_PUSHDATA4 && 
+                            oscriptPubKey.GetOp(pc, opcode) && opcode == OP_CHECKLOCKTIMEVERIFY && 
+                            oscriptPubKey.GetOp(pc, opcode) && opcode == OP_DROP) {
+                            for (unsigned i = 0; i < vchRet.size(); i++) {
+                                nCoinLockTime += vchRet[i] << (i * 8);
+                            }
+                        }
+
+                        vCoins.push_back(make_pair(COutput(pcoin, i, nDepth,
                                                  ((mine & ISMINE_SPENDABLE) != ISMINE_NO) ||
-                                                  (coinControl && coinControl->fAllowWatchOnly && (mine & ISMINE_WATCH_SOLVABLE) != ISMINE_NO)));
+                                                  (coinControl && coinControl->fAllowWatchOnly && (mine & ISMINE_WATCH_SOLVABLE) != ISMINE_NO), isChecked), nCoinLockTime));
+                }
             }
         }
     }
 }
 
-static void ApproximateBestSubset(vector<pair<CAmount, pair<const CWalletTx*,unsigned int> > >vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,
-                                  vector<char>& vfBest, CAmount& nBest, int iterations = 1000)
+static void ApproximateBestSubset(vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > >vValue, const int64_t& nTotalLower, const int64_t& nTargetValue,
+                                  vector<char>& vfBest, int64_t& nBest, int iterations = 1000)
 {
     vector<char> vfIncluded;
 
@@ -1697,7 +1701,7 @@ static void ApproximateBestSubset(vector<pair<CAmount, pair<const CWalletTx*,uns
     for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)
     {
         vfIncluded.assign(vValue.size(), false);
-        CAmount nTotal = 0;
+        int64_t nTotal = 0;
         bool fReachedTarget = false;
         for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)
         {
@@ -1740,18 +1744,43 @@ static void ApproximateBestSubset(vector<pair<CAmount, pair<const CWalletTx*,uns
     }
 }
 
-bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, vector<COutput> vCoins,
-                                 set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const
+bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMine, const int nConfTheirs, std::vector<COutput> vCoins,
+                                 std::set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const
+{
+    setCoinsRet.clear();
+    nValueRet.clear();
+
+    CValue retval;
+    std::set<std::pair<const CWalletTx*,unsigned int> > setcoins;
+
+    BOOST_FOREACH(const CValue tgtval, nTargetValue) {
+        if (!inner_SelectCoinsMinConf(tgtval, nConfMine, nConfTheirs, vCoins, setcoins, retval))
+            return false;
+        setCoinsRet.insert(setcoins.begin(), setcoins.end());
+        nValueRet += retval;
+    }
+
+    return true;
+
+}
+bool CWallet::inner_SelectCoinsMinConf(const CValue& NtARGETvALUE, const int nConfMine, const int nConfTheirs, std::vector<COutput> vCoins,
+                                 std::set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, CValue& NvALUErET) const
 {
+    uint32_t asset_id = NtARGETvALUE.first;
+    int64_t nTargetValue = NtARGETvALUE.second;
+    int64_t nValueRet;
+
     setCoinsRet.clear();
     nValueRet = 0;
 
     // List of values less than target
-    pair<CAmount, pair<const CWalletTx*,unsigned int> > coinLowestLarger;
-    coinLowestLarger.first = std::numeric_limits<CAmount>::max();
+    pair<int64_t, pair<const CWalletTx*,unsigned int> > coinLowestLarger;
+    coinLowestLarger.first = std::numeric_limits<int64_t>::max();
     coinLowestLarger.second.first = NULL;
-    vector<pair<CAmount, pair<const CWalletTx*,unsigned int> > > vValue;
-    CAmount nTotalLower = 0;
+    vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > > vValue;
+    int64_t nTotalLower = 0;
+    vector<char> vfBest;
+    int64_t nBest;
 
     random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);
 
@@ -1766,17 +1795,20 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int
             continue;
 
         int i = output.i;
-        CAmount n = pcoin->vout[i].nValue;
+        CValue m = pcoin->vout[i].nValue;
+        if (m.first != asset_id)
+            continue;
+        int64_t n = m.second;
 
-        pair<CAmount,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));
+        pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));
 
         if (n == nTargetValue)
         {
             setCoinsRet.insert(coin.second);
             nValueRet += coin.first;
-            return true;
+            goto success;
         }
-        else if (n < nTargetValue + MIN_CHANGE)
+        else if (n < nTargetValue)
         {
             vValue.push_back(coin);
             nTotalLower += n;
@@ -1794,7 +1826,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int
             setCoinsRet.insert(vValue[i].second);
             nValueRet += vValue[i].first;
         }
-        return true;
+        goto success;
     }
 
     if (nTotalLower < nTargetValue)
@@ -1803,22 +1835,20 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int
             return false;
         setCoinsRet.insert(coinLowestLarger.second);
         nValueRet += coinLowestLarger.first;
-        return true;
+        goto success;
     }
 
     // Solve subset sum by stochastic approximation
     sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());
-    vector<char> vfBest;
-    CAmount nBest;
 
     ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest);
-    if (nBest != nTargetValue && nTotalLower >= nTargetValue + MIN_CHANGE)
-        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + MIN_CHANGE, vfBest, nBest);
+    // if (nBest != nTargetValue && nTotalLower >= nTargetValue + MIN_CHANGE)
+    //    ApproximateBestSubset(vValue, nTotalLower, nTargetValue + MIN_CHANGE, vfBest, nBest);
 
     // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,
     //                                   or the next bigger coin is closer), return the bigger coin
     if (coinLowestLarger.second.first &&
-        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || coinLowestLarger.first <= nBest))
+        (nBest < nTargetValue || coinLowestLarger.first <= nBest))
     {
         setCoinsRet.insert(coinLowestLarger.second);
         nValueRet += coinLowestLarger.first;
@@ -1838,13 +1868,20 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int
         LogPrint("selectcoins", "total %s\n", FormatMoney(nBest));
     }
 
+success:
+    NvALUErET.first = NtARGETvALUE.first;
+    NvALUErET.second = nValueRet;
     return true;
 }
 
-bool CWallet::SelectCoins(const CAmount& nTargetValue, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const
+bool CWallet::SelectCoins(const CAmount& nTargetValue, uint32_t& nLockTime, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const
 {
+    vector<pair<COutput, uint32_t> > vCoinsTimed;
+    AvailableCoins(vCoinsTimed, true, coinControl, false, true);
+
     vector<COutput> vCoins;
-    AvailableCoins(vCoins, true, coinControl);
+    for(vector<pair<COutput, uint32_t> >::iterator it = vCoinsTimed.begin(); it != vCoinsTimed.end(); it++)
+        if (it->second <= nLockTime) vCoins.push_back(it->first);
 
     // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)
     if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs)
@@ -1861,7 +1898,7 @@ bool CWallet::SelectCoins(const CAmount& nTargetValue, set<pair<const CWalletTx*
 
     // calculate value from preset inputs and store them
     set<pair<const CWalletTx*, uint32_t> > setPresetCoins;
-    CAmount nValueFromPresetInputs = 0;
+    CAmount nValueFromPresetInputs;
 
     std::vector<COutPoint> vPresetInputs;
     if (coinControl)
@@ -1904,14 +1941,14 @@ bool CWallet::SelectCoins(const CAmount& nTargetValue, set<pair<const CWalletTx*
     return res;
 }
 
-bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount &nFeeRet, int& nChangePosRet, std::string& strFailReason, bool includeWatching)
+bool CWallet::FundTransaction(CMutableTransaction& tx, int& nChangePosRet, std::string& strFailReason, bool includeWatching)
 {
     vector<CRecipient> vecSend;
 
     // Turn the txout set into a CRecipient vector
     BOOST_FOREACH(const CTxOut& txOut, tx.vout)
     {
-        CRecipient recipient = {txOut.scriptPubKey, txOut.nValue, false};
+        CRecipient recipient = {txOut.scriptPubKey, txOut.nValue};
         vecSend.push_back(recipient);
     }
 
@@ -1923,7 +1960,7 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount &nFeeRet, int& nC
 
     CReserveKey reservekey(this);
     CWalletTx wtx;
-    if (!CreateTransaction(vecSend, wtx, reservekey, nFeeRet, nChangePosRet, strFailReason, &coinControl, false))
+    if (!CreateTransaction(vecSend, wtx, reservekey, nChangePosRet, strFailReason, &coinControl, false))
         return false;
 
     if (nChangePosRet != -1)
@@ -1948,24 +1985,36 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount &nFeeRet, int& nC
     return true;
 }
 
-bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet,
+bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey,
                                 int& nChangePosRet, std::string& strFailReason, const CCoinControl* coinControl, bool sign)
 {
-    CAmount nValue = 0;
-    unsigned int nSubtractFeeFromAmount = 0;
+    CAmount nValue;
     BOOST_FOREACH (const CRecipient& recipient, vecSend)
     {
-        if (nValue < 0 || recipient.nAmount < 0)
+
+        if (recipient.nAmount.second < 0)
         {
             strFailReason = _("Transaction amounts must be positive");
             return false;
         }
-        nValue += recipient.nAmount;
+        // Must pay to an authoried transaction id
+        suint160 id, primeid;
+
+        if (chainActive.IdAuthorized(recipient.scriptPubKey, id, primeid)) {
+            if (!primeid.first && CKeyID(primeid.second) == vchDefaultKey.GetID()) {
+                strFailReason = _("Cannot pay to self");
+                return false;
+            }
+        }
+        else {
+            strFailReason = _("Receiver id must be authorized");
+            return false;
+        }
+
+        nValue[recipient.nAmount.first] += recipient.nAmount.second;
 
-        if (recipient.fSubtractFeeFromAmount)
-            nSubtractFeeFromAmount++;
     }
-    if (vecSend.empty() || nValue < 0)
+    if (vecSend.empty())
     {
         strFailReason = _("Transaction amounts must be positive");
         return false;
@@ -1975,6 +2024,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt
     wtxNew.BindWallet(this);
     CMutableTransaction txNew;
 
+#if 0
     // Discourage fee sniping.
     //
     // For a large miner the value of the transactions in the best block and
@@ -2006,234 +2056,400 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt
 
     assert(txNew.nLockTime <= (unsigned int)chainActive.Height());
     assert(txNew.nLockTime < LOCKTIME_THRESHOLD);
+#else
+    txNew.nLockTime = chainActive.Tip()->GetMedianTimePast() - 1;
+
+    if (GetRandInt(10) == 0)
+        txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100));
 
+    assert(txNew.nLockTime >= LOCKTIME_THRESHOLD);
+#endif
     {
         LOCK2(cs_main, cs_wallet);
         {
-            nFeeRet = 0;
-            // Start with no fee and loop until there is enough fee
-            while (true)
+            txNew.vin.clear();
+            txNew.vout.clear();
+            wtxNew.fFromMe = true;
+            nChangePosRet = -1;
+
+            CAmount nValueToSelect = nValue;
+            // vouts to the payees
+            BOOST_FOREACH (const CRecipient& recipient, vecSend)
             {
-                txNew.vin.clear();
-                txNew.vout.clear();
-                wtxNew.fFromMe = true;
-                nChangePosRet = -1;
-                bool fFirst = true;
-
-                CAmount nValueToSelect = nValue;
-                if (nSubtractFeeFromAmount == 0)
-                    nValueToSelect += nFeeRet;
-                double dPriority = 0;
-                // vouts to the payees
-                BOOST_FOREACH (const CRecipient& recipient, vecSend)
-                {
-                    CTxOut txout(recipient.nAmount, recipient.scriptPubKey);
+                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);
 
-                    if (recipient.fSubtractFeeFromAmount)
-                    {
-                        txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient
+                txNew.vout.push_back(txout);
+            }
 
-                        if (fFirst) // first receiver pays the remainder not divisible by output count
-                        {
-                            fFirst = false;
-                            txout.nValue -= nFeeRet % nSubtractFeeFromAmount;
-                        }
-                    }
+            // Choose coins to use
+            set<pair<const CWalletTx*,unsigned int> > setCoins;
+            CAmount nValueIn;
+            if (!SelectCoins(nValueToSelect, txNew.nLockTime, setCoins, nValueIn, coinControl))
+            {
+                strFailReason = _("Insufficient funds");
+                return false;
+            }
 
-                    if (txout.IsDust(::minRelayTxFee))
-                    {
-                        if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)
-                        {
-                            if (txout.nValue < 0)
-                                strFailReason = _("The transaction amount is too small to pay the fee");
-                            else
-                                strFailReason = _("The transaction amount is too small to send after the fee has been deducted");
-                        }
-                        else
-                            strFailReason = _("Transaction amount too small");
-                        return false;
-                    }
-                    txNew.vout.push_back(txout);
-                }
+            const CAmount nChange = nValueIn - nValueToSelect;
+            if (nChange.size() > 0)
+            {
+                // Fill a vout to ourself
+                // TODO: pass in scriptChange instead of reservekey so
+                // change transaction isn't always pay-to-bitcoin-address
+                CScript scriptChange;
 
-                // Choose coins to use
-                set<pair<const CWalletTx*,unsigned int> > setCoins;
-                CAmount nValueIn = 0;
-                if (!SelectCoins(nValueToSelect, setCoins, nValueIn, coinControl))
-                {
-                    strFailReason = _("Insufficient funds");
-                    return false;
-                }
-                BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)
-                {
-                    CAmount nCredit = pcoin.first->vout[pcoin.second].nValue;
-                    //The coin age after the next block (depth+1) is used instead of the current,
-                    //reflecting an assumption the user would accept a bit more delay for
-                    //a chance at a free transaction.
-                    //But mempool inputs might still be in the mempool, so their age stays 0
-                    int age = pcoin.first->GetDepthInMainChain();
-                    assert(age >= 0);
-                    if (age != 0)
-                        age += 1;
-                    dPriority += (double)nCredit * age;
-                }
+                // coin control: send change to custom address
+                if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))
+                    scriptChange = GetScriptForDestination(coinControl->destChange);
 
-                const CAmount nChange = nValueIn - nValueToSelect;
-                if (nChange > 0)
+                // no coin control: send change to newly generated address
+                else
                 {
-                    // Fill a vout to ourself
-                    // TODO: pass in scriptChange instead of reservekey so
-                    // change transaction isn't always pay-to-bitcoin-address
-                    CScript scriptChange;
-
-                    // coin control: send change to custom address
-                    if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))
-                        scriptChange = GetScriptForDestination(coinControl->destChange);
-
-                    // no coin control: send change to newly generated address
-                    else
-                    {
-                        // Note: We use a new key here to keep it from being obvious which side is the change.
-                        //  The drawback is that by not reusing a previous key, the change may be lost if a
-                        //  backup is restored, if the backup doesn't have the new private key for the change.
-                        //  If we reused the old key, it would be possible to add code to look for and
-                        //  rediscover unknown transactions that were written with keys of ours to recover
-                        //  post-backup change.
-
-                        // Reserve a new key pair from key pool
-                        CPubKey vchPubKey;
-                        bool ret;
-                        ret = reservekey.GetReservedKey(vchPubKey);
-                        assert(ret); // should never fail, as we just unlocked
-
-                        scriptChange = GetScriptForDestination(vchPubKey.GetID());
+                    // Note: We use a new key here to keep it from being obvious which side is the change.
+                    //  The drawback is that by not reusing a previous key, the change may be lost if a
+                    //  backup is restored, if the backup doesn't have the new private key for the change.
+                    //  If we reused the old key, it would be possible to add code to look for and
+                    //  rediscover unknown transactions that were written with keys of ours to recover
+                    //  post-backup change.
+
+                    // Reserve a new key pair from key pool
+                    CPubKey vchPubKey;
+
+                    if (!reservekey.GetReservedKey(vchPubKey)) {
+                        // Default to primary key
+                        vchPubKey = vchDefaultKey;
+
+                        if (!HaveKey(vchPubKey.GetID())) {
+                            strFailReason = _("Primary private key missing.");
+                            return false;
+                        }
                     }
 
-                    CTxOut newTxOut(nChange, scriptChange);
+                    scriptChange = GetScriptForDestination(vchPubKey.GetID());
+                }
 
-                    // We do not move dust-change to fees, because the sender would end up paying more than requested.
-                    // This would be against the purpose of the all-inclusive feature.
-                    // So instead we raise the change and deduct from the recipient.
-                    if (nSubtractFeeFromAmount > 0 && newTxOut.IsDust(::minRelayTxFee))
-                    {
-                        CAmount nDust = newTxOut.GetDustThreshold(::minRelayTxFee) - newTxOut.nValue;
-                        newTxOut.nValue += nDust; // raise change until no more dust
-                        for (unsigned int i = 0; i < vecSend.size(); i++) // subtract from first recipient
-                        {
-                            if (vecSend[i].fSubtractFeeFromAmount)
-                            {
-                                txNew.vout[i].nValue -= nDust;
-                                if (txNew.vout[i].IsDust(::minRelayTxFee))
-                                {
-                                    strFailReason = _("The transaction amount is too small to send after the fee has been deducted");
-                                    return false;
-                                }
-                                break;
-                            }
-                        }
+                BOOST_FOREACH(const CValue& cvTarget, nChange) {
+    ////////////////////////////////////////////////////
+                    if (cvTarget.second == 0)
+                        continue;
+                    if (cvTarget.second < 0) {
+                        strFailReason = _("The transaction amount is too small to send after the fee has been deducted");
+                        return false;
                     }
 
-                    // Never create dust outputs; if we would, just
-                    // add the dust to the fee.
-                    if (newTxOut.IsDust(::minRelayTxFee))
-                    {
-                        nFeeRet += nChange;
-                        reservekey.ReturnKey();
-                    }
-                    else
+                    CTxOut newTxOut(cvTarget, scriptChange);
+
                     {
                         // Insert change txn at random position:
                         nChangePosRet = GetRandInt(txNew.vout.size()+1);
                         vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosRet;
                         txNew.vout.insert(position, newTxOut);
                     }
+    ////////////////////////////////////////////////////
                 }
-                else
-                    reservekey.ReturnKey();
-
-                // Fill vin
-                //
-                // Note how the sequence number is set to max()-1 so that the
-                // nLockTime set above actually works.
-                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)
-                    txNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second,CScript(),
-                                              std::numeric_limits<unsigned int>::max()-1));
-
-                // Sign
-                int nIn = 0;
-                CTransaction txNewConst(txNew);
-                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)
-                {
-                    bool signSuccess;
-                    const CScript& scriptPubKey = coin.first->vout[coin.second].scriptPubKey;
-                    CScript& scriptSigRes = txNew.vin[nIn].scriptSig;
-                    if (sign)
-                        signSuccess = ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, scriptSigRes);
-                    else
-                        signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, scriptSigRes);
+            }
+            else
+                reservekey.ReturnKey();
 
-                    if (!signSuccess)
-                    {
-                        strFailReason = _("Signing transaction failed");
-                        return false;
-                    }
-                    nIn++;
-                }
+            // Add self authorization
+            set<CKeyID> setAddress; 
+            vector<CKeyID> vectorAddress;
+
+            GetAllReserveKeys(setAddress, vectorAddress);
 
-                unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);
+            valtype ids;
 
-                // Remove scriptSigs if we used dummy signatures for fee calculation
-                if (!sign) {
-                    BOOST_FOREACH (CTxIn& vin, txNew.vin)
-                        vin.scriptSig = CScript();
+            setAddress.clear();
+            BOOST_FOREACH(const CKeyID& id, vectorAddress) {
+                // uint160 baseid = *((uint160*)&id);
+                uint160 baseid = (uint160)id;
+
+                if (setAuthorizedAddress.count(id) == 0 && baseid != uint160() && !chainActive.TransIdPresent(make_pair(false, baseid))) {
+                    ids.push_back(false);
+                    ids.insert(ids.end(), baseid.begin(), baseid.end());
+                    setAddress.insert(id);
+                    if (ids.size() >= 21 * 4000) break;
                 }
+            }
 
-                // Embed the constructed transaction data in wtxNew.
-                *static_cast<CTransaction*>(&wtxNew) = CTransaction(txNew);
+            if (ids.size() >= 21) {
+                valtype authids;
+                authids.push_back(USER_AUTH_TRANS_IDS);
+                authids.insert(authids.end(), ids.begin(), ids.end());
+                txNew.vout.push_back(CTxOut(std::make_pair(0, 0), CScript() << OP_RETURN << authids));
 
-                // Limit size
-                if (nBytes >= MAX_STANDARD_TX_SIZE)
+            }
+            // Fill vin
+            //
+            // Note how the sequence number is set to max()-1 so that the
+            // nLockTime set above actually works.
+            BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)
+                txNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second,CScript(),
+                                          std::numeric_limits<unsigned int>::max()-1));
+
+            // Sign
+            int nIn = 0;
+            CTransaction txNewConst(txNew);
+            BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)
+            {
+                bool signSuccess;
+                const CScript& scriptPubKey = coin.first->vout[coin.second].scriptPubKey;
+                CScript& scriptSigRes = txNew.vin[nIn].scriptSig;
+                if (sign)
+                    signSuccess = ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, scriptSigRes);
+                else
+                    signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, scriptSigRes);
+
+                if (!signSuccess)
                 {
-                    strFailReason = _("Transaction too large");
+                    strFailReason = _("Signing transaction failed");
                     return false;
                 }
+                nIn++;
+            }
 
-                dPriority = wtxNew.ComputePriority(dPriority, nBytes);
+            unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);
 
-                // Can we complete this as a free transaction?
-                if (fSendFreeTransactions && nBytes <= MAX_FREE_TRANSACTION_CREATE_SIZE)
-                {
-                    // Not enough fee: enough priority?
-                    double dPriorityNeeded = mempool.estimateSmartPriority(nTxConfirmTarget);
-                    // Require at least hard-coded AllowFree.
-                    if (dPriority >= dPriorityNeeded && AllowFree(dPriority))
-                        break;
-                }
+            // Remove scriptSigs if we used dummy signatures for fee calculation
+            if (!sign) {
+                BOOST_FOREACH (CTxIn& vin, txNew.vin)
+                    vin.scriptSig = CScript();
+            }
 
-                CAmount nFeeNeeded = GetMinimumFee(nBytes, nTxConfirmTarget, mempool);
-                if (coinControl && nFeeNeeded > 0 && coinControl->nMinimumTotalFee > nFeeNeeded) {
-                    nFeeNeeded = coinControl->nMinimumTotalFee;
-                }
+            // Embed the constructed transaction data in wtxNew.
+            *static_cast<CTransaction*>(&wtxNew) = CTransaction(txNew);
 
-                // If we made it here and we aren't even able to meet the relay fee on the next pass, give up
-                // because we must be at the maximum allowed fee.
-                if (nFeeNeeded < ::minRelayTxFee.GetFee(nBytes))
-                {
-                    strFailReason = _("Transaction too large for fee policy");
-                    return false;
-                }
+            // Limit size
+            if (nBytes >= MAX_STANDARD_TX_SIZE)
+            {
+                strFailReason = _("Transaction too large");
+                return false;
+            }
+            setAuthorizedAddress.insert(setAddress.begin(), setAddress.end()); 
+        }
+    }
+
+    return true;
+}
+
+void CWallet::ReverseTransForBooking(const CBlock &blk)
+{
+    // Abandon the POS transaction
+    LOCK(cs_wallet);
+
+    if (ISMINE_SPENDABLE != ::IsMine(*this, blk.vtx[0].vout[0].scriptPubKey)) return;
 
-                if (nFeeRet >= nFeeNeeded)
-                    break; // Done, enough fee included.
+    const uint256& hashTx = blk.vtx[0].GetHash();
+    if (!AbandonTransaction(hashTx)) {
+        LogPrintf("%s: Abandon POS transaction %s failed.\n", __func__, hashTx.ToString());
+    }
+
+    LogPrintf("%s: Abandoned POS transaction %s.\n", __func__, hashTx.ToString());
+
+    // Todo: return the reserved key
+}
+
+void CWallet::TransForBooking(CBlock &blk, const CBlockIndex& tip)
+{
+    //////////////////////////////////////////////////////////////
+
+
+    LOCK(cs_wallet);
 
-                // Include more fee and try again.
-                nFeeRet = nFeeNeeded;
+    uint32_t nLockTime = chainActive.Tip()->GetMedianTimePast() - 1;
+
+    if (GetRandInt(10) == 0)
+        nLockTime = std::max(0, (int)nLockTime - GetRandInt(100));
+
+    assert(nLockTime >= LOCKTIME_THRESHOLD);
+
+    // Calculate spendable asset number 0
+    int64_t totalCoinSeconds = 0;
+    CKey key;
+
+    typedef std::multimap<int64_t, std::pair<COutput, int64_t> > coin_map;
+    coin_map vCoins;
+    {
+        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
+        {
+            const uint256& wtxid = it->first;
+            const CWalletTx* pcoin = &(*it).second;
+            const CBlockIndex* coinblk;
+
+            if (!CheckFinalTx(*pcoin))
                 continue;
+
+            if (!pcoin->IsTrusted())
+                continue;
+
+            int nDepth = pcoin->GetDepthInMainChain(coinblk);
+            if (nDepth <= 0)
+                continue;
+
+            int64_t coinSeconds = tip.GetBlockTime() - coinblk->GetBlockTime();
+            if (coinSeconds < 0) continue;
+
+            // Add and minimize the tip stake weight
+            if (coinSeconds == 0) coinSeconds = 1;
+            coinSeconds = chainActive.GetSecondsDecayed(coinSeconds);
+
+            for (unsigned int i = 0; i < pcoin->vout.size(); i++) {
+                isminetype mine = IsMine(pcoin->vout[i]);
+                if (!(IsSpent(wtxid, i)) && mine == ISMINE_SPENDABLE &&
+                    !IsLockedCoin((*it).first, i) && pcoin->vout[i].nValue.first == 0 && pcoin->vout[i].nValue.second > 0) {
+                        const CScript& scriptPubKey = pcoin->vout[i].scriptPubKey;
+                        vector<valtype> vSolutions;
+                        txnouttype whichType;
+
+                        uint32_t nCoinLockTime;
+
+                        if (!Solver(scriptPubKey, whichType, vSolutions, &nCoinLockTime))
+                            return;
+
+                        if (nCoinLockTime > nLockTime)
+                            continue;
+                        // Consider only public key hash type
+                        if (whichType != TX_PUBKEYHASH)
+                            continue;
+
+                        if (i == 0) {
+                            // Sign block header with the key of the first vin
+                            if (!GetKey(CKeyID(uint160(vSolutions[0])), key))
+                                return;
+                        }
+                        int64_t shares = pcoin->vout[i].nValue.second;
+                        int64_t nCoinSeconds = shares * coinSeconds;
+                        totalCoinSeconds += nCoinSeconds;
+                        vCoins.insert(std::make_pair(nCoinSeconds, std::make_pair(COutput(pcoin, i, nDepth, true, false), shares)));
+                }
             }
         }
     }
 
-    return true;
+    if (totalCoinSeconds <= 0) return;
+
+    CReserveKey reservekey(this);
+    CWalletTx wtxNew;
+    wtxNew.fTimeReceivedIsTxTime = true;
+    wtxNew.BindWallet(this);
+    CMutableTransaction txNew;
+
+    txNew.nLockTime = nLockTime;
+
+    txNew.vin.clear();
+    txNew.vout.clear();
+    wtxNew.fFromMe = true;
+    wtxNew.bFirstTx = true;
+
+    // Fill vin
+    //
+    // Note how the sequence number is set to max()-1 so that the
+    // nLockTime set above actually works.
+
+    int64_t nCoinSeconds = 0;
+
+    CValue valueOut(0,0);
+
+    BOOST_FOREACH(const coin_map::value_type& coin, vCoins) {
+        // Divide total stake by six (TODO: which might be a dynamic number by operator action)
+        if (nCoinSeconds >= totalCoinSeconds / 6) break;
+
+        txNew.vin.push_back(CTxIn(coin.second.first.tx->GetHash(),coin.second.first.i,CScript(),
+                                  std::numeric_limits<unsigned int>::max()-1));
+
+        nCoinSeconds += coin.first;
+        valueOut.second += coin.second.second;
+    }
+
+    if (txNew.vin.size() == 0) return;
+
+    CScript scriptSelf;
+
+    {
+        // Reserve a new key pair from key pool
+        CPubKey vchPubKey;
+
+        if (!reservekey.GetReservedKey(vchPubKey)) {
+            // Default to primary key
+            vchPubKey = vchDefaultKey;
+
+            if (!HaveKey(vchPubKey.GetID()))
+                return;
+        }
+
+        scriptSelf = GetScriptForDestination(vchPubKey.GetID());
+    }
+
+    {
+        // Insert change txn at random position:
+        txNew.vout.push_back(CTxOut(valueOut, scriptSelf));
+    }
+
+    CScript scriptFirstPubKey;
+    // Sign
+    unsigned int nIn = 0;
+    CTransaction txNewConst(txNew);
+    // BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)
+    BOOST_FOREACH(const coin_map::value_type& coin, vCoins) {
+        bool signSuccess;
+        const CScript& scriptPubKey = coin.second.first.tx->vout[coin.second.first.i].scriptPubKey;
+        if (nIn == 0) scriptFirstPubKey = scriptPubKey;
+        CScript& scriptSigRes = txNew.vin[nIn].scriptSig;
+
+        signSuccess = ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, scriptSigRes);
+
+        if (!signSuccess)
+        {
+            reservekey.ReturnKey();
+            return;
+        }
+        nIn++;
+        if (nIn >= txNew.vin.size()) break;
+    }
+
+    unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);
+
+    // Embed the constructed transaction data in wtxNew.
+    *static_cast<CTransaction*>(&wtxNew) = CTransaction(txNew);
+
+    // Limit size
+    if (nBytes >= MAX_STANDARD_TX_SIZE)
+    {
+        reservekey.ReturnKey();
+        return;
+    }
+
+    blk.vtx[0] = txNew;
+    blk.hashMerkleRoot = BlockMerkleRoot(blk);
+    blk.nRootHeight = tip.nRootHeight;
+    blk.nOperatorHeight = tip.nOperatorHeight;
+    blk.nChainStakeSeconds = tip.nChainStakeSeconds + nCoinSeconds;
+
+    txNew.vout[0].scriptPubKey = CScript() << OP_RETURN << ToByteVector(blk.GetHash());
+
+    {
+        CTransaction txNewConst(txNew);
+        // BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)
+
+        if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, 0, SIGHASH_ALL), scriptFirstPubKey, blk.vchBlockSig))
+        {
+            reservekey.ReturnKey();
+            return;
+        }
+
+        // Remove the last element to avoid redundance
+        vector<unsigned char> vDustBin;
+        blk.vchBlockSig >> vDustBin;
+    }
+
+    // Hack fBroadcastTransactions to avoid memory pool and relay
+    bool tmp = fBroadcastTransactions;
+    fBroadcastTransactions = false;
+    CommitTransaction(wtxNew, reservekey);
+    fBroadcastTransactions = tmp;
+
+    return;
+
 }
 
 /**
@@ -2243,7 +2459,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)
 {
     {
         LOCK2(cs_main, cs_wallet);
-        LogPrintf("CommitTransaction:\n%s", wtxNew.ToString());
+        // LogPrintf("CommitTransaction:\n%s", wtxNew.ToString());
         {
             // This is only to keep the database open to defeat the auto-flush for the
             // duration of this scope.  This is the only place where this optimization
@@ -2273,13 +2489,13 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)
         // Track how many getdata requests our transaction gets
         mapRequestCount[wtxNew.GetHash()] = 0;
 
-        if (fBroadcastTransactions)
+        if (fBroadcastTransactions && !wtxNew.bFirstTx)
         {
             // Broadcast
-            if (!wtxNew.AcceptToMemoryPool(false))
+            if (!wtxNew.AcceptToMemoryPool())
             {
                 // This must not fail. The transaction has already been signed and recorded.
-                LogPrintf("CommitTransaction(): Error: Transaction not valid\n");
+                LogPrintf("CommitTransaction(): Error: Transaction not valid: %s\n", wtxNew.GetHash().ToString());
                 return false;
             }
             wtxNew.RelayWalletTransaction();
@@ -2300,34 +2516,6 @@ bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, CWalletDB & pw
     return true;
 }
 
-CAmount CWallet::GetRequiredFee(unsigned int nTxBytes)
-{
-    return std::max(minTxFee.GetFee(nTxBytes), ::minRelayTxFee.GetFee(nTxBytes));
-}
-
-CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool)
-{
-    // payTxFee is user-set "I want to pay this much"
-    CAmount nFeeNeeded = payTxFee.GetFee(nTxBytes);
-    // User didn't set: use -txconfirmtarget to estimate...
-    if (nFeeNeeded == 0) {
-        int estimateFoundTarget = nConfirmTarget;
-        nFeeNeeded = pool.estimateSmartFee(nConfirmTarget, &estimateFoundTarget).GetFee(nTxBytes);
-        // ... unless we don't have enough mempool data for estimatefee, then use fallbackFee
-        if (nFeeNeeded == 0)
-            nFeeNeeded = fallbackFee.GetFee(nTxBytes);
-    }
-    // prevent user from paying a fee below minRelayTxFee or minTxFee
-    nFeeNeeded = std::max(nFeeNeeded, GetRequiredFee(nTxBytes));
-    // But always obey the maximum
-    if (nFeeNeeded > maxTxFee)
-        nFeeNeeded = maxTxFee;
-    return nFeeNeeded;
-}
-
-
-
-
 DBErrors CWallet::LoadWallet(bool& fFirstRunRet)
 {
     if (!fFileBacked)
@@ -2502,6 +2690,13 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)
     {
         LOCK(cs_wallet);
 
+        if (vchDefaultKey.IsValid()) {
+            // this public key is not authorized
+            if (chainActive.GetPrimeId(make_pair(false, (uint160)(vchDefaultKey.GetID()))) == std::make_pair(false, uint160())) {
+                return;
+            }
+        }
+
         if (!IsLocked())
             TopUpKeyPool();
 
@@ -2512,18 +2707,29 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)
         CWalletDB walletdb(strWalletFile);
 
         nIndex = *(setKeyPool.begin());
-        setKeyPool.erase(setKeyPool.begin());
         if (!walletdb.ReadPool(nIndex, keypool))
             throw runtime_error("ReserveKeyFromKeyPool(): read failed");
+
+        if (!vchDefaultKey.IsValid() || chainActive.GetPrimeId(make_pair(false, (uint160)(keypool.vchPubKey.GetID()))) != std::make_pair(false, uint160())) {
+            setKeyPool.erase(setKeyPool.begin());
+        }
+        else {
+            nIndex = -1;
+            return;
+        }
+
         if (!HaveKey(keypool.vchPubKey.GetID()))
             throw runtime_error("ReserveKeyFromKeyPool(): unknown key in key pool");
         assert(keypool.vchPubKey.IsValid());
+
         LogPrintf("keypool reserve %d\n", nIndex);
     }
 }
 
 void CWallet::KeepKey(int64_t nIndex)
 {
+    // Hack for reusage of default key
+    if (nIndex == 1) return;
     // Remove from key pool
     if (fFileBacked)
     {
@@ -2552,9 +2758,7 @@ bool CWallet::GetKeyFromPool(CPubKey& result)
         ReserveKeyFromKeyPool(nIndex, keypool);
         if (nIndex == -1)
         {
-            if (IsLocked()) return false;
-            result = GenerateNewKey();
-            return true;
+            return false;
         }
         KeepKey(nIndex);
         result = keypool.vchPubKey;
@@ -2601,10 +2805,13 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()
                 if(!ExtractDestination(pcoin->vout[i].scriptPubKey, addr))
                     continue;
 
-                CAmount n = IsSpent(walletEntry.first, i) ? 0 : pcoin->vout[i].nValue;
+                CAmount n;
 
                 if (!balances.count(addr))
-                    balances[addr] = 0;
+                    balances[addr] = n;
+
+                if (!IsSpent(walletEntry.first, i)) n += pcoin->vout[i].nValue;
+
                 balances[addr] += n;
             }
         }
@@ -2753,9 +2960,10 @@ void CReserveKey::ReturnKey()
     vchPubKey = CPubKey();
 }
 
-void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const
+void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress, vector<CKeyID>& vectorAddress) const
 {
     setAddress.clear();
+    vectorAddress.clear();
 
     CWalletDB walletdb(strWalletFile);
 
@@ -2769,7 +2977,11 @@ void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const
         CKeyID keyID = keypool.vchPubKey.GetID();
         if (!HaveKey(keyID))
             throw runtime_error("GetAllReserveKeyHashes(): unknown key in key pool");
-        setAddress.insert(keyID);
+
+        if (setAddress.count(keyID) == 0) {
+            setAddress.insert(keyID);
+            vectorAddress.push_back(keyID);
+        }
     }
 }
 
@@ -2784,17 +2996,6 @@ void CWallet::UpdatedTransaction(const uint256 &hashTx)
     }
 }
 
-void CWallet::GetScriptForMining(boost::shared_ptr<CReserveScript> &script)
-{
-    boost::shared_ptr<CReserveKey> rKey(new CReserveKey(this));
-    CPubKey pubkey;
-    if (!rKey->GetReservedKey(pubkey))
-        return;
-
-    script = rKey;
-    script->reserveScript = CScript() << ToByteVector(pubkey) << OP_CHECKSIG;
-}
-
 void CWallet::LockCoin(COutPoint& output)
 {
     AssertLockHeld(cs_wallet); // setLockedCoins
@@ -2995,6 +3196,9 @@ int CMerkleTx::SetMerkleBranch(const CBlock& block)
         return 0;
     }
 
+    if (nIndex == 0) 
+        bFirstTx = true;
+
     // Is the tx in a block that's in the main chain
     BlockMap::iterator mi = mapBlockIndex.find(hashBlock);
     if (mi == mapBlockIndex.end())
@@ -3033,8 +3237,13 @@ int CMerkleTx::GetBlocksToMaturity() const
 }
 
 
-bool CMerkleTx::AcceptToMemoryPool(bool fLimitFree, bool fRejectAbsurdFee)
+bool CMerkleTx::AcceptToMemoryPool()
 {
+    bool res;
     CValidationState state;
-    return ::AcceptToMemoryPool(mempool, state, *this, fLimitFree, NULL, false, fRejectAbsurdFee);
+    res = ::AcceptToMemoryPool(mempool, state, *this, NULL, false);
+    if (res) return true;
+
+    LogPrintf("reject code: %d, reason: %s, debug messget: %s\n", state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());
+    return false;
 }
diff --git a/src/wallet/wallet.h b/src/wallet/wallet.h
index f7e57e205..3e9721f16 100644
--- a/src/wallet/wallet.h
+++ b/src/wallet/wallet.h
@@ -30,35 +30,14 @@
 /**
  * Settings
  */
-extern CFeeRate payTxFee;
-extern CAmount maxTxFee;
 extern unsigned int nTxConfirmTarget;
 extern bool bSpendZeroConfChange;
-extern bool fSendFreeTransactions;
 
 static const unsigned int DEFAULT_KEYPOOL_SIZE = 100;
-//! -paytxfee default
-static const CAmount DEFAULT_TRANSACTION_FEE = 0;
-//! -paytxfee will warn if called with a higher fee than this amount (in satoshis) per KB
-static const CAmount nHighTransactionFeeWarning = 0.01 * COIN;
-//! -fallbackfee default
-static const CAmount DEFAULT_FALLBACK_FEE = 20000;
-//! -mintxfee default
-static const CAmount DEFAULT_TRANSACTION_MINFEE = 1000;
-//! -maxtxfee default
-static const CAmount DEFAULT_TRANSACTION_MAXFEE = 0.1 * COIN;
-//! minimum change amount
-static const CAmount MIN_CHANGE = CENT;
 //! Default for -spendzeroconfchange
 static const bool DEFAULT_SPEND_ZEROCONF_CHANGE = true;
-//! Default for -sendfreetransactions
-static const bool DEFAULT_SEND_FREE_TRANSACTIONS = false;
 //! -txconfirmtarget default
 static const unsigned int DEFAULT_TX_CONFIRM_TARGET = 2;
-//! -maxtxfee will warn if called with a higher fee than this amount (in satoshis)
-static const CAmount nHighTransactionMaxFeeWarning = 100 * nHighTransactionFeeWarning;
-//! Largest (in bytes) free transaction we're willing to create
-static const unsigned int MAX_FREE_TRANSACTION_CREATE_SIZE = 1000;
 static const bool DEFAULT_WALLETBROADCAST = true;
 
 class CAccountingEntry;
@@ -122,8 +101,7 @@ public:
 struct CRecipient
 {
     CScript scriptPubKey;
-    CAmount nAmount;
-    bool fSubtractFeeFromAmount;
+    CValue nAmount;
 };
 
 typedef std::map<std::string, std::string> mapValue_t;
@@ -150,7 +128,7 @@ static void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)
 struct COutputEntry
 {
     CTxDestination destination;
-    CAmount amount;
+    CValue amount;
     int vout;
 };
 
@@ -170,6 +148,7 @@ public:
      * compatibility.
      */
     int nIndex;
+    bool bFirstTx;
 
     CMerkleTx()
     {
@@ -185,6 +164,7 @@ public:
     {
         hashBlock = uint256();
         nIndex = -1;
+        bFirstTx = false;
     }
 
     ADD_SERIALIZE_METHODS;
@@ -197,6 +177,7 @@ public:
         READWRITE(hashBlock);
         READWRITE(vMerkleBranch);
         READWRITE(nIndex);
+        READWRITE(bFirstTx);
     }
 
     int SetMerkleBranch(const CBlock& block);
@@ -211,7 +192,7 @@ public:
     int GetDepthInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }
     bool IsInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet) > 0; }
     int GetBlocksToMaturity() const;
-    bool AcceptToMemoryPool(bool fLimitFree=true, bool fRejectAbsurdFee=true);
+    bool AcceptToMemoryPool();
     bool hashUnset() const { return (hashBlock.IsNull() || hashBlock == ABANDON_HASH); }
     bool isAbandoned() const { return (hashBlock == ABANDON_HASH); }
     void setAbandoned() { hashBlock = ABANDON_HASH; }
@@ -295,15 +276,6 @@ public:
         fImmatureWatchCreditCached = false;
         fAvailableWatchCreditCached = false;
         fChangeCached = false;
-        nDebitCached = 0;
-        nCreditCached = 0;
-        nImmatureCreditCached = 0;
-        nAvailableCreditCached = 0;
-        nWatchDebitCached = 0;
-        nWatchCreditCached = 0;
-        nAvailableWatchCreditCached = 0;
-        nImmatureWatchCreditCached = 0;
-        nChangeCached = 0;
         nOrderPos = -1;
     }
 
@@ -373,21 +345,20 @@ public:
     //! filter decides which addresses will count towards the debit
     CAmount GetDebit(const isminefilter& filter) const;
     CAmount GetCredit(const isminefilter& filter) const;
-    CAmount GetImmatureCredit(bool fUseCache=true) const;
     CAmount GetAvailableCredit(bool fUseCache=true) const;
     CAmount GetImmatureWatchOnlyCredit(const bool& fUseCache=true) const;
     CAmount GetAvailableWatchOnlyCredit(const bool& fUseCache=true) const;
     CAmount GetChange() const;
 
     void GetAmounts(std::list<COutputEntry>& listReceived,
-                    std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;
+                    std::list<COutputEntry>& listSent, std::string& strSentAccount, const isminefilter& filter) const;
 
     void GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,
-                           CAmount& nSent, CAmount& nFee, const isminefilter& filter) const;
+                           CAmount& nSent, const isminefilter& filter) const;
 
     bool IsFromMe(const isminefilter& filter) const
     {
-        return (GetDebit(filter) > 0);
+        return (GetDebit(filter) > CAmount());
     }
 
     // True if only scriptSigs are different
@@ -416,10 +387,11 @@ public:
     int i;
     int nDepth;
     bool fSpendable;
+    bool fChecked;
 
-    COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn)
+    COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn, bool fCheckedIn)
     {
-        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn;
+        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fChecked = fCheckedIn;
     }
 
     std::string ToString() const;
@@ -468,7 +440,7 @@ private:
      * all coins from coinControl are selected; Never select unconfirmed coins
      * if they are not ours
      */
-    bool SelectCoins(const CAmount& nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL) const;
+    bool SelectCoins(const CAmount& nTargetValue, uint32_t& nLockTime, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL) const;
 
     CWalletDB *pwalletdbEncryption;
 
@@ -497,6 +469,8 @@ private:
 
     void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>);
 
+    std::set<CKeyID> setAuthorizedAddress;
+
 public:
     /*
      * Main wallet lock.
@@ -576,7 +550,7 @@ public:
     /**
      * populate vCoins with vector of available COutputs.
      */
-    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed=true, const CCoinControl *coinControl = NULL, bool fIncludeZeroValue=false) const;
+    void AvailableCoins(std::vector<std::pair<COutput, uint32_t> >& vCoins, bool fOnlyConfirmed=true, const CCoinControl *coinControl = NULL, bool fIncludeZeroValue=false, bool fOnlyChecked=false) const;
 
     /**
      * Shuffle and select coins until nTargetValue is reached while avoiding
@@ -608,6 +582,8 @@ public:
 
     bool LoadMinVersion(int nVersion) { AssertLockHeld(cs_wallet); nWalletVersion = nVersion; nWalletMaxVersion = std::max(nWalletMaxVersion, nVersion); return true; }
 
+    bool inner_SelectCoinsMinConf(const CValue& NtARGETvALUE, const int nConfMine, const int nConfTheirs, std::vector<COutput> vCoins,
+                                     std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CValue& NvALUErET) const;
     //! Adds an encrypted key to the store, and saves it to disk.
     bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);
     //! Adds an encrypted key to the store, without saving it to disk (used by LoadWallet)
@@ -652,40 +628,25 @@ public:
     std::vector<uint256> ResendWalletTransactionsBefore(int64_t nTime);
     CAmount GetBalance() const;
     CAmount GetUnconfirmedBalance() const;
-    CAmount GetImmatureBalance() const;
     CAmount GetWatchOnlyBalance() const;
     CAmount GetUnconfirmedWatchOnlyBalance() const;
-    CAmount GetImmatureWatchOnlyBalance() const;
 
     /**
      * Insert additional inputs into the transaction by
      * calling CreateTransaction();
      */
-    bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosRet, std::string& strFailReason, bool includeWatching);
+    bool FundTransaction(CMutableTransaction& tx, int& nChangePosRet, std::string& strFailReason, bool includeWatching);
 
     /**
      * Create a new transaction paying the recipients with a set of coins
      * selected by SelectCoins(); Also create the change output, when needed
      */
-    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosRet,
+    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int& nChangePosRet,
                            std::string& strFailReason, const CCoinControl *coinControl = NULL, bool sign = true);
     bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey);
 
     bool AddAccountingEntry(const CAccountingEntry&, CWalletDB & pwalletdb);
 
-    static CFeeRate minTxFee;
-    static CFeeRate fallbackFee;
-    /**
-     * Estimate the minimum fee considering user set parameters
-     * and the required fee
-     */
-    static CAmount GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool);
-    /**
-     * Return the minimum required fee taking into account the
-     * floating relay fee and user set minimum transaction fee
-     */
-    static CAmount GetRequiredFee(unsigned int nTxBytes);
-
     bool NewKeyPool();
     bool TopUpKeyPool(unsigned int kpSize = 0);
     void ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool);
@@ -693,7 +654,7 @@ public:
     void ReturnKey(int64_t nIndex);
     bool GetKeyFromPool(CPubKey &key);
     int64_t GetOldestKeyPoolTime();
-    void GetAllReserveKeys(std::set<CKeyID>& setAddress) const;
+    void GetAllReserveKeys(std::set<CKeyID>& setAddress, std::vector<CKeyID>& vectorAddress) const;
 
     std::set< std::set<CTxDestination> > GetAddressGroupings();
     std::map<CTxDestination, CAmount> GetAddressBalances();
@@ -701,11 +662,11 @@ public:
     std::set<CTxDestination> GetAccountAddresses(const std::string& strAccount) const;
 
     isminetype IsMine(const CTxIn& txin) const;
-    CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;
+    CValue GetDebit(const CTxIn& txin, const isminefilter& filter) const;
     isminetype IsMine(const CTxOut& txout) const;
-    CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const;
+    CValue GetCredit(const CTxOut& txout, const isminefilter& filter) const;
     bool IsChange(const CTxOut& txout) const;
-    CAmount GetChange(const CTxOut& txout) const;
+    CValue GetChange(const CTxOut& txout) const;
     bool IsMine(const CTransaction& tx) const;
     /** should probably be renamed to IsRelevantToMe */
     bool IsFromMe(const CTransaction& tx) const;
@@ -733,7 +694,8 @@ public:
         }
     }
 
-    void GetScriptForMining(boost::shared_ptr<CReserveScript> &script);
+    void TransForBooking(CBlock &blk, const CBlockIndex& tip);
+    void ReverseTransForBooking(const CBlock &blk);
     void ResetRequestCount(const uint256 &hash)
     {
         LOCK(cs_wallet);
@@ -877,7 +839,7 @@ public:
 
     void SetNull()
     {
-        nCreditDebit = 0;
+        nCreditDebit.clear();
         nTime = 0;
         strAccount.clear();
         strOtherAccount.clear();
diff --git a/src/wallet/walletdb.cpp b/src/wallet/walletdb.cpp
index b1b9d0c23..3aa6ad09c 100644
--- a/src/wallet/walletdb.cpp
+++ b/src/wallet/walletdb.cpp
@@ -201,7 +201,7 @@ CAmount CWalletDB::GetAccountCreditDebit(const string& strAccount)
     list<CAccountingEntry> entries;
     ListAccountCreditDebit(strAccount, entries);
 
-    CAmount nCreditDebit = 0;
+    CAmount nCreditDebit;
     BOOST_FOREACH (const CAccountingEntry& entry, entries)
         nCreditDebit += entry.nCreditDebit;
 
@@ -619,7 +619,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)
     DBErrors result = DB_LOAD_OK;
 
     try {
-        LOCK(pwallet->cs_wallet);
+        LOCK2(cs_main, pwallet->cs_wallet); // LOCK(pwallet->cs_wallet);
         int nMinVersion = 0;
         if (Read((string)"minversion", nMinVersion))
         {
